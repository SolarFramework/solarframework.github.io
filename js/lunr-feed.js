// builds lunr
var index = lunr(function () {
  this.field('title')
  this.field('content', {boost: 10})
  this.ref('id')
});



index.add({
    title: "GIT",
    content: "GIT\n\nTable of Contents\n\nGIT[[GIT repositories]]\nAccess to code source here\n\nThe direct links to repositories\n\n\nHow to contribute\nAccess to Pull Requests\nAccess to issues\n\n\n\nGIT[[GIT repositories]]\n\n\n\n\n\nAccess to code source here\n\n\nTo get access to the list of all SolAR repositories: https://github.com/SolarFramework\n\n\nThe direct links to repositories\n\n\n\n\n\n\n\n\n\nName\nGitHub url\n\n\nFramework\nSolARframework\nhttps://github.com/SolarFramework/SolARFramework\n\n\nbuild_scripts\nhttps://github.com/SolarFramework/build-scripts\n\n\nModules\nSolARModuleOpenCV\nhttps://github.com/SolarFramework/SolARModuleOpenCV\n\n\nSolARModuleNonFreeOpenCV\nhttps://github.com/SolarFramework/SolARModuleNonFreeOpenCV\n\n\nSolARModuleTools\nhttps://github.com/SolarFramework/SolARModuleTools\n\n\nSolARModuleFBOW\nhttps://github.com/SolarFramework/SolARModuleFBOW\n\n\nSolARModuleOpenGV\nhttps://github.com/SolarFramework/SolARModuleOpenGV\n\n\nSolARModuleCeres\nhttps://github.com/SolarFramework/SolARModuleCeres\n\n\nSolARModuleOpenGL\nhttps://github.com/SolarFramework/SolARModuleOpenGL\n\n\nSamples\nNatural Image Marker\nhttps://github.com/SolarFramework/NaturalImageMarker\n\n\nFiducial Marker\nhttps://github.com/SolarFramework/FiducialMarker\n\n\n Sample-Slam\nhttps://github.com/SolarFramework/Sample-Slam\n\n\nSample-Triangulation\nhttps://github.com/SolarFramework/Sample-Triangulation\n\n\n\n\n\n\n\nHow to contribute\n\n\nPlease refer to our contribution workflow section\n\n\n\n\nAccess to Pull Requests\n\n\nhttps://solarframework.github.io/SolAR-githubPullRequests.html\n\n\n\n\nAccess to issues\n\n\n\n\nFor open issues visit https://github.com/issues?q=user%3ASolarFramework+is%3Aopen\n\n\n\n\n",
    id: 0
  });
  

index.add({
    title: "About",
    content: "About\n\nAbout us\n\n\n\n\n\nWho initiated Solar ?\n\n\nThe SolAR initiative was launched by the b&lt;&gt;com Institute of Research and Technology, and is open to any contributors or users who share the SolAR goals.\n\n\n\n\n\n\n\n\n\nOur first Contributors\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nContact US\n\n\nFor any requests, please contact us.\n\n\n",
    id: 1
  });
  

index.add({
    title: "for Android development",
    content: "\nTable of Contents\n\nInstall for Android\nTest SolAR\nInstall development environment\n\nInstall Qt Creator IDE\nInstall Android SDK and NDK\nConfigure Qt Android Kit\n\n\nBuild SolAR v0.9.0\n\nClone SolAR\nBuild on Qt Creator\n\n\nUnity SolAR Android\n\n\n\nInstall for Android\n\n\n\n\n\nTest SolAR\n\n\nWe provide you a bundle to test our samples code. It is .zip file including SolAR&#8217;s .apk and markers if required.\n\n\nTable 1. Available Samples\n\n\n\n\n\n\nSolAR Demo (Fiducial, Natural, SLAM)\nv0.8.0 download link (V0.9.0 coming soon)\n\n\n\n\n\n\n\n\n\n\nPrint the marker included in .zip file to use it during the test.\n\n\n\n\n\n\n\nInstall development environment\n\n\nInstall Qt Creator IDE\n\nThe SolAR framework uses a dedicated pipeline to link and compile code as well as internal tools for third party downloads which should make your job much easier.\nAs you will see later, the SolAR framework is based on QMake originally created by the Qt Company, but compliant with most IDE.\n\n\nRefer to your OS section to install your development environment, whether on Windows or Linux.\n\n\n\n\n\n\n\n\nDo not forget to install Qt Android component. SolAR supports arm64-v8a architecture only.\n\n\n\n\n\n\n\n\n\n\n\nIt is recommended to install IDE for your own OS to test directly your pipeline on your system and then compile it for Android\n\n\n\n\n\n\nInstall Android SDK and NDK\n\nOnce Qt Creator installed we can install dependencies required by Qt Creator for Android :\n\n\n\n\n\n\n\n\nWe recommend you to install this dependencies using Unity Android build support module (available from Unity HUB, see build support)\nOtherwise you can also directly download the dependencies in Qt Creator from SDKManager in Android tab of Tools&gt;Options&gt;Devices\n\n\n\n\n\n\n\nJava SDK\n\n\nAndroid SDK\n\n\nAndroid NDK\n\n\n\n\nYou can find more information in Qt documentation : Android building\n\n\n\nConfigure Qt Android Kit\n\nIn Qt Creator navigation bar go to Tools &gt; Options &gt; Devices.\nThen fill required path and check if your Android kit is valid :\n\n\n\n\n\nFigure 1. Android kit configuration\n\n\nInstall SolAR dependencies\n\nRefer to your OS section to install Remaken, whether on Windows or Linux.\n\n\n\nSet Remaken for Android\n\nYou need to configure your Remaken profile according to your development environment. To do so, run the following command in a command prompt:\n\n\n\nremaken profile init --cpp-std 17 -b clang -o android -a arm64-v8a\n\n\n\nYou can check if the change have been done in your Remaken profile using :\n\n\n\nremaken profile display\n\n\n\n\nSet Conan profile for Android\n\nAs we are using Conan to download dependencies, you need to configure your default conan profile. To do so, open the default file available in your ${HOME}/.conan/profiles, and replace the configuration by the following one before saving it:\n\n\n\n[settings]\nos=Android\nos_build=Linux\narch=armv8\narch_build=x86_64\ncompiler=clang\ncompiler.version=8\ncompiler.libcxx=libc++\nbuild_type=Release\nos.api_level=21\ncompiler.cppstd=17\n[options]\n[build_requires]\n[env]\n\n\n\n\n\n\n\n\n\nos_build should match your OS (Windows or Linux)\n\n\n\n\n\nNow, you are ready to download your dependencies with Remaken.\n\n\n\nUse Remaken\n\nRemaken uses a file called packagedependencies.txt to describe which depedencies to install, in which version, where to install them, where to download them, with which package manager and with which configuration.\n\n\nA global packagedepedencies.txt defining the common dependencies with specific packagedependencies_os.txt files defining dependencies which are specific for each os are available in the parent GIT repository SolAR, and can be downloaded on the following link:\n\n\n\n\npackagedependencies.txt\n\n\npackagedependencies-android.txt\n\n\n\n\nCopy these files where you want on your computer, open a command prompt in the folder where you have copied the packagedependencies.txt and packagedependencies_os.txt files, and run remaken with the following command:\n\n\n\nremaken install packagedependencies.txt\n\n\n\nThis command will install all SolAR dependencies in release mode.\n\n\nTo download the dependencies in debug mode, run the following command:\n\n\n\nremaken install -c debug packagedependencies.txt\n\n\n\nThis is done, all your dependencies are downloaded and ready to use !\nSome of the module will download and build third parties using Conan which requires CMake (minimum version 3.10).\n\n\n\n\n\n\nBuild SolAR v0.9.0\n\n\nClone SolAR\n\nSolAR is made up of a multitude of projects (SolAR Framework, SolAR pipeline manager, modules, samples, etc.). To help you, we have created a parent repository with sub-modules regrouping all source codes of SolAR projects. You can clone it from the following url:\nhttps://github.com/SolarFramework/SolAR.git\n\n\n\n\n\n\n\n\nNo space in the path of the folder where you are cloning SolAR !\n\n\n\n\n\n\ngit clone https://github.com/SolarFramework/SolAR.git\n\n\n\nDo not forget to install and update recursively the submodules:\n\n\n\ncd SolAR\ngit submodule update --init --recursive\n\n\n\nIf you want to move all submodules on Master, launch the following command\n\n\n\ngit submodule foreach git pull origin master\n\n\n\nIf you do not want to download all the source codes of SolAR, you can have a look to the different repositories available on Github on the Community/Git page.\n\n\n\nBuild on Qt Creator\n\nCounting the framework, the pipeline manager, modules, module tests, samples, pipelines, pipeline tests, there are more than 60 QT projects on GitHub. In order to ease the building of all this projects, they are grouped in the following parent QT projects available into the root folder of SolAR:\n\n\n\n\nSolARCore\n\n\nSolARAllModules\n\n\nSolARAllModulesTests\n\n\nSolARAllSamples\n\n\nSolARAllPipelines\n\n\nSolARAllPipelineTests\n\n\n\n\nYou can open one of them or all in QT Creator.\n\n\nCheck by clicking on the Projects tab, and then on the Manage Kits&#8230;&#8203; button that your Qt x.x.x Android for arm64-v8a kit is well configured\n\n\nNow, you have to configure your parent project before building them. In your project build settings of your kit, for each configuration (release and debug), add the following argument to the Builds Steps &gt; Make step:\n\n\n\n\nSolARCore: install\n\n\nSolARAllModules: install and install_deps\n\n\nSolARAllModulesTests: install and install_deps\n\n\nSolARAllSamples: install and install_deps\n\n\nSolARAllPipelines: install\n\n\nSolARAllPipelineTests: install and install_deps\n\n\n\n\nThe install step  will copy the built binaries into ${HOME}/.remaken/packages, and the install_deps step will also copy its dependencies.\n\n\n\n\n\n\n\n\nDisable step Make install and Build Android APK\n\n\n\n\n\n\n\n\nFigure 2. Edit build settings\n\n\nIf you open several projects, you will have to set their build order. You can do it in QT Creator by defining the dependencies of each project in the Projects menu, select your project, click and Dependencies, and check the projects that depend directly on the selected project (checking `Synchronize configuration' will synchronize all projects in Debug or Release configuration).\n\n\n\n\n\nFigure 3. Project dependencies settings\n\n\nTable 2. Project dependencies\n\n\n\n\n\n\nProject\nProject dependencies\n\n\n\n\nSolARAllModules\nSolARCore\n\n\nSolARAllModulesTests\nSolARAllModules\n\n\nSolARAllPipelines\nSolARAllModules\n\n\nSolARAllPipelineTests\nSolARAllPipelines\n\n\nSolARAllSamples\nSolARAllModules\n\n\nSolARCore\nNo dependency\n\n\n\n\nThen, in the Build menu, click on Rebuild All Projects for All Configurations, and go get a cup of coffee.\n\n\nNow your shared libraries can be use as a SolAR module in Unity to build an Android application.\n\n\n\n\n\nUnity SolAR Android\n\n\nTo build a SolAR Android application you need to have Android build support module installed.\n\n\n\n\n\nFigure 4. Add Android build support module from Unity HUB\n\n\nSet your Unity Android environment. Then you need to set your current target platform of Unity Editor File &gt; Build settings to Android. In the player settings you must specify a package name (ex : com.company.appname) and set the configuration to support SolAR Framework.\n\n\n\n\n\n\n\n\nSolAR modules provide support for AArch64 instruction sets through Application Binary Interface arm64-v8a. This is the most common architecture used by Android devices.\n\n\n\n\n\n\n\n\nFigure 5. Set player settings for arm64-v8a and SolAR\n\n\nNow you can import your SolAR modules and their dependencies in your Unity project in the dedicated directory ./Assets/Plugins/Android/.\n\n\n\n\nIf you haven&#8217;t build or download modules and dependencies for Android, execute ./plugin/unity/SolARUnityPlugin/Install.bat.\n\n\nOtherwise you could simply execute ./plugin/unity/SolARUnityPlugin/Bundle.bat to bundle .so of your Remaken packages and wrap SWIG.\n\n\n\n\n\n\n\n\n\n\nYou cannot directly test your pipeline in Unity Editor with modules built for Android. It is recommended to develop for your OS in a first time and then provide your module for Android.\n\n\n\n\n\nCongratulation, your configuration is ready to use and you can build your .apk with Unity to play it on your Android device. If necessary you can set Unity build settings options and use ADB to debug your app.\n\n\nMoreover you can edit your pipeline configuration on your device. XML is stored in your public path of the application in your internal memory (ie : /storage/emulated/0/Android/data/com.company.appname/files/StreamingAssets/SolAR/Pipelines/*.xml)\n\n\nYou can find more information for SolAR Android Unity pipeline in Unity Android Deployment\n\n\nWindows\n\n\n",
    id: 2
  });
  

index.add({
    title: "api",
    content: "\nTable of Contents\n\nAPI\nAPI\n\n\n\nAPI\n\n\n\n\n\nAPI\n\n\nIn order to create new components, please refer to the list of available API in the SolAR framework :\n\n\n\n",
    id: 3
  });
  

index.add({
    title: "best practises",
    content: "BEST practises\n\nTable of Contents\n\nBest practices\nSolAR guidelines\n\nComponent Interfaces\nModules and Components\nComponent Implementations\nModules\nPipepline Management\n\n\nLogs to help debugging\ncoding rules\n\nProject organization\nFiles\nC / C++ Coding Rules\nLanguage features\nLibraries and headers\nNaming conventions\nDesign conventions\nLayout conventions\nTracing and debugging\nError handling\nMiscellaneous conventions\nDocumentation\nC/C++ Performance rules\nTools\n\n\nAppendix A.\tRules management\n\nI.\tResponsibility\nII.\tDeviation\nIII.\tTraining\nIV.\tControl\n\n\n\n\n\nBest practices\n\n\n\n\n\nSolAR guidelines\n\n\nThe following rules shall be used for every addition/modification to the SolAR project.\nThis encompasses the SolAR framework and the GUI interface and unless otherwise specified, these rules shall apply to both.\n\n\nComponent Interfaces\n\n1.1. Solar component interfaces are virtual base classes. They shall inherit from class org::bcom::xpcf::IComponentIntrospect\n\n\n1.2. SolAR Interfaces are defined in a dedicated header file (.h) whose name shall begin with a capital I followed with the name of the abstract class it refers to, e.g. ICamera.h.\n\n\n1.3. SolAR Interfaces shall not contain member variables, it is an abstract class without committing to a particular implementation of the class. If you need member variables, declare them in the implementation of the component\n\n\n1.4. A component interface must be a abstract class, meaning that all its methods must be virtual.\n\n\n1.5. Solar Framework is organized hierarchically via dedicated directories and namespaces. Currently, concerning the interfaces, this organization is as follows :\n\n\n\n\n\n\n\n\nDirectory\nnamespace\n\n\n\n\nSolARFramework/interfaces/api/display\nSolAR::api::display\n\n\nSolARFramework/interfaces/api/features\nSolAR::api::features\n\n\nSolARFramework/interfaces/api/geom\nSolAR::api::geom\n\n\nSolARFramework/interfaces/api/image\nSolAR::api::image\n\n\nSolARFramework/interfaces/api/input/devices\nSolAR::api::input::devices\n\n\nSolARFramework/interfaces/api/input/files\nSolAR::api::input::files\n\n\nSolARFramework/interfaces/api/sink\nSolAR::api::sink\n\n\nSolARFramework/interfaces/api/solver/map\nSolAR::api::solver::map\n\n\nSolARFramework/interfaces/api/solver/pose\nSolAR::api::solver::pose\n\n\n\n\n1.6. Namespaces should use lower case.\n\n\n1.7. Any new interface must fall into one of these categories. Yet, if needed, one may ask the SolAR Team to add a new one to fulfill a particular need not covered by the current organization.\n\n\n1.8. If possible, an abstract interface of a component must define only one processing method. Exception may be allowed if your processing method need take as an input or output only one or a collection of several objects, as for instance:\n\n\n\nvirtual void drawCircle(SRef&lt;Point2Df&gt; point, unsigned int radius, int thickness, std::vector&lt;unsigned int&gt; &amp; bgrValues, SRef&lt;Image&gt; displayImage) = 0;\n virtual void drawCircles(std::vector&lt;SRef&lt;Point2Df&gt;&gt;&amp; points, unsigned int radius, int thickness, SRef&lt;Image&gt; displayImage) = 0;\n\n\n\nor if the processing method can take as input our output parameter an object or an inherited object, as for instance:\n\n\n\nvirtual void drawCircles(std::vector&lt;SRef&lt;Point2Df&gt;&gt;&amp; points, unsigned int radius, int thickness, SRef&lt;Image&gt; displayImage) = 0;\nvirtual void drawCircles(std::vector&lt;SRef&lt;Keypoint&gt;&gt;&amp; keypoints, unsigned int radius, int thickness, SRef&lt;Image&gt; displayImage) = 0;\n\n\n\n1.9. A 128-bit UUID (Universal Unique IDentifier) shall be associated to any virtual interface and explicitly quoted in the interface header file, preferably after the class definition.\n\n\nThe syntax is the following :\n\n\n\nXPCF_DEFINE_INTERFACE_TRAITS(SolARnamespaces::IInterfaceClassName,\n                             &quot;aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee&quot;,\n                             &quot;Interface description&quot;);\n\n\n\nAn example :\n\n\n\nXPCF_DEFINE_INTERFACE_TRAITS(SolAR::api::display::I2DOverlay,\n                             &quot;62b8b0b5-9344-40e6-a288-e609eb3ff0f1&quot;,\n                             &quot;SolAR::I2DOverlay interface&quot;);\n\n\n\n1.10. The header file shall contain Doxygen documentation code in order to automatically generate the interface description web page during the continuous integration process used by the Solar Integration Team.\nIn particular the purpose of the interface shall be documented, as well as each virtual method with its input/ouput parameters.\nFor instance for class documentation:\n\n\n\n/**\n * @class I2DOverlay\n * @brief Drawing interface to overlay 2D information on top of an image.\n *\n * This class provides drawing methods to overlay 2D debug informations on top of an image.\n */\n\n\n\nand for method documentation:\n\n\n\n/// @brief Draw a Squared Binary Pattern.\n/// @param[in] pattern The squared binary pattern to display.\n/// @param[in,out] displayImage The image on which the squared binary pattern will be drawn (on the whole image).\nvirtual void drawSBPattern (SRef&lt;SquaredBinaryPattern&gt; pattern, SRef&lt;Image&gt; displayImage) = 0;\n\n\n\n\nModules and Components\n\nModules are the placeholders for the components. Basically, they are defined to reflect a particular type of implementation, based e.g. on a particular technology or a particular provider, etc &#8230;&#8203;\n\n\nA component cannot exist by itself. It must be included in a module but a module may contain only one component if needed.\n\n\nThey are are few rules that modules and components must conform to in order to be usable by SolAR. This is explained in the following.\n\n\n\n\nModules are delivered as shared libraries (windows or linux)\n\n\nThe recommended naming convention is  ModuleName, where name should reflect a characteristic of the module, e.g. ModuleOpencvFree.\n\n\nComponents are declared inside a namespace according to the following naming convention : SolAR::MODULES::NAMEOFMODULE\n\n\nA 128-bit UUID (Universal Unique IDentifier) shall be associated to every module\n\n\nA 128-bit UUID (Universal Unique IDentifier) shall be associated to every component included in a module\n\n\nA Module exports its components via a dedicated Export API defined in a header file named NameOfModuleAPI.h, such :\n\n\n\n\n\n/**\n * Copyright and license notice ......\n */\n\n#ifndef NAME_API_H\n    #define NAMEOFMODULE_API_H\n    #if _WIN32\n        #ifdef NameOfModule_API_DLLEXPORT\n            #define NAMEOFMODULE_EXPORT_API __declspec(dllexport)\n        #else //NameOfModule_API_DLLEXPORT\n            #define NAMEOFMODULE_EXPORT_API __declspec(dllimport)\n        #endif //NameOfModule_API_DLLEXPORT\n    #else //_WIN32\n        #define NAMEOFMODULE_EXPORT_API\n    #endif //_WIN32\n    #include \"NameOfModule_traits.h\"\n#endif //NAMEOFMODULE_API_H\n\n\n\nand where 'NameOfModule_traits.h'  exposes the list of components contained in the module. Follows a generic example of this file.\n\n\n\n#define NAMEOFMODULE_TRAITS_H\n\n#include &quot;xpcf/component/ComponentTraits.h&quot;\n\nnamespace SolAR {\nnamespace MODULES {\nnamespace NAME {\nclass Component1;\nclass Component2;\n}\n}\n}\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::MODULES::NAME::Component1,\n                             &quot;aaaaaaaa-bbbb-cccc-dddd-eeeeeeee&quot;,\n                             &quot;SolAR::MODULES::NAME::Component1 definition&quot;)\n\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::MODULES::NAME::Component1,\n                             &quot;ffffffff-gggg-hhhh-iiii-jjjjjjjj&quot;,\n                              &quot;SolAR::MODULES::NAME::Component2 definition&quot;)\n\n\n#endif // NAMEOFMODULE_TRAITS_H\n\n\n\n\n\nThere will be a code file named NameOfModule.cpp that shall contain the Module UUID as well as which components are included and exposed in the module. The syntax is as follows.\nNameOfModule.cpp:\n\n\n\n\n\n#include \"xpcf/module/ModuleFactory.h\"\n\n#include \"component1.h\"\n#include \"component2.h\"\n\nnamespace xpcf=org::bcom::xpcf;\n\nXPCF_DECLARE_MODULE(\"kkkkkkkk-llll-mmmm-nnnn-oooooooo\", \"ModuleName\")\n\n\nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid&amp; componentUUID,SRef&lt;xpcf::IComponentIntrospect&gt;&amp; interfaceRef)\n{\n     xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n     errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::NAME::component1&gt;(componentUUID,interfaceRef);\n     if (errCode != xpcf::XPCFErrorCode::_SUCCESS)\n     {\n         errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::NAME::component2&gt;(componentUUID,interfaceRef);\n     }\n    return errCode;\n}\n\nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::MODULES::Name::component1)\nXPCF_ADD_COMPONENT(SolAR::MODULES::Name::component2)\nXPCF_END_COMPONENTS_DECLARATION\n\n\n\nIn the above mentioned code, a two-component module is considered.\n\n\nEach component is implemented via a class (.cpp/.h).\n\n\nComponents should be implemented for processing.\nIt should take in parameters and deliver out components and data.\n\n\n2.1. Data structures should be implemented for the data flow, meaning the data that will be exchanged between components at runtime thanks to the processing methods of the components. To optimize vision pipelines developped thanks to the SolAR Framework, it is of real need to take care to data structure optimization (reduce the memory copy, favour a quick access to data, etc.)\n\n\n2.2. A data structure must be defined in a namespace SolAR::datastructure\n\n\n2.3. The header and cpp files must be put under the datastructure directory.\n\n\n2.4. The header file shall contains Doxygen documentation code in order to automatically generate the data structure description web page during the continuous integration process used by the Solar Integration Team.\nFor instance for class documentation:\n\n\n\n/**\n  * @class Image\n  * @brief Specifies the Image base class.\n  *\n  * This class provides an image abstraction for SolAR\n  */\n\n\n\nand for method documentation:\n\n\n\n/** @brief  reserves new space depending on the image layers and bitspercomponent infos\n  *  @param width: width of the image\n  *  @param height: height of the image\n  */\n  void setSize(uint32_t width, uint32_t height);\n\n\n\n\n\n\n\n\n\nPlease refer to existing SolAR component interfaces and take them as examples.\n\n\n\n\n\n\nComponent Implementations\n\nA component implements a low-level vision processing in order to offer much more flexibility. They can be be interconnected together to create  high-level and real-time vision pipeline (localization, 3D reconstruction, etc.).\n\n\nThat is why a component should take in parameters and deliver out data structures to ease their connection (data flow).\n\n\nWhen you intent to  create a component, first verify that :\n\n\n\n\na SolAR interface already exists for your kind of components. If so, please use the specified interface.\nif no, or if you think the existing interfaces do not totally fit your need, please contact the SolAR team.\n\n\n\n\nPlease look at the organization of existing modules and components.\n\n\n3.1. Any component must be embedded in a module. Modules are used to easily publish one or a group of components to the solAR community. If you want to create a new module, please copy the existing structure of SolAR modules.\n\n\n3.2. Your components should have explicit names (that means, that ideally, we do not need to read documentation to understands what it is for and on which third party it is based). Please refer to existing components for naming examples.\n\n\n3.3. Your components must inherit from component interfaces defined by the SolARFramework. If no component interface fit your need or if you think an existing interface should be extended, please contact the SolAR team.\n\n\n3.4. Your components can define their own attributes which should be defined as private. No attributes can be shared by other components. If you want to shared data between components, pass them as attribute of the processing method.\n\n\n3.5. Your components can define their own methods which should be defined as private. The only public methods should be the ones defined by the abstract interfaces.\n\n\n3.6. Processing methods should not pass control or configuration parameters, but only the parameters representing the input and output dataflow of the component. If a parameter does not have vocation to change at each pass of the pipeline, this parameter must be moved as a private attribute of the component.\n\n\n3.7. All methods defined by the abstract interface you are inheriting must be implemented in your component.\n\n\n3.8. Your component should inherit from ConfigurableBase if you want to configure it thanks to an external file (please refer to other components, for instance ImageFilter). So you won&#8217;t have to recompile your pipeline if you want to change the configuration of its components.\n\n\nexample :\n\n\n\nSolARImageFilterBinaryOpencv::SolARImageFilterBinaryOpencv():ConfigurableBase(xpcf::toUUID&lt;SolARImageFilterBinaryOpencv&gt;())\n{\n    addInterface&lt;api::image::IImageFilter&gt;(this);\n}\n\n\n\n3.9. If you want to initialize the value of component attributes at runtime thanks to an external file, you need to wrap it to a naming string. Thus, you will be able to configure your pipeline by editing an external file defining this attribute by its given name.\nexample :\n\n\n\n    params-&gt;wrapInteger(&quot;min&quot;, min);\n\n\n\n3.10. There is no need to implement a setParameter and a getParameter method in a SolAR component. To configure a parameter at runtime in your code, get the wanted property of your component through the IConfigurable interface and set it to the desired value.\n\n\nexample :\n\n\n\nauto rIConfigurable_imageFilterBinary = imageFilterBinary-&gt;bindTo&lt;xpcf::IConfigurable&gt;();\nauto imageFilterBinary_property=rIConfigurable_imageFilterBinary-&gt;getProperty(&quot;min&quot;);\nimageFilterBinary_property-&gt;setIntegerValue(-1);\n\n\n\n3.11. All Dataflow parameters of a processing method that are not modified by the function must be const.\n\n\n3.12. All Dataflow parameters of a processing method that are SRef and that can be instantiated by the method must be a reference on a SRef, otherwise do not use a reference on a SRef. In the following example, the ouptut image of a ImageConvertor can be auotmatically instantiated according to the size of the input image:\n\n\n\nvirtual FrameworkReturnCode convert(SRef&lt;Image&gt; imgSrc, SRef&lt;Image&gt;&amp; imgDst) = 0;\n\n\n\n3.13. The namespace of your component must respect the following form: modules::module_name, where module_name refers to the name of your module.\n\n\n3.14. The namespaces of your component should use lower case.\n\n\n\n\n\n\n\n\nPlease refer to existing SolAR component implementations and take them as examples.\n\n\n\n\n\n\n\n\n\n\n\nPlease refer to existing SolAR components and take them as examples.\n\n\n\n\n\n3.15. Each parameter of each method of your component should be tested in your code, to detect bad parameter values. When an incorrect value is detected, the method should return an errorcode. This will help developers for implementing and debugging their pose estimation solution.\n\n\n3.16. Each component should have a corresponding \"simple\" unit test . The unit test should test component creation, configuration, and simple use of this component, with normal cases. The unit test should be commented, to help other contributors to understand your component.\n\n\n3.17. Each component should have unit tests with limit cases, as bad instanciation (bad values of attributes), bad use of components (for example: try to load an image that does not exist), and test every error code of each method.\n\n\n\nModules\n\n4.1. A Module is a group of components with the same implementation basis :\n\n\n\n\nsame third parties\n\n\nsame authors\n\n\nsame Intellectual Properties\n\n\n\n\n4.2. For each module, there should be a XML file describing the components with their UID. Please refer to SolarModuleTools example, and XPCF documentation to do it.\n\n\n4.3. In each module, there should be a Module unit test project, gathering the unit tests of all components.\n\n\n\nPipepline Management\n\nSolAR architecture is based on a pipeline manager called XPCF and implemented by b&lt;&gt;com.\nPlease refer to the XPCF github project link: https://github.com/b-com-software-basis/xpcf [XPCF GITHUB repository] to know more about XPCF.\n\n\n\n\n\n\n\n\nPlease be aware that components must be interoperable thanks to XPCF, and that is why thoses guidelines should be used.\n\n\n\n\n\n\n\n\nLogs to help debugging\n\n\nA SolARLog tool has been defined in order to help you to debug and test your programs.\n\n\nSolarLog is based on spdlog, and is managed as a singleton, so that you will have at maximum 2 loggers : 1 console and 1 file.\n\n\nYou have  2 log modes\n\n\n\n\nconsole\n\n\nfile\n\n\n\n\nPlease initiate your console logger with  LOG_ADD_LOG_TO_CONSOLE or file logger thanks to  LOG_ADD_LOG_TO_FILE.\n\n\nYou will easily find examples in SolAR sample codes.\n\n\nPlease use one of this macro to log your data, depending on the severity you want :\n\n\n\n\nLOG_TRACE: create a TRACE of INFO level\n\n\nLOG_INFO(fmt, &#8230;&#8203;) : create a log of INFO level\n\n\nLOG_DEBUG(fmt, &#8230;&#8203;) : create a log of DEBUG level\n\n\nLOG_CRITICAL(fmt, &#8230;&#8203;) : create a log of CRITICIAL level\n\n\nLOG_WARNING(fmt, &#8230;&#8203;) : create a log of WARNING level\n\n\nLOG_ERROR(fmt, &#8230;&#8203;)  : create a log of ERROR level\n\n\nLOG_FLUSH : can be used to force logs flush (console or file mode)\n\n\nLOG_RELEASE : is used to release the logger (should be used at the end of a program).\n\n\n\n\n\n\ncoding rules\n\n\nProject organization\n\nIn order to ease the source code management, we should follow the same hierarchy for each module. A module typically becomes one dynamic or static library (dll or lib). To make the code more accessible and friendly for everyone, developers should follow the rules below:\n\n\n\nFiles\n\n\n\n\n\n\n\nC++/C modules\n- Project-wide definitions must be in a dedicated header file (for instance definitions.h)\n- Each module may have a common .h file that contains all common constants, macros, enum, structures… It should not contain elements that are not common to classes in the module.\n\n\nC++/C source files\nC++/C source files should contain the implementation of only one class (except for very small private utility classes related to that class).\nSee Naming conventions for naming conventions.\n\n\nC++/C headers files\nC++/C headers files should contain the declaration of only one class (except for very small public utility classes related to that class).\nSee Naming conventions for naming conventions.\n\n\nDirectory layout for each module\nThe directory layout for each module should be as described in:\n coding_rules.adoc chapter Project organisation\n\n\n\n\n\nC / C++ Coding Rules\n\n\n\n\n\n\n\nNOT VALIDATED\nTIP: Write here if you validate with your name and your comment\n\n\n\n\n\nWhy restricting C++?\n\n\nEven if compilers now correctly compile even the most advanced C++ language features, some advanced features make the code overly complex and difficult to maintain.\n\n\nWhy restricting C?\n\n\nC can be written in many ways to do the same things but some ways are more obfuscated and offers less robustness.\n\n\nThen, what language to use?\nb&lt;&gt;com is using a mix of C and C++ based on existing code, external dependencies (like platform types, SDK, etc).\n\n\nThat’s why the following rules makes sense in our environment and, in order to facilitate porting and code review, developers must use the set of rules defined below. An example of code and header can be found in annexes A1 and A2.\n\n\n\nLanguage features\n\nAs it is very easy to make unreadable and non-understandable C code, here are a few rules/restrictions to follow for the C language itself:\n\n\n\n\n\n\n\n\nTemplates\nTemplates should be used following the \"KISS\" principle. Extreme template programming must be avoided and replaced with ad-hoc design to ensure code maintainability.\n\n\nExceptions\nExceptions must not be used outside package boundary (i.e. outside a static or dynamic library no exception must be thrown).\n\n\nOperator overload\nOperator overloading should be used appropriately.\n\n\nWeird language features of C++\nWeird language features of C++ must not be used, especially:\n- static variables that invoke constructors at initialization time  (except for some very special cases, such as the singleton pattern)\n- run-time type information (‘casts’ can fail at run-time)\n\n\nBit fields\nBit fields must not be used for the following reasons: they are not portable because the implementation of bit fields is left to the compiler manufacturer according to the platform; and usage of bit fields is usually inefficient in terms of code size. Use one variable instead of each bit field.\nConsider using the STL bitset template class instead.\n\n\nNamespaces\nNamespaces may be used for std classes to avoid the full Class::methName statement. But for internal classes with ambiguous names, try to always use their full class name.\n\n\n'goto' keyword\nThe 'goto' keyword should not be used, and if it is, it can only be used to jump to the end of a method for error recovery.\nBy considering the architecture of a method, this keyword can nearly always be avoided.\nSee annex A3 for examples.\n\n\n‘continue’ and ‘break’ keywords\nThe ‘continue’ statement should not be used; the ‘break’ statement should not be used except inside switch statements.\n\n\n‘return’\nThe 'return' keyword may be used anywhere in the code.\nHowever, it requires that the no dynamic allocation rule is respected (see below) and that no vital code is skipped.\nIt also requires that all synchronization is made through C++11 lock_guard objects.\n\n\nC++ types\nTypes such as bool, etc. may be used if they are not platform dependant.\n\n\nC++ iostreams\nIostreams should be used.\n\n\nDynamic memory allocations\nDynamic memory allocation should be avoided.\nMost of the time, C++ offers semantics that allows no dynamic allocation design.\nmalloc/free, new/delete should be used during initialization sequence (in the class constructors for instance)\nDuring run time, explicit memory allocations should not be used to avoid memory fragmentation and leaks.\nIf an array is needed at some point during the execution of the program, this need should preferably be planned and reserved at the initialization sequence.\nLocal arrays are recommended if they are small in size (no more than 16-32 values).\n\n\nArrays\nuse STL&#8217;s vector&lt;T&gt; and array&lt;T&gt; instead of old C-style arrays, as C-style arrays don&#8217;t behave as expected with C++ objects.\n\n\nDynamically allocation of member (aggregated/composed) object\ndynamic allocation of a \"local\" object must occur only when the inner object lifetime is different from the \"hosting\" class (aggregation case) OR when the used framework doesn&#8217;t allow the creation of the object upon class creation (for instance, when no default constructor is available).\nWhen dynamically allocating inner objects, prefer the use of STL&#8217;s shared_ptr or unique_ptr (depending on the inner object lifetime), to ensure proper behavior upon exception throwing &#8230;&#8203;\n\n\nClass instantiations during run time\nAll the necessary classes, arrays, structures should be present, allocated and initialized before run time (during the initialization sequence) except for transient objects (objects operated by a pipeline should be created at the beginning and destroyed at the end for instance)\n\n\nConstants\nConstants must be declared using static const or enum for enumeration of constants. #define must be avoided (language evolution tends to avoid #statements).\n\n\nconst\nconst keyword MUST be used. It must be used appropriately.\nUsed on method parameters, it clearly shows when a parameter is an input, input/output or output parameter.\nUsed for methods, it clearly shows that const methods leave the underlying object members unmodified. (typically getters should be const methods).\n\n\n\n\nC++11\n\n\n\n\n\n\n\n\nMove semantics\nMove semantics must not be used. In most cases, move semantics can be replaced with designing the method using C++ references upon output parameters, or with the use of STL shared_ptr.\n\n\nLambdas expressions\n\n\n\nThreads\nC++11 threads and related facilities (mutex, scoped lock_guard, future &#8230;&#8203;) must be used\n\n\nLiterals\n\n\n\nRange for\nRange for must be used to work on containers as it improves the code readibility\n\n\nauto\nauto keyword use is recommended when it simplifies the code readibility.\nIt allows to avoid explicit typing of objects when there&#8217;s not a strong interest to :\n- for iterators\n- for temporary objects\n\n\nsmart pointers\nSTL&#8217;s smart pointers must be used. When possible, it should replace most of old C-style pointers (DLL boundary issue ?)\n\n\nFunction objects\nstd::function, std::bind, std::mem_fn &#8230;&#8203; readibility, maintainability issues ?\n\n\nSTL containers initializer list\n\n\n\nDate and time\nSTL chrono, useful also for performance counters\n\n\nSTL\narray&lt;T&gt;, bitset&lt;T&gt;\n\n\n\n\n\nLibraries and headers\n\n\n\n\n\n\n\nSTL containers\nSTL should be used for container types, such as vectors, lists, maps, etc. (but must not be used across DLL boundaries).\n\n\nC++ strings\nThe C++ string object should be used for string manipulation (but must not be used across DLL boundaries).\n\n\nC++ 'cin', 'cout', 'cerr'\nThe C++ 'cin', 'cout', 'cerr' must not be used (except inside unit test code and command line tools).\n\n\nC 'stdin', 'stdout', 'stderr'\nThe C 'stdin', 'stdout', 'stderr' must not be used (except inside unit test code and command line tools).\n\n\nC headers/libraries\nC headers/libraries may be used.\n\n\nSystem specific headers/libraries\nSystem specific headers/libraries must not be used\n(except in system specific source code – in that case it should be clearly isolated and identified). The code should use as little as possible the windows SDKs (tradeoff between using existing code and code created from scratch).\n\n\nMultiple header include\nTo avoid multiple definitions, each header must have:\n#ifndef HEADERNAME_H\n#define HEADERNAME_H\n&lt;header&gt;\n#endif // HEADERNAME_H\n\n\nInclude inside header files\n#include should not be inside header files in order to avoid include files obfuscation, and to prevent some cases of bad build of a project which shares dependencies with a non-rebuilt project.\n\n\nFunction and variable declaration\nFunction and variable declarations must be done in header files (and not in other files).\n\n\n#pragma once\nUse of #pragma once is prohibited :\n- even if it is supported by a vast majority of c++ compilers, it is not a standard directive of the language\n- although it protects from header naming conflict, it doesn&#8217;t prevent from ncluding a header twice if it exists in more than one location in a project as files are excluded based on their filesystem-level identity.\n\n\n\n\n\nNaming conventions\n\n\n\n\n\n\n\nNOT VALIDATED\nTIP: Write here if you validate with your name and your comment\n\n\n\n\n\n\n\n\n\n\n\nAbout names\n- Words must be in English.\n- Words inside the name must start with an uppercase letter. Other letters of the word must be lowercase letters (except for constants).\n- Names should not contain underscores '_' (except for constants and the prefixes as specified bellow).\n- Names should not contain abbreviations (except if the abbreviation is widely used in the particular field, such as ESDescriptor for “elementary stream descriptor”).\n- Names should be explicit according to what they will do, avoid generic names (like i, a, x…).\n\n\nC++ source files\nC++ source files must begin with the name of the class followed by ‘.cpp’.\n\n\nC source files\nC source files must begin with the name of the class followed by ‘.c’.\n\n\nC++/C headers files\nC++/C header files must begin with the name of the class followed by ‘.h’.\n\n\nC++ template headers files\nC++ template header files must begin with the name of the class followed by ‘.[inl|tpl]’.\n\n\nC++ template source files\nC++ template source files must begin with the name of the class followed by ‘.[ipp|tcc]’.\n\n\nClasses,\nstructures,\nglobal functions, structure tags, typedefs,\nenumerated values\nClass names, structure names, global functions, structure tags, typedefs, enumerated values must have their name beginning with an uppercase.\nExample MatrixBase\n\n\nMethods\nMethod names must begin with a lowercase letter (except for constructors and destructors).\nExample\treadAccessUnit()\n\n\nPrivate members\nPrivate member variable names must be prefixed with 'm_' and start with a lowercase letter.\nExample\tm_accessUnitList\n\n\nPrivate static members\nIf used, private static member variable names must be prefixed with 's_' and start with a lowercase.\nExample\ts_socketCounter\n\n\nLocal variables\nLocal variable names must start with a lowercase letter.\nExample\tdataLength\n\n\nConstants\nConstants must be all uppercase with each word separated by “_”.\nExample\tMAX_LENGTH\n\n\n\n\n\nDesign conventions\n\n\n\n\n\n\n\nMultiple inheritance\nPolymorphism\nMultiple inheritances should not be used, except if the additional classes are pure virtual (equivalent to Java interfaces).\n\n\nClasses with public virtual methods\nClasses with public virtual methods must have a virtual destructor (or else the destructor will not be called). When possible, use the appropriate compiler warning to be warn when destructor isn&#8217;t declared virtual while some public methods are.\n\n\nStatic member variables\nStatic member variables must not be used (these are basically “global variables”). (except for singleton design pattern)\n\n\nPublic member variables\nPublic member variables must not be used (except in pure “struct-like” classes). Instead, getter and/or setter methods should be provided to access member variables.\nExample\tint getMember()\n{\n&#8230;&#8203;.return m_member;\n}\nError setMember(int variable)\n{\n&#8230;&#8203;.if (variable&#8230;&#8203;)\n&#8230;&#8203;.{\n&#8230;&#8203;&#8230;&#8203;..m_variable = variable;\n&#8230;&#8203;&#8230;&#8203;..return NoErr;\n&#8230;&#8203;.}\n&#8230;&#8203;.return Error_NUMBER;\n}\n\n\nUnsigned/signed types\nSigned and unsigned computations should not be mixed. Signed and unsigned doesn’t work well together and are, in many cases, not comparable one another.\nSituations like “comparing unsigned values with potentially negative values” or “use signed computations to be casted into unsigned variables” makes the code vulnerable.\n\n\nSigned types\nUnsigned types  should be used.\nSigned types should only be used when the value for the variable or parameter in question could sensibly be negative.\n\n\n'enum' type\nFor variables or parameters that may take one of a set of values whose representation is arbitrary, the enum type should be used.\nExample\tenum CM_Colors { CM_RED, CM_GREEN, CM_BLUE };\n\n\nDynamic length structure\nIt is recommended to avoid structures with dynamic length. However, if they are used, the size should be bounded in size in order to avoid unlimited memory occupation.\n\n\nPreprocessor definitions\nThe definition and use of preprocessing flags (#ifdef/#ifndef) in the source code should be limited; in particular, there should not be any OS or compiler specific code.\nHowever, if specific code is present, it should be isolated and clearly identified.\nMost of the time, a different design approach allows to avoid inlined OS preprocessor definitions (namespace or inheritance usage for instance).\n\n\nCode under conditional compilation flags\nCode under #if, #ifdef, #ifndef should be limited. Theses sections, if not build with the rest of the code, can easily be broken without notice.\n\n\nInline\nInline may be used instead of macro for functions that are called often and when they are more than one line long.\n\n\nRange of variables\nConsider the range of each variable: each variable should remain local to a code block as much as possible.\nVariable like the for iterator can remain local to the loop. If the if condition statement block needs a local variable: declare it inside the statement block. This variable will not be visible outside the block, preventing misuse.\nNote for Intel compilers: before ICC11, declaring a variable into a for statement for (int myVariable;…) resulted in having the variable defined locally to the function containing the for. With ICC11, this variable exists only with the for statement code block.\nExample\tif (myCondFct())\n{\n&#8230;&#8203;.\tint myLocalVar = methodVar * m_aMember;\n&#8230;&#8203;.useMyLocalVar(myLocalVar);\n}\naMethodThatCanNotUseMyLocalVarHere();\nmyLocalVar is only used in the if statement block. If someone attempts to use it outside, the project will not build. This variable only serves that code block and it is not useful outside. The code is easier to read, no need to monitor myLocalVar, or wonder if it is used elsewhere…\n\n\nScope of variables\nAvoid using one variable for multiple purposes (the compiler handles this optimization process better than anybody).\n\n\nCode organization\nIt is recommended to differentiate:\n- Functions dedicated to computing.\n- Functions dedicated to schedule and control the computing functions.\n- Functions dedicated to data flow management.\nExample\tError computeFunc(UInt32* res, UInt32* sourceTable)\n{\n&#8230;&#8203;.// compute code\n&#8230;&#8203;.res = sourceTable[0] * sourceTable[1] + MY_CONST;\n&#8230;&#8203;.return NoErr;\n}\nError dataFlowFunc(MyStruct destStruct, MyStruct* sourceStruct)\n{\n&#8230;&#8203;.// copy struct\n&#8230;&#8203;.memcpy(destStruct, sourceStruct, sizeof(destStruct));\n&#8230;&#8203;.return NoErr;\n}\nError controlFunc(MyStruct* destStruct, MyStruct* sourceStruct, UInt32* sourceTable)\n{\n&#8230;&#8203;.Error err;\n&#8230;&#8203;.UInt32 res;\n&#8230;&#8203;.err = computeFunc(&amp;res, sourceTable);\n&#8230;&#8203;.if (err == NoErr)\n&#8230;&#8203;.{\n&#8230;&#8203;&#8230;&#8203;..err = dataFlowFunc(destStruct, sourceStruct);\n&#8230;&#8203;.}\n&#8230;&#8203;.return err;\n}\n\n\nThread concurrency\nUse threads with caution. It is recommended to ask architecture experts about the use of threads. Use C++11 threads' library.\n\n\nSingleton design pattern\nThis pattern should not be used unless absolutely needed. When used, special care should be taken to consider concurrent access issues; the unique instance should be automatically created in the first call of “getInstance”; and the constructor should be declared as private.\nSometimes, a statically created singleton is the prefered choice (more than the dynamically created one).\n\n\nCasts\nCasts should not be used unless absolutely needed. C-style casts must be prohibited and replaced with C++ casts.\nExample\tUInt16 var1;\nUInt32 var2;\nUInt64 myResult;\nmyResult = var1 * var2;\nmyResult = (UInt64) var1 * var2;\nmyResult = UInt64(var1) * UInt64(var2);\n\n\n\n\n\n\n\n\n\n\nDon&#8217;t put two methods calls on the same line. Don&#8217;t put break keyword in switch/case statement at the end of a processing line.\n\n\n\n\n\n\nLayout conventions\n\n\n\n\n\n\n\nTabs\nTabs must not be used. Spaces must be used for indentation. Editors should be set to fill with spaces, not tabs. Tab settings tend to be different for editors, printers and web pages.\nNote: This is obviously an arbitrary choice, but mixing tabs and spaces causes much difficulty in reviewing code…\n\n\nIndentation\nIndentation offset must be set to 4 spaces and is performed according to the following rules:\n- code surrounded by braces must be indented by one level.\n\n\nBlank lines\nA blank line should be used to separate logically distinct sections of code.\n\n\nCurly brackets\nCompound statements (if, else, else if, while, for, switch, do) must ALWAYS make use of curly brackets, even where the \"associated\" body only consists of a single line. Structures must use curly brackets around the clause.\n\n\nCurly brackets\nCurly brackets should appear at the beginning of the next line or at the end of the line.\nExample\tif (a == b) {\n&#8230;&#8203;.c = 0;\n}\nelse {\n}\nif (a == b)\n{\n&#8230;&#8203;.c = 0;\n}\nelse\n{\n}\n\n\nParentheses\nAlthough C++ has precedence rules that should ensure a given expression is evaluated in the same order regardless of the compiler, additional parentheses should be used where the order of evaluation is not obvious.\n\n\nMultiple parentheses\nParentheses on multiple lines must be aligned on the previous parentheses with the same level. Operators must be at the end of the lines.\nExample\tif (a == b) &amp;&amp; &#8230;&#8203;..(c == d ||\n&#8230;&#8203;.(e == f))\nif (a == b) &amp;&amp; (c == d ||\n&#8230;&#8203;.(e == f))\n\n\nFunctions\nEach function should perform a single well-defined operation.\nFunctions should not be too long. Up to 2 pages of printout or about 100 lines of source code is reasonable. These figures include comments and blank lines.\n\n\nSource files\nSources files must be small. 1000 lines of source code is reasonable (including comments and blank lines).\nThese files are easier to read and faster to compile (Intel compiler can compile several source files in parallel).\n\n\nHeader files\nHeader files must be small. 100 lines for headers are reasonable.\n\n\nSwitch\nCase/default from a switch statement are written on the same column as the switch keyword. break; and other lines are indented.\n The break keyword must ALWAYS be on its own line. Mixing the break keyword with processing code makes the code confused : it can be interpreted as \"fall-off\" code when break is at the end of long lines.\nExample\tswitch (getStyle(config))\n{\ncase STYLE_GOOD:\n&#8230;&#8203;.// Ah, it&#8217;s so good!\n&#8230;&#8203;.break;\ncase STYLE_BAD:\n&#8230;&#8203;.// Oh no, it&#8217;s bad!\n&#8230;&#8203;.break;\ndefault:\n&#8230;&#8203;.// Hmmm!\n&#8230;&#8203;.break;\n}\n\n\nInstructions\nPut one instruction per line.\n\n\nfor\nAlways put curly brackets in for clause. for instructions must be on their own lines (not on the for line)\n\n\n\n\n\nTracing and debugging\n\n\n\n\n\n\n\nBoost::log\nBoost::log is the recommended framework to log, as it provides great functionality out of the box without the need for extra/complex configuration\n\n\n\n\n\nError handling\n\n\n\n\n\n\n\nDefault error codes and types\nThe default error codes and error types should be declared in a common b&lt;&gt;com header file.\n\n\nType of value returned for error codes\nThe type of value returned for error codes should be Error.\nExample\tError parseString(char *str);\n\n\nMemory allocation\nA method that attempts to allocate memory must provide an allocation failure mechanism, typically by returning an error code. Note that other methods that call such a method must also provide a failure mechanism, and so on&#8230;&#8203; Memory allocation should not be performed in constructors as constructors don’t return error code.\n\n\nFile management\nThe success of a file opening must be checked and if not successful, the error must be handled appropriately.\nFiles must be closed when no longer used or when an error to exit occurs.\nWhen closing the file, the return value must be checked.\n\n\nFunction call\nThe success of a function call must be checked and if not successful, the error must be handled appropriately. The error codes returned by functions must be tested and treated.\n\n\nInit/deinit functions\nAfter calling constructors and before destructors, it is sometimes necessary to call init and deinit functions to permit error handling on structures that might fail (as these errors cannot be handled in constructors and destructors.\n\n\n\n\n\nMiscellaneous conventions\n\n\n\n\n\n\n\nCompiler warnings\nSource code must not have any warnings when compiled on any targeted platform with any targeted compiler (with a reasonably high warning level – at least level 3).\n\n\nC – C++ interfacing\nAll C public interfaces (*.h) which may be compiled with a C++ compiler must wrap the contents of the file with the pair of macros BEGIN_EXTERN_C and END_EXTERN_C.\nExample\tBEGIN_EXTERN_C\nEND_EXTERN_C\n\n\nC++ interfacing\nAll C class headers (*.h) which may be compiled with a C compiler must include a C API and ensure the non visibility of C code by putting it within an “#ifdef __cplusplus … #endif” statement.\n\n\nDynamic library export\nThe definition of each class or function that is exported in a dynamic library must be preceded by the XX_EXTERN keyword, XX being the prefix for the module to which the class belongs.\n\n\nPortability\nSee http://www.mozilla.org/hacking/portable-cpp.html for more miscellaneous recommendations on portability on various platforms. If a rule differs from b&lt;&gt;com coding rules, follow the b&lt;&gt;com coding rule.\n\n\n\n\n\nDocumentation\n\n\n\n\n\n\n\nCopyright\nEach b&lt;&gt;com source and header file must use the template copyright header comment.\n(See Annex A1: .h)\nSource from other origins (Open Source for example) may have their own license. In this case, the license must be respected. The headers of third party files must be left intact (then it should not be replaced by b&lt;&gt;com copyright).\n\n\nPrimary documentation\nof a class\nThe primary documentation of a class must appear in the header file.\n\n\nClass description\nEach class must have a description before the class declaration.\n(see Annex A1: class description)\n\n\nMethods\nEach method (public, protected and private) must have a short description before the method declaration.\n(see Annex A1: setup method description)\nA method that is already sufficiently documented in the superclass may omit the description or have a single-line comment '// see superclass'\n(see Annex A1: clone method description)\n\n\nMember variable\nEach member variable must have a description either before the member variable declaration or on the same line.\n(see Annex A1: member description)\n\n\nComments\nComments are written in English. Do not use accented characters in source files.\nAll comments should be “DOxygen” compatible (see Tools). All tags must start with ‘@’ and not ‘\\’.\nEach block of code should be commented. Algorithms must be commented.\nBugs from Bugzilla must not be referenced in the code.\n\n\n/*…/\nThis type of comment block must be used for comments that apply either to a class, a function, a structure, an enum, a member… which is present below the comment block.\n(see Annex A1: class description)\n\n\n//\nThis comment line should be used inside the code to comment lines in C++ sources. They should be used even for block of comments.\n(see Annex A2)\n\n\n/…/\nThis comment block should not be used for C++ except for the template copyright block on top of the file and for method and variable documentation.\n\n\n\n\n\nC/C++ Performance rules\n\nBecause we need performance for all code types to achieve close-to-realtime target, these rules replace corresponding rules in previous chapters in order to ensure better software performance.\nFor C++, to improve performance, classes must act as evolved structures/handlers. They must point at a set of non reentrant methods (avoiding static code, allowing parallelism, allowing instantiation).\n\n\n\n\n\n\n\n\n'goto' keyword\nThe 'goto' keyword must not be used.\n\n\n‘continue’ and ‘break’ keywords\nThe ‘continue’ statement must not be used; the ‘break’ statement must not be used outside of switch statements.\n\n\nC++ &#8594; C convertibility\nC++ source must always be convertible into C code. If the rules associated with classes are followed, a class can be immediately converted into a structure and a bunch of methods with, as parameter, a handle on the structure that represents the former members.\n\n\nRecursive code\nRecursive code must not be used for performance reasons and lack of control over the code and because no parallelization and optimization are possible.\n\n\n?No class as class member?\nA class must not contain another class as a member except through pointers.\n\n\nStructures must not contain arrays\nA structure (class or struct) must not contain arrays except through pointers.\nThe size of the structures must remain reasonable.\n\n\nDynamic memory allocation\nDynamic memory allocation must not be used.\nmalloc/free, new/delete must be used during initialization sequence (into the class creators for instance)\nDuring run time, explicit memory allocation must not be used to avoid memory fragmentation and leaks.\nIf an array is needed at some point during the execution of the program, this need must be planned and reserved at the initialization sequence.\nLocal arrays are tolerated if they are small in size (no more than 16-32 values).\n\n\nClass instantiations during run time\nAll the necessary classes, arrays, structures must be present, allocated and initialized before run time (during the initialization sequence).\n\n\nDynamic length structure\nDynamic length structures must not be used (in order to avoid unlimited memory occupation).\n\n\n\n\n\nTools\n\n\n\n\n\n\n\nUncrustify\nMost of the code formatting rules described in this document can be enforced using “uncrustify”.\n\n\nDOxygen\nDOxygen extract comments from the source code and generates documentation. It is recommended to check the comment structure with this tool.\nRefer to the online manual (http://www.stack.nl/~dimitri/doxygen/index.html) for a complete description of DOxygen rules.\n\n\n\n\n\n\n\nAppendix A.\tRules management\n\n\nI.\tResponsibility\n\nThe Development group manager is responsible of these rules.\n\n\n\nII.\tDeviation\n\nAny b&lt;&gt;com source code must follow these rules. Third party package follow their own rules and should not be modified to follow these rules.\n\n\n\nIII.\tTraining\n\nAny C/C++ developers and integrators must be trained to these rules.\n\n\n\nIV.\tControl\n\nThe compliancy with these coding rules can be performed with Uncrustify tool with the appropriate config file (see tools).\n\n\n\n",
    id: 4
  });
  

index.add({
    title: null,
    content: "\nTable of Contents\n\nBuild\nBuild systems for windows &amp; linux\nWindows\n\nQT Creator\nVisual Studio QT VS Tool\n\n\nLinux\n\n\n\nBuild\n\n\n\n\n\nBuild systems for windows &amp; linux\n\n\nSolAR Framework is composed of modules and samples. Each of them has a .pro file used for the build.\n\n\n\n\nWindows\n\n\nRemaken has to be installed. (https://github.com/SolarFramework/Tools/releases)\n\n\nQT Creator\n\n\n\nOpen QTCreator and click on Open Project (in Menu).\n\n\nOpen a SolAR module or sample double clicking on it .pro file.\n\n\nConfigure the project if needed, we recommend to use MSVC 2017 64bit on Windows.\n\n\nExecute \"Run qmake\" command.\n\n\nExecute build / rebuild command.\n\n\n\n\n\nVisual Studio QT VS Tool\n\nInstall QT VS Tool 2.4.3. (https://marketplace.visualstudio.com/items?itemName=TheQtCompany.QtVisualStudioTools-19123)\n\n\n\n\nOpen Visual Studio.\n\n\nGo to QT VS Tools\n\n\n\n\n\n\n\n\n\n\n\nSimply click on \"Open QT Project file\" and visual studio do the rest.\n\n\nQT VS Tools realizes the Qmake command during this importation.\n\n\n\n\n\n\n\n\n\n\nTo execute a qmake command again, re-import the .pro file.\n\n\n\n\n\n\n\nThen, use visual studio and run pthe project like a classic one.\n\n\n\n\n\n\n\nLinux\n\n\nTested on ubuntu:18.04 for SolARFramework project.\n\n\n#update and core\n\n\n\n\napt-get update\n\n\napt-get install -y git wget pkg-config unzip\n\n\n\n\n#build tools\n\n\n\n\napt-get install -y qt5-default\n\n\napt-get install -y g++\n\n\n\n\n#Need python-pip and conan\n\n\n\n\napt install -y python3-pip\n\n\npip3 install conan\n\n\n\n\n#Need buildefs qmake SFT b&lt;&gt;com\n\n\n\n\ngit clone https://github.com/b-com-software-basis/builddefs-qmake.git\n\n\nmkdir -p /root/.remaken/rules/qmake\n\n\ncp -r builddefs-qmake/* /root/.remaken/rules/qmake\n\n\n\n\n#ENV VARIABLES\n\n\n\n\nexport REMAKEN_RULES_ROOT=\"/root/.remaken/rules/\"\n\n\n\n\n#Need Remaken &#8594; thirdParties installer b&lt;&gt;com\n\n\n\n\ncd /usr/local/bin\n\n\nwget https://github.com/SolarFramework/binaries/releases/download/remaken/1.0.0/linux/remaken\n\n\nchmod 777 remaken\n\n\n\n\n#Clone git repository, use remaken for thirdParties\n\n\n\n\ngit clone --branch develop https://github.com/SolarFramework/SolARFramework.git\n\n\ncd SolARFramework\n\n\ngit checkout develop\n\n\nremaken --cpp-std 17\n\n\nmkdir SolARFramework-build \\\n\n\ncd SolARFramework-build \\\n\n\nqmake ../SolARFramework/SolARFramework.pro \\\n\n\nmake\n\n\n\n\n",
    id: 5
  });
  

index.add({
    title: "create a component",
    content: "Create a component\n\nTable of Contents\n\nCreate a component\nWhat is a component ?\nCreate a component with the wizard\n\nDownload QTCreator wizards for XPCF\nCreate a SolAR component in QTCreator\nThe component header file\nThe component cpp file\nDeclare your component in your module\nAdd your component to your registry file\n\n\n\n\n\nCreate a component\n\n\n\n\n\nWhat is a component ?\n\n\nA SolAR component is element embedding processing (and soon storage) capabilities. Components are designed to be connected together in order to create a full pipeline. For this reason, a component defines ideally one (potentially several) processing function defining input (the data to process) and ouptut (the processed data). For interoperability issues, the component has to implement a SolAR component interface defined by the SolAR Framework API available  here.\n\n\nAs each component implementation can require dedicated configuration parameters, the SolAR framework provides an easy-to-use mechanism to initialize them at load-time with a external xml configuration file.\n\n\nFinally, when a SolAR component is implemented, it has to be embedded in a SolAR module for its publication to the SolAR pipeline assemblers.\n\n\n\n\nCreate a component with the wizard\n\n\nDownload QTCreator wizards for XPCF\n\nCreating a new component from scratch can be a little bit tricky. To help you, a QTCreator wizard is available and will make the task much easier.\nStart by installing this wizard by launching the install.bat on Windows (in your ${REMAKEN_PKG_ROOT}/packages/win-cl-14.1/xpcf/[version]/wizards/qtcreator) or install.sh on Linux (in your ${REMAKEN_PKG_ROOT}/packages/linux-gcc/xpcf/[version]/wizards/qtcreator).\n\n\nYou can also download the wizard on the following link:\nhttps://github.com/SolarFramework/Tools/releases/download/XPCFWizard_2_3_4/XPCF_qtcreator_wizards.zip\nThen unzip the downloaded file, and run the install.bat on Windows or the install.sh on Linux.\n\n\n\nCreate a SolAR component in QTCreator\n\nOpen QTCreator and create the project of your module for which you want to add a new component\n\n\nRight click on your Sources folder, and click on Add New&#8230;&#8203; in the contextual menu.\n\n\n\n\n\nFigure 1. Add a new component in QT\n\n\nSelect XPCF and XPCF Component class and click on Choose button.\n\n\n\n\n\nFigure 2. Create an SolAR Component in QT\n\n\nThen, set the name of your module, inspired by the name of the SolAR interface you will implement. Do not forget to specifiy the namespace of your module. In addition, you will have defined the SolAR interface that your component will inherit. Again, do not forget the namespace of the interface. If you need more information about the interfaces available in SolAR, check its API documentation. Finally, you can define if your component is configurable. If yes, you will be able to easily configure it in a dedicated file attached to your pipeline.\n\n\n\n\n\nFigure 3. Set component name and inherited interface in QT\n\n\nNormally, your component class will be added to the project of your module, just select a version control if needed and click on the Finish\nbutton.\n\n\nTwo files have been created, one header file and one cpp file.\n\n\nNow, let&#8217;s take a closer look at these files to implement your component.\n\n\n\nThe component header file\n\nMyDescriptorsExtractor.h\n\n#ifndef MYDESCRIPTORSEXTRACTOR_H\n#define MYDESCRIPTORSEXTRACTOR_H\n#include &lt;xpcf/component/ConfigurableBase.h&gt;\n\n(1)\n#include &quot;IDescriptorsExtractor.h&quot;\n#include &quot;SolARMyModuleAPI.h&quot;\n\nnamespace SolAR {\nnamespace MODULES {\nnamespace MyModule {\n\n(2)\nclass MyModule_API_DLLEXPORT MyDescriptorsExtractor : public org::bcom::xpcf::ConfigurableBase, public virtual SolAR::api::features::IDescriptorsExtractor\n{\npublic:\n    MyDescriptorsExtractor();\n    ~MyDescriptorsExtractor() override;\n    void unloadComponent () override;\n\n(3)\n    inline std::string getTypeString() override { return std::string(&quot;DescriptorsExtractorType::MYCOMPONENT&quot;) ;};\n\n    /// @brief Extracts a set of descriptors from a given image around a set of keypoints based on AKAZE algorithm\n    /// &quot;Fast explicit diffusion for acceleratedfeatures in nonlinear scale space&quot;\n    /// [in] image: source image.\n    /// [in] keypoints: set of keypoints.\n    /// [out] decsriptors: se of computed descriptors.\n    void extract (const SRef&lt;Image&gt; image,\n                  const std::vector&lt; Keypoint &gt; &amp;keypoints,\n                  SRef&lt;DescriptorBuffer&gt; &amp; descriptors) override;\n\n};\n\n\n} // namespace MyModule\n} // namespace MODULES\n} // namespace SolAR\n\n(4)\ntemplate &lt;&gt; struct org::bcom::xpcf::ComponentTraits&lt;SolAR::MODULES::MyModule::MyDescriptorsExtractor&gt;\n{\n\n    static constexpr const char * UUID = &quot;{4bc8c7d0-9e57-4816-8e92-e26103cc43f7}&quot;;\n    static constexpr const char * NAME = &quot;MyDescriptorsExtractor&quot;;\n    static constexpr const char * DESCRIPTION = &quot;MyDescriptorsExtractor implements SolAR::api::features::IDescriptorsExtractor interface&quot;;\n};\n\n#endif // MYDESCRIPTORSEXTRACTOR_H\n\n\n\n\n\n1\nAdd the include files for the SolAR abstract interface that your component inherits, as well as the header file defining the export declaration MACRO of your module.\n\n\n2\nAdd your export declaration MACRO defined in MyModuleAPI.h file to export your component in the dynamic library of your module (Here MyModule_API_DLLEXPORT).\n\n\n3\nHere, you will have to define the interface of your component inherited from your SolAR interface. For instance, the getStringType and the extract methods declared in the IDescriptorExtractor abstract interface.\n\n\n4\nThe traits are automatically defined with a automatically generated UUID, the name of the component and a description that you are free to change.\n\n\n\n\nAs in this sample you are implementing a descriptor extractor component inherited from the SolAR interface IDescriptorsExtractor, you will have to add the following interface to your component:\n\n\n\nstd::string getTypeString() override;\n\n/// @brief Extracts a set of descriptors from a given image around a set of keypoints based on my wonderfull algorithm\n/// [in] image: source image.\n/// [in] keypoints: set of keypoints.\n/// [out] decsriptors: se of computed descriptors.\nvoid extract (const SRef&lt;Image&gt; image, const std::vector&lt; Keypoint &gt; &amp;keypoints, SRef&lt;DescriptorBuffer&gt; &amp; descriptors) override;\n\n\n\n\n\n\n\n\n\nAs the SolAR interfaces are defined with abstract class with pure virtual methods, you will have to declare in your component all the pure virtual methods declared in the interface it inherits.\n\n\n\n\n\n\n\n\n\n\n\nOf course, you can add any method and variable required by your component, but in private, as the only access to a component should be done through the inherited SolAR interface!\n\n\n\n\n\n\nThe component cpp file\n\nMyDescriptorsExtractor.cpp\n\n#include &quot;MyDescriptorsExtractor.h&quot;\n\n\nnamespace xpcf = org::bcom::xpcf;\n\ntemplate&lt;&gt; SolAR::MODULES::MyModule::MyDescriptorsExtractor * xpcf::ComponentFactory::createInstance&lt;fullComponentType&gt;();\n\n\nnamespace SolAR {\nnamespace MODULES {\nnamespace MyModule {\n\nMyDescriptorsExtractor::MyDescriptorsExtractor():xpcf::ConfigurableBase(xpcf::toMap&lt;MyDescriptorsExtractor&gt;())\n{\n\n    declareInterface&lt;SolAR::api::features::IDescriptorsExtractor&gt;(this);\n    (1)\n    //  Inject declarations come here : declare any component that must be injected to your component through its interface\n    // declareInjectable&lt;IFilter&gt;(m_filter);\n    //\n    // Inject declaration can have a name :\n    // declareInjectable&lt;IFilter&gt;(m_blurFilter, &quot;blurFilter&quot;);\n    //\n    // Inject declaration can be optional i.e. not finding a binding component for the interface is not an error :\n    // declareInjectable&lt;IImageFilter&gt;(m_imageFilter, false);\n\n    // wrap any component member variable to expose as properties with declareProperty&lt;T&gt;() with T matching the variable type\n    // For example : declareProperty&lt;float&gt;(&quot;blurFactor&quot;,m_blurFactor);\n    // declareProperty(&quot;name&quot;,m_memberVariable) also works with template type deduction when m_memberVariable is a supported type of IProperty\n}\n\nMyDescriptorsExtractor::~MyDescriptorsExtractor()\n{\n\n}\n\n(2)\nvoid MyDescriptorsExtractor::unloadComponent ()\n{\n    // provide component cleanup strategy\n\n    // default strategy is to delete self, uncomment following line in this case :\n    // delete this;\n    return;\n}\n\n(3)\nxpcf::XPCFErrorCode MyDescriptorsExtractor::onConfigured()\n\n{\n    // Add custom onConfigured code\n    return xpcf::XPCFErrorCode::_SUCCESS;\n}\n\n(4)\nvoid MyDescriptorsExtractor::extract(const SRef&lt;Image&gt; image, const std::vector&lt;Keypoint&gt; &amp; keypoints, SRef&lt;DescriptorBuffer&gt; &amp; descriptors)\n{\n    // Add the code to extract your descriptor\n\n}\n\n} // namespace MyModule\n} // namespace MODULES\n} // namespace SolAR\n\n\n\n\n\n1\nIn the constructor of your component, you can simply inject another component to your current component. Thus, you will be able to define which component you want to inject in your configuration file. You can also define here the class variable members you want to configure from your configuration file. Both component injection and variable configuration funciton can be set in just a line of code.\n\n\n2\nSpecify here what your component has to do before it will be deleted.\n\n\n3\nSpecify here some processing to do when the class member variable values have been set according to the configuration file.\n\n\n4\nAdd the implementation of the method abstract declared by the inherited SolAR interface. Here, the extract method of the IDescriptorExtractor interface.\n\n\n\n\nNow, you can code the implementation of your methods defined in your header file.\n\n\n\nDeclare your component in your module\n\nThat is great, you have created your component, you have implemented its functions, but now you have to declare it in the module.\n\n\nTo do that, just open the main file of your module, and add the following lines of code:\n\n\nMyModule_main.cpp\n\n#include &lt;xpcf/module/ModuleFactory.h&gt;\n#include &lt;iostream&gt;\n\n#include &quot;MyDescriptorExtractor.h&quot; (1)\n\nnamespace xpcf=org::bcom::xpcf;\n\n/**\n *  @ingroup xpcfmodule\n */\n/**\n  * Declare module.\n  */\nXPCF_DECLARE_MODULE(&quot;{41a884a8-645b-47bc-9f41-66d057b2ec5d}&quot;,&quot;SolAR::MODULES::MyModule&quot;,&quot;MyModule module description&quot;);\n\n/**\n * This method is the module entry point.\n * XPCF uses this method to create components available in the module.\n *\n * Each component exposed must be declared inside a xpcf::tryCreateComponent&lt;ComponentType&gt;() call.\n */\nextern &quot;C&quot; XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const xpcf::uuids::uuid&amp; componentUUID,SRef&lt;xpcf::IComponentIntrospect&gt;&amp; interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n    errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::MyModule::MyDescriptorExtractor&gt;(componentUUID,interfaceRef); (2)\n //   if (errCode != xpcf::XPCFErrorCode::_SUCCESS) {\n //       errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::MyModule::OtherComponents&gt;(componentUUID,interfaceRef);\n //   }\n    return errCode;\n}\n\n/**\n  * The declarations below populate list of the components available in the module (it represents the module index).\n  * XPCF uses this index to introspect the components available in a module, providing the ability to generate the configuration file skeleton from the code.\n  */\nXPCF_BEGIN_COMPONENTS_DECLARATION\n(3)\nXPCF_ADD_COMPONENT(SolAR::MODULES::MyModule::MyDEscriptorsExtractor)\nXPCF_END_COMPONENTS_DECLARATION\n\n\n\n\n\n1\nAdd the header file of the component you want to add to your module\n\n\n2\nAdd the next 3 following lines of code to your module main file for each component you want to add to your module (update the second line with the name of your component).\n\n\n3\nAdd your component in the component declaration of your module.\n\n\n\n\n\nAdd your component to your registry file\n\nFinally, edit the xpcf_MyModule_registry.xml that should be at the root folder of your module project. Add a decsription for each component you want to embed in your module as follows:\n\n\nxpcf_MyModule_registry.xml\n\n&lt;xpcf-registry&gt;\n&lt;module uuid=&quot;5b066de7-2a9f-4dff-a730-ce82adafe2f6&quot; name=&quot;MyModule&quot; description=&quot;MyModule_Description&quot; path=&quot;$REMAKEN_PKG_ROOT/packages/SolARBuild/win-cl-14.1/MyModule/1.0.0/lib/x86_64/shared&quot;&gt;\n\n&lt;component uuid=&quot;4bc8c7d0-9e57-4816-8e92-e26103cc43f7&quot; name=&quot;MyDesrciptorsExtractor&quot; description=&quot;MyDesrciptorsExtractor Description&quot;&gt; (1)\n        &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot;/&gt; (2)\n        &lt;interface uuid=&quot;c0e49ff1-0696-4fe6-85a8-9b2c1e155d2e&quot; name=&quot;IDescriptorsExtractor&quot; description=&quot;SolAR::api::features::IDescriptorsExtractor&quot;/&gt; (3)\n&lt;/component&gt;\n\n&lt;/module&gt;\n&lt;/xpcf-registry&gt;\n\n\n\n\n\n1\nCopy and paste the component UUID, name and description defined in the traits defined in the component header file.\n\n\n2\nKeep always this declaration related to the inheritance to IComponentIntrospect.\n\n\n3\nAdd a description to all SolAR interfaces inherited by your component. To get access to UUID of SolAR interfaces, please take a look at the SolAR framework API documentation.\n\n\n\n\nThis is done, your component has been added to your module. You can now build your module, and use it in your pipelines.\n\n\n\n",
    id: 6
  });
  

index.add({
    title: "contribution workflow",
    content: "Contribution workflow\n\nTable of Contents\n\nContribution workflow\nContribute to SolAR Framework\nContributing by creating your own components\nContact\n\n\n\nContribution workflow\n\n\n\n\n\n\n\n\n\nContribute to SolAR Framework\n\n\nContributers may be interested in enhancing Solar Framework. For instance, they may want to:\n\n\n\n\ndefine new interfaces or new data structures\n\n\npropose bug fixes\n\n\netc.\n\n\n\n\nThe proposed workflow is based on github forks and pull requests:\n\n\n\n\nif not already done, create a github account: github\n\n\nopen the url of the repository related to the project you want to contribute to. The list of repositories and their urls is here: github SolAR repositories\n\n\nclick on the \"fork\" button in order to copy the repository to your own github account\n\n\nkeep your fork up to date: read the page help github in order\nto sync your local copy with the original repository\n\n\n\n\nYou may then ask the upstream repository to accept your changes: this is performed by creating a pull request.\nFollow the instructions at pull request documentation to see how to create a pull request\nbetween your fork and the original repository.\n\n\nWhen your pull request is created, request for a pull request review, by following these instructions: https://help.github.com/articles/requesting-a-pull-request-review/\n\n\n\n\nContributing by creating your own components\n\n\nYou may be interested by developing your own components based on SolAR interfaces.\nIn this case, create your own github repository, and create any SolAR components and packages you need by following these instructions.\n\n\nOnce your component is created, don&#8217;t hesitate to contact us!\n\n\n\n\nContact\n\n\nFor any request, please contact us.\n\n\n",
    id: 7
  });
  

index.add({
    title: "C++",
    content: "\nTable of Contents\n\nUse a pipleine in C++\nInstall SolAR before creating your app\nCreate an application project\n\nQT Creator\nVisual Studio\n\n\nSelect your dependencies\nConfigure your pipeline\nmain.cpp\n\n\n\nUse a pipleine in C++\n\n\n\n\n\nInstall SolAR before creating your app\n\n\nRefer to Install section.\n\n\n\n\n\n\n\n\nInstall https://github.com/SolarFramework/Tools/releases XPCF_Wizard.\n\n\n\n\n\n\n\nCreate an application project\n\n\nQT Creator\n\n\n\nOpen QTCreator and create a new project (in File menu).\n\n\n\n\n\n\n\n\n\n\n\nThen, set the name of your application (e.g. MySolARApp) that will use a SolAR pipeline, and its location.\n\n\nNext, define your build system with qmake. For the next step, choose your development kits. We recommend to use MSVC 2017 64bit on Windows or Clang on Linux.\n\n\n\n\nYour project is now created and the result is a .pro file like following:\n\n\nMySolARApp.pro\n\n## remove Qt dependencies\nQT -= core gui\nTARGET = MySolARApp (1)\nVERSION=x.x.x (2)\n\nCONFIG += c++1z\nCONFIG -= qt\nCONFIG += console\n\nDEFINES += MYVERSION=$${VERSION}\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += NDEBUG=1\n}\n\nwin32:CONFIG -= static\nwin32:CONFIG += shared\n\nDEPENDENCIESCONFIG = sharedlib install_recurse\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, recurse install or install_recurse (do same thing) are use to install dependencies of dependencies, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude ($$shell_quote($$shell_path($$(REMAKEN_RULES_ROOT)/qmake/templateappconfig.pri)))\n (3)\n\nDEFINES += BOOST_ALL_DYN_LINK\nDEFINES += BOOST_AUTO_LINK_NOMANGLE\nDEFINES += BOOST_LOG_DYN_LINK\n\nSOURCES += \\\n    main.cpp\n\nunix {\n    LIBS += -ldl\n    QMAKE_CXXFLAGS += -DBOOST_LOG_DYN_LINK\n}\n\nmacx {\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CXXFLAGS += -fasm-blocks -x objective-c++\n}\n\nwin32 {\n    QMAKE_LFLAGS += /MACHINE:X64\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275\n\n    # Windows Kit (msvc2013 64)\n    LIBS += -L$$(WINDOWSSDKDIR)lib/winv6.3/um/x64 -lshell32 -lgdi32 -lComdlg32\n    INCLUDEPATH += $$(WINDOWSSDKDIR)lib/winv6.3/um/x64\n\n}\n\nDISTFILES += \\\n    conf_mySolARApp.xml\n\n#NOTE : Must be placed at the end of the .pro\ninclude ($$shell_quote($$shell_path($$(REMAKEN_RULES_ROOT)/qmake/remaken_install_target.pri))))\n# Shell_quote &amp; shell_path required for visual on windows\n\n\n\nNow, just update the .pro file:\n\n\n\n\n1\nset the TARGET with the name of your application,\n\n\n2\nset the version number of your application,\n\n\n3\ncheck if the builddefs folder used to define the building pipeline is well referenced\n\n\n\n\nFinally, click on Projects in the left menu of QTcreator, click on Run, set your working directory to the root directory of your project, and check Add build library search path to LD_LIBRARY_PATH if not already done.\n\n\n\nVisual Studio\n\nYou can also simply create your application with Visual Studio by using the .pro file (see above for more details how to configure the .pro file).\n\n\nMicrosoft Visual Studio provides a Qt Visual Studio Tools. This enables developers to import QT project files (.pro) into Visual Studio.\n\n\nInstall QT Visual Studio Tools:\n\n\n\n\nIn Visual Studio, select Tools &gt; Extensions and Updates &gt; Online to install and update QT Visual Studio Tools.\n\n\n\n\nImport the .pro. file into Visual Studio:\n\n\n\n\nSelect Qt VS Tools &gt; Open Qt Project File (.pro) and choose your .pro file.\n\n\n\n\nRight now, your project is configured.\n\n\n\n\n\nSelect your dependencies\n\n\nCopy in your project folder the packagedependencies.txt file of the pipeline you want to use, and add a dependency to the pipeline:\n\n\npackagedependecies.txt\n\nSolARFramework|0.8.0|SolARFramework|SolARBuild@github|https://github.com/SolarFramework/SolarFramework/releases/download\n(1)\nOtherDependency|version x.x.x|OtherDependency|LocalFolder@WhereDistant|urlToIt\n\n\n\n\n\n1\nAdd the dependency to the pipeline you want to use, with its version number.\n\n\n\n\nMore documentation here :\nRemaken is a dependencies manager. https://github.com/b-com-software-basis/remaken\nIt manages your third parties and it creates a REMAKEN_RULES_ROOT env. variable.\n\n\n\n\nConfigure your pipeline\n\n\nCopy the configuration file provided with your pipeline in your project folder:\n\n\nMyPipelineConfiguration.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;\n&lt;xpcf-registry autoAlias =&quot;true&quot;&gt;\n\n&lt;module uuid=&quot;94b21be9-703b-4a00-86a9-0db1bf70ef89&quot; name=&quot;MyPipelineModule&quot; path=&quot;$REMAKEN_PKG_ROOT/packages/SolARBuild/win-cl-14.1/MyPipeline/x.x.x/lib/x86_64/shared&quot; description=&quot;MyPipelineModule&quot;&gt;\n  &lt;component uuid=&quot;855c83b7-f4ec-48ab-8e89-56018ea9e169&quot; name=&quot;MyPipeline&quot; description=&quot;MyPipeline&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot;/&gt;\n    &lt;interface uuid=&quot;b5a6225e-6a91-4050-b298-886f4c17d9d2&quot; name=&quot;IPipeline&quot; description=&quot;IPipeline&quot;/&gt;\n  &lt;/component&gt;\n&lt;/module&gt;\n&lt;module uuid=&quot;15e1990b-86b2-445c-8194-0cbe80ede970&quot; name=&quot;SolARModuleOpenCV&quot; path=&quot;$REMAKEN_PKG_ROOT/packages/SolARBuild/win-cl-14.1/SolARModuleOpenCV/0.8.0/lib/x86_64/shared&quot; description=&quot;OpenCV&quot;&gt;\n  &lt;component uuid=&quot;5B7396F4-A804-4F3C-A0EB-FB1D56042BB4&quot; name=&quot;SolARCameraOpencv&quot; description=&quot;SolARCameraOpencv&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot;/&gt;\n    &lt;interface uuid=&quot;5DDC7DF0-8377-437F-9C81-3643F7676A5B&quot; name=&quot;ICamera&quot; description=&quot;ICamera&quot;/&gt;\n  &lt;/component&gt;\n&lt;/module&gt;\n&lt;module uuid=&quot;28b89d39-41bd-451d-b19e-d25a3d7c5797&quot; name=&quot;SolARModuleTools&quot; path=&quot;$REMAKEN_PKG_ROOT/packages/SolARBuild/win-cl-14.1/SolARModuleTools/0.8.0/lib/x86_64/shared&quot; description=&quot;Module Tools&quot;&gt;\n  &lt;component uuid=&quot;85db2f25-4f1c-4e06-9011-e020284bfc4f&quot; name=&quot;SolARBasicSink&quot; description=&quot;A Sink component for a synchronized pose and image pair&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot; /&gt;\n    &lt;interface uuid=&quot;c0d9fee4-d7d7-4866-a6cd-3bacac23316a&quot; name=&quot;ISinkPoseImage&quot; description=&quot;An interface allowing to store a synchronized pose and image from the pipeline to make it available to a third party application&quot; /&gt;\n  &lt;/component&gt;\n  &lt;component uuid=&quot;1e43cda9-7850-4a8a-a32b-f3f31ea94902&quot; name=&quot;SolARBasicSource&quot; description=&quot;A source component for feeding the pipeline with external images&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot; /&gt;\n    &lt;interface uuid=&quot;06e2fc5d-39da-4486-b2a6-1d8bd788fa13&quot; name=&quot;ISourceImage&quot; description=&quot;An interface allowing to store an image from extern source to make it available to the pipeline&quot; /&gt;\n  &lt;/component&gt;\n&lt;/module&gt;\n\n&lt;properties&gt;\n  &lt;configuration component=&quot;SolARCameraOpencv&quot;&gt;\n    &lt;property name=&quot;calibrationFile&quot; type=&quot;string&quot; value=&quot;camera_calibration.yml&quot;/&gt;\n    &lt;property name=&quot;deviceID&quot; type=&quot;UnsignedInteger&quot; value=&quot;0&quot;/&gt;\n  &lt;/configuration&gt;\n&lt;/properties&gt;\n\n&lt;/xpcf-registry&gt;\n\n\n\n\n\nmain.cpp\n\n\nCopy the following code in your main.cpp file for testing your SolAR pipeline:\n\n\nmain.cpp\n\n/**\n * information concerning the copyright and license of your SolAR application\n */\n\n#include &lt;boost/log/core.hpp&gt;\n#include &quot;core/Log.h&quot;\n#include &quot;xpcf/xpcf.h&quot;\n\n\n// ADD COMPONENTS HEADERS HERE, e.g #include &quot;SolarComponent.h&quot;\n#include &quot;PipelineManager.h&quot;\n\nusing namespace SolAR;\nusing namespace SolAR::PIPELINE;\n\nnamespace xpcf  = org::bcom::xpcf;\n\n#include &quot;SolARModuleOpencv_traits.h&quot;\n#include &quot;SolARImageViewerOpencv.h&quot;\n#include &quot;SolAR3DOverlayBoxOpencv.h&quot;\n\nusing namespace SolAR;\nusing namespace SolAR::MODULES::OPENCV;\nusing namespace SolAR::api;\n\nint main(){\n\n#if NDEBUG\n    boost::log::core::get()-&gt;set_logging_enabled(false);\n#endif\n\n    LOG_ADD_LOG_TO_CONSOLE();\n    SRef&lt;xpcf::IComponentManager&gt; componentMgr = xpcf::getComponentManagerInstance();\n    componentMgr-&gt;load(&quot;MyPipelineConfiguration.xml&quot;);\n    auto pipeline = componentMgr-&gt;resolve&lt;pipeline::IPipeline&gt;();\n\n    (1)\n    if (pipeline-&gt;init(componentMgr) == FrameworkReturnCode::_SUCCESS)\n    {\n        auto imageViewerResult = componentMgr-&gt;resolve&lt;display::IImageViewer&gt;();\n        auto overlay3DComponent = componentMgr-&gt;resolve&lt;display::I3DOverlay&gt;();\n\n        // Set camera parameters\n        CameraParameters camParam = pipeline-&gt;getCameraParameters();\n        overlay3DComponent-&gt;setCameraParameters(camParam.intrinsic, camParam.distorsion);\n\n        unsigned char* r_imageData=new unsigned char[camParam.resolution.width * camParam.resolution.height * 3];\n        SRef&lt;Image&gt; camImage=xpcf::utils::make_shared&lt;Image&gt;(r_imageData,camParam.resolution.width,camParam.resolution.height,SolAR::Image::LAYOUT_BGR,SolAR::Image::INTERLEAVED,SolAR::Image::TYPE_8U);\n\n        Transform3Df s_pose;\n\n        if (pipeline-&gt;start(camImage-&gt;data()) == FrameworkReturnCode::_SUCCESS)\n        {\n            while (true)\n            {\n                Transform3Df pose;\n\n                sink::SinkReturnCode returnCode = pipeline-&gt;udpate(pose);\n                if(returnCode==sink::SinkReturnCode::_ERROR)\n                    break;\n\n                if ((returnCode == sink::SinkReturnCode::_NEW_POSE) || (returnCode == sink::SinkReturnCode::_NEW_POSE_AND_NEW_IMAGE))\n                {\n                    for(int i=0;i&lt;3;i++)\n                         for(int j=0;j&lt;3;j++)\n                             s_pose(i,j)=pose(i,j);\n                    for(int i=0;i&lt;3;i++)\n                             s_pose(i,3)=pose(i,3);\n                    for(int j=0;j&lt;3;j++)\n                        s_pose(3,j)=0;\n                    s_pose(3,3)=1;\n                    overlay3DComponent-&gt;draw(s_pose, camImage);\n                }\n\n                if (imageViewerResult-&gt;display(camImage) == SolAR::FrameworkReturnCode::_STOP){\n                    pipeline.stop();\n                    break;\n                }\n             }\n        }\n        delete[] r_imageData;\n    }\n}\n\n\n\n\n\n1\nwhen you will load your pipeline, fill in the path to its configuration file and its UUID (the UUID of the component representing the pipeline available in the configuration file).\n\n\n\n\n\n\n\n\n\n\nDon&#8217;t forget to re-run qmake before building your application for QT Creator and re-import .pro file for Visual Studio.\n\n\n\n\n\nBuild and run your application.\n\n\n",
    id: 8
  });
  

index.add({
    title: null,
    content: "\n\n  \n    SolAR\n    SolAR\n    https://solarframework.github.io//\n    \n    Fri, 08 Jan 2021 10:10:21 +0000\n    Fri, 08 Jan 2021 10:10:21 +0000\n    Jekyll v3.5.1\n    \n  \n\n",
    id: 9
  });
  

index.add({
    title: "get modules",
    content: "\nTable of Contents\n\nGet Modules\nGet Modules\n\nInstall\nLinks\n\n\n\n\n\nGet Modules\n\n\n\n\n\nGet Modules\n\n\nInstall\n\nAll modules binaries can be downloaded by installing dependencies (take a look to the install page).\n\n\nAll modules sources can be cloned from GitHub using the following links.\n\n\n\nLinks\n\nThe direct links to modules and samples binaries\n\n\n\n\n\n\n\n\n\n\nName\nGitHub url\n\n\nFramework\nSolARframework\nhttps://github.com/SolarFramework/SolARFramework/releases\n\n\nModules\nSolARModuleCeres\nhttps://github.com/SolarFramework/SolARModuleCeres/releases\n\n\nSolARModuleFBOW\nhttps://github.com/SolarFramework/SolARModuleFBOW/releases\n\n\nSolARModuleG2O\nhttps://github.com/SolarFramework/SolARModuleG2O/releases\n\n\nSolARModuleNonFreeOpenCV\nhttps://github.com/SolarFramework/SolARModuleNonFreeOpenCV/releases\n\n\nSolARModuleOpenCV\nhttps://github.com/SolarFramework/SolARModuleOpenCV/releases\n\n\nSolARModuleOpenGL\nhttps://github.com/SolarFramework/SolARModuleOpenGL/releases\n\n\nSolARModuleOpenGV\nhttps://github.com/SolarFramework/SolARModuleOpenGV/releases\n\n\nSolARModulePCL\nhttps://github.com/SolarFramework/SolARModulePCL/releases\n\n\nSolARModuleRealSense\nhttps://github.com/SolarFramework/SolARModuleRealSense/releases\n\n\nSolARModuleTools\nhttps://github.com/SolarFramework/SolARModuleTools/releases\n\n\nSamples\nNatural Image Marker\nhttps://github.com/SolarFramework/NaturalImageMarker/releases\n\n\nFiducial Marker\nhttps://github.com/SolarFramework/FiducialMarker/releases\n\n\n Sample-Slam\nhttps://github.com/SolarFramework/Sample-Slam/releases\n\n\nSample-Triangulation\nhttps://github.com/SolarFramework/Sample-Triangulation/releases\n\n\n\n\n\n",
    id: 10
  });
  

index.add({
    title: "Install",
    content: "\nTable of Contents\n\nInstall SolAR\nSupported platform\n\n\n\nInstall SolAR\n\n\n\n\n\nSupported platform\n\n\n\n\n\n\n\nWindows\n\n\n\n\n\nLinux\n\n\n\n\n\nAndroid\n\n\n\n\n",
    id: 11
  });
  

index.add({
    title: "Community",
    content: "\nTable of Contents\n\nCommunity\nCommunity\nContact\n\n\n\nCommunity\n\n\n\n\n\nCommunity\n\n\nThere are several ways to contribute to SolAR framework.\n\n\nYou can :\n\n\n\n\ncontribute to Core framework, by defining API, architecture, framework tools &#8230;&#8203; this typically needs software engineering and architecture skills.\n\n\ncontribute to Components, by creating a new SolAR component, that can be used in a pose estimation solution&#8230;&#8203; this typically needs computer vision skills (and software skills).\n\n\n\n\nPlease contribute!\nRefer to our contribution workflow section\n\n\n\n\nContact\n\n\nFor any request, please contact us.\n\n\n",
    id: 12
  });
  

index.add({
    title: "Create",
    content: "\nTable of Contents\n\nCreate\nWhy create SolAR components ?\nWhat is a SolAR component ?\nwhat is a SolAR module ?\n\n\n\nCreate\n\n\n\n\n\nWhy create SolAR components ?\n\n\nThe SolAR framework has been designed to easily assemble a set of SolAR vision components to build vision pipelines adressing AR services. To ensure the interoperability, a concrete vision component must implement one of the more than 50 interfaces currently defined in the SolAR framework. Thus, a SolAR pipeline assembler can easily choose and connect SolAR vision components together to assemble a vision pipeline, and he can easily swap on component by another one to improve or adapt the pipeline to a dedicated device or task. This modularity aims at creating an ecosystem where researchers and vision expert will be able to easily share, promote or make their research results accessible to a large community to help the adoption of augmented reality.\n\n\n\n\nWhat is a SolAR component ?\n\n\nEach component processes input data and streams the processing output to feed the input of other components. Thus, each processing can be performed in parallel by buffering data between components to optimize the global vision pipeline. Components exchange data with strong types defined by the data structures available in the framework to ensure strong interfaces and avoid the connection of components with incompatible data.\n\n\nAlso, each concrete implementation of a SolAR component can define its own parameters to provide configuration genericity. This configuration is very simple with SolAR and allow to configure the pipeline at load time thanks to a simple xml file, and even at runtime through the SolAR API.\n\n\n\n\nwhat is a SolAR module ?\n\n\nAs it is difficult to manage tens, hundreds or even thousands of components independently (i.e. one shared library per component), SolAR components must be grouped into SolAR modules (i.e. a unique shared library embedded a set of concrete implementation of SolAR components). Thus, it will be much more easy to manage the publication of modules which can be organized according to the creator&#8217;s choice (a module dedicated to a third party such as OpenCV, to a research institution, to a company, to a dedicated pipeline assembly, etc.).\n\n\n",
    id: 13
  });
  

index.add({
    title: "Use",
    content: "Use\n\nTable of Contents\n\nUse\nOverview\nHow to contribute\n\n\n\nUse\n\n\n\n\n\nOverview\n\n\nSolAR is a opensource framework designed to solve computer vision problems.\n\n\nThis part of the website is to help developers be successful with our framework and create AR applications.\n\n\n\n\n\nFor the moment :\n\n\n\nUnity3D engine support\n\n\nC++ native support\n\n\n\n\n\nComing soon :\n\n\n\nAndroid platform support.\n\n\n\n\n\n\n\n*In the future :\n\n\n+\n* iOS platform support\n\n\n\n\nHow to contribute\n\n\nPlease refer to our contribution workflow section\n\n\n",
    id: 14
  });
  

index.add({
    title: "Assemble",
    content: "\nTable of Contents\n\nAssemble\nWhat is a SolAR vision pipeline ?\nWhy use SolAR to assemble vision pipelines for AR ?\nHow it works ?\n\n\n\nAssemble\n\n\n\n\n\nWhat is a SolAR vision pipeline ?\n\n\nThe SolAR framework has been designed to simplify the design of vision pipelines adressing augmented reality applications. A SolAR vision pipeline is a chain of connected vision processing components generally executed in parallel. For instance, a SolAR vision pipeline may take as input images captured by one or more cameras as well as data from an inertial sensor. These data will be processed in series by a set of SolAR components to estimate the pose of an AR device.\n\n\n\n\nWhy use SolAR to assemble vision pipelines for AR ?\n\n\nThe SolAR framework has been designed from the beginning to clearly separate tasks and roles and offer modularity. Indeed, a vision pipeline assembler will be able to focus on the pipeline design without worrying about the implementation of components, the intergation of existing computer vision libraries or the integration of the pipeline in an AR service.\n\n\nA vision pipeline assembler can easily:\n\n\n\n\ndownload existing SolAR vision components created and published by the SolAR component creators,\n\n\nassemble the vision components to create a vision pipeline,\n\n\nupdate the vision pipeline architecture,\n\n\nswap components by other ones,\n\n\nconfigure components,\n\n\ntest the vision pipeline,\n\n\npublish it for AR pipeline users who will develop AR services.\n\n\n\n\n\n\nHow it works ?\n\n\nThe SolAR framework handles everything that will allow a modular assembling of a vision pipeline:\n\n\n\n\nSolAR Data Structures define the information that flows in a pipeline and are exchanged between components.\n\n\nSolAR Component Interfaces define for now more than 50 standardized abstract interfaces for the different categories of vision processing components required to implement vision pipelines (e.g. keypoint detector, descriptor extractor, features matching, PnP and optimization). This unified interface is required to ensure interoperability between components allowing to easily swap one with another to improve the final vision pipeline.\n\n\nSolAR Components are concrete implementations of vision processing components compliant with SolAR components interfaces. Several components can implement the same SolAR component interface. In general, these components are created by wrapping computer vision libraries that could be either open-source (OpenCV, PCL, ROS, etc.) or proprietary. Each component can define its own parameters that will be used to fine tune the vision pipeline.\n\n\nSolAR Modules are shared libraries embedding a set of SolAR components to ease their management and publication.\n\n\nComponent Manager based on XPCF, a lightweight cross platform component framework similar to the well known COM model. it manages the introspection of SolAR modules and components, it provides an \"in-code\" dependency injection factory to create concrete component instance and bind them to a abstract SolAR component interface, it handles the loading of modules and components at runtime, it provides interfaces for load of pipeline and used modules and components at run-time, etc. XPCF is a third party developped by b&lt;&gt;com under Apache licencse 2.0 (more information about XPCF is available on GitHub).\n\n\n\n\n",
    id: 15
  });
  

index.add({
    title: "Home",
    content: "\n  \n    \n      \n    \n  \n\n\n  \n    What is SolAR?\n    SolAR is an open-source framework under Apache v2 licence dedicated to Augmented Reality. \n    \n    SolAR is modular and evolutive. It allows, in various contexts of use, the construction of customized computer vision pipelines targeting Augmented Reality applications (e.g. camera pose estimation or 3D mapping).\n    \n    SolAR contains:\n      \n        \n           interfaces promoting interoperability\n           computer vision components constructed from third-party bricks\n           plugins for third-party applications\n        \n      \n    \n  \n  \n    What's new in SolAR framework?\n    v0.9.0 just released! (2021/01/07) \n      \n        \n           Map overlap detection and merging \n           Move to XPCF 2.5.0 to use remoting feature for creating communication layer of cloud services \n        \n      \n    v0.8.0 (2020/10/05) \n      \n        \n           Android is now supported \n           The SLAM pipeline integrates a global bundle adjustment and a loop closure \n           The map can be saved and reloaded for persistent AR experiences \n           Storage components are now available to share data between processing components (point clouds, keyframes, covisibility, etc.) \n           Component injection to create high-level component implementations (e.g. SLAM bootstraper, tracking, and mapping)  with the low-level components of your choice (e.g. keypoint detector, descriptor, matcher, or PnP)\n           Binded or injected components are now configurable with specific properties (XPCF 2.4.0) \n           Use of conan-center-index remote and of a new solar conan remote for installing third parties \n        \n      \n      \n    v0.7.0 (2020/02/07)\n      \n        \n           A SLAM pipeline is now available on SolAR Framework\n           New build pipeline, based on qmake\n        \n      \n  \n\n\n  \n    \n      SolAR framework Overview\n      \n        \n          Your browser does not support the video tag.\n        \n      \n    \n  \n\n\n  \n    Who need SolAR?  \n    According to your needs, SolAR framework offers several user profiles:\n  \n\n\n  \n    \n      \n        \n            \n            \n                \n          \n        \n      \n      \n        SolAR pipeline user\n      \n      \n          As an AR service designer, I can use a prebuild standalone or Unity integrated AR pipeline...\n      \n    \n  \n  \n    \n      \n        \n          \n              \n              \n          \n        \n      \n      \n        SolAR pipeline assembler\n      \n      \n          As an AR pipeline developer, I can assemble components to build my own customized AR pipeline...\n      \n    \n  \n  \n  \n    \n      \n        \n          \n          \n        \n      \n    \n    \n      SolAR component developer\n    \n    \n        As an SolAR component developer, I can create customized bricks responding to specific needs...\n    \n    \n  \n\n\n  \n    How to contribute to SolAR?\n    Join the community, find out how you can contribute to the framework according to your profile and skills and participate to the augmented reality adoption. \n    \n    \n      \n    \n      \n        \n          \n              \n                    \n          \n        \n      \n      \n        SolAR framework contributor\n      \n      \n          As an SolAR framework developer, I can contribute to SolAR expansion...\n      \n    \n  \n\n\n",
    id: 16
  });
  

index.add({
    title: null,
    content: "\nClone SolAR\n\nSolAR is made up of a multitude of projects (SolAR Framework, SolAR pipeline manager, modules, samples, etc.). To help you, we have created a parent repository with sub-modules regrouping all source codes of SolAR projects. You can clone it from the following url:\nhttps://github.com/SolarFramework/SolAR.git\n\n\n\n\n\n\n\n\nNo space in the path of the folder where you are cloning SolAR !\n\n\n\n\n\n\ngit clone https://github.com/SolarFramework/SolAR.git\n\n\n\nDo not forget to install and update recursively the submodules:\n\n\n\ncd SolAR\ngit submodule update --init --recursive\n\n\n\nIf you want to move all submodules on Master, launch the following command\n\n\n\ngit submodule foreach git pull origin master\n\n\n\nIf you do not want to download all the source codes of SolAR, you can have a look to the different repositories available on Github on the Community/Git page.\n\n",
    id: 17
  });
  

index.add({
    title: "How to install",
    content: "\nTable of Contents\n\nInstall\nHow to install\nNext Steps\n\n\n\nInstall\n\n\n\n\n\nHow to install\n\n\nPrior to start, be sure that SolAR and your working environment are correctly configured as explained in the following :\n\n\nUnresolved directive in installassemble_back.adoc - include::../create/_install.adoc[]\n\n\n\n\nNext Steps\n\n\nIn the context of SolAR, a pipeline is a set of connected actions that takes on one hand a camera frame.\nActions are performed via C++ methods with dedicated input/output parameters. Generally output parameters of one action serve as input parameters for subsequent actions, hence the term pipeline.\n\n\nThe SolAR framework provides a comprehensive list of usable methods that are located in the API directory.\n\n\nAlso SolAR provides a set of modules that implement the said methods.\n\n\nTo build a pipeline, it is necessary to identify what are the required actions and which modules/components are available to perform them.\n\n\nSection \"Get Modules\" explains this in detail.\n\n\nOnce it is done, due to the use of XPCF, the three main items to take care of are :\n\n\n\n\na configuration file\n\n\na dependencies description file\n\n\na build configuration file (.pro or cmake)\n\n\n\n\n",
    id: 18
  });
  

index.add({
    title: "install",
    content: "\nTable of Contents\n\nInstall\nInstall\n\nInstall SolAR version 0.6.0 - Windows 7/10\nInstall SolAR version 0.6.0 - Ubuntu 18.04\n\n\n\n\n\nInstall\n\n\n\n\n\nInstall\n\n\nInstall SolAR version 0.6.0 - Windows 7/10\n\nA SolAR Framework Windows installer is provided in order to quickly install:\n\n\n\n\nthe SolARFramework library (debug and release modes) and interfaces (C++ header files)\n\n\nSolAR modules libraries (debug and release modes) and interfaces (C++ header files)\n\n\nthe required third party libraries (debug and release modes) and third party interfaces (C++ header files)\n\n\nthe QT creator pre-requisites\n\n\nSolAR samples (C++ sample code)\n\n\n\n\nThe installer can be downloaded here:\n\n\nhttps://github.com/SolarFramework/binaries/releases/download/SolARFramework-installer%2Fwin/SolarFramework-installer-0.6.0.exe\n\n\nUsing the installer is straightforward:\n\n\n\n\ndownload then launch the installer\n\n\nread then accept the license agreement, then press \"Next\"\n\n\n\n\n\n\n\n\n\n\nPlease close QT Creator, if running, on your computer, before executing the installer.\n\n\n\n\n\n\n\n\n\n\n\n\nselect the destination installation folder (default is: C:\\SolARFramework).\n\n\n\n\n\n\n\n\n\n\n\nselect the components you want to install.\n\n\n\n\n\n\n\n\n\nRegarding this last step, you have the choice between:\n\n\n\n\nSolAR libraries: this will install SolAR Framework and SolAR modules libraries and interfaces only.\n\n\nQT creator dependencies: this will install a windows version of pkg-config program, used by SolAR build scripts to generate Makefiles under QT creator\n\n\nThird party libraries: this will install the following third party libraries and interfaces: fbow, freeglut, opencv, boost, eigen, spdlog and xpcf\n\n\nSources: this will install a sources folder containing SolAR Framework, Modules and Samples sources.\n\n\nSample code: this will create a Samples folder under your SolARFramework installation folder. This folder contains sample C++ projects that you can use\nto learn the basics of SolAR.\n\n\nBuild scripts: this will create a build-scripts folder containing bash scripts to manage git repositories and to compiles sources\n\n\nExecutable Samples: this will create a Samples folder containing 4 executable samples (fiducial marker, natural image marker, triangulation based on 2 images and a SLAM sample)\n\n\n\n\nPlease use the default values: it will install everything you need to use SolAR, especially if you want to first test a sample code.\n\n\n\nInstall SolAR version 0.6.0 - Ubuntu 18.04\n\n\n\ndownload both files SolARFramework-0.6.0.tar.xz and SolARFrameworkInstall-0.6.0.sh at the following address:\n\n\nopen a terminal and go to the directory where you have saved SolARFramework-0.6.0.tar.xz and SolARFrameworkInstall-0.6.0.sh\n\n\nrun the following commands\n\n\nfoo@bar:~$ chmod 755 SolARFrameworkInstall-0.6.0.sh\nfoo@bar:~$ ./SolARFrameworkInstall-0.6.0.sh all\n\n\n\n\nnote that you can run the following command to get instructions on how to use the installer:\n\n\nfoo@bar:~$ ./SolARFrameworkInstall-0.6.0.sh\n\n\n\n\nas a result, a SolARFramework directory should now be present under your HOME directory. This directory should contain:\n\n\nfoo@bar:~$ ls SolARFramework\nbuild-scripts  samples  sources SolARLibraries\n\n\n\n\nin your terminal you can now run samples (executable) contained under the samples/ folder\n\n\nyou can also browse SolAR sources under the sources folder\n\n\nyou will be able to update your source tree, running the following command:\n\n\nfoo@bar:~$ ./build-scripts/updateGit.sh develop\n\n\n\n\nfinally you will be able to compile the source code:\n\n\nfoo@bar:~$ ./build-scripts/cmake-build.sh all\n\n\n\n\nnote that in order to run samples your LD_LIBRARY_PATH needs to contain current directory (\"./\"). This can be performed by running the following command:\n\n\nfoo@bar:~$ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH\n\n\n\n\n\n\n\n",
    id: 19
  });
  

index.add({
    title: "on linux",
    content: "\nTable of Contents\n\nInstall On Linux\nSupported distribution\nTest SolAR\nInstall development environment\n\nInstall QT Creator IDE\nInstall dependencies\n\n\nBuild SolAR v0.9.0\n\nClone SolAR\nBuild on Qt Creator\n\n\nQ&amp;A\n\nRemaken does not work\n\n\n\n\n\nInstall On Linux\n\n\n\n\n\nSupported distribution\n\n\nCurrently, only Ubuntu 18.04 distribution has been tested, and is highly recommended. We plan to support Ubuntu 20.04 very soon.\n\n\n\n\nTest SolAR\n\n\nWe provide you with a set of samples to test the possibilities of the SolAR framework. Each .zip file corresponds to stand-alone applications, including all necessary SolAR .dll and .exe files.\n\n\nTable 1. Available Samples\n\n\n\n\n\n\nNatural Image Marker\nhttps://github.com/SolarFramework/NaturalImageMarker/releases, V0.9.0 coming soon\n\n\nFiducial Marker\nhttps://github.com/SolarFramework/FiducialMarker/releases, V0.9.0 coming soon\n\n\n Sample-Slam\nhttps://github.com/SolarFramework/Sample-Slam/releases, V0.9.0 coming soon\n\n\nSample-Triangulation\nhttps://github.com/SolarFramework/Sample-Triangulation/releases, V0.9.0 coming soon\n\n\n\n\n\n\n\n\n\n\nPrint the marker included in .zip file to perform the test.\n\n\n\n\n\n\n\nInstall development environment\n\n\nThe SolAR framework uses a dedicated pipeline to link and compile code as well as internal tools for third party downloads which should make your job much easier.\nAs you will see later, the SolAR framework is based on QMake originally created by the Qt Company, but compliant with most IDE.\n\n\nInstall QT Creator IDE\n\nAs SolAR is using QMake file to setup the projects, we highly recommend to install Qt Creator. Moreover, you will have access to wizards which will help you create new SolAR modules, components and pipelines.\n\n\nDownload the latest version of QTCreator on the following link (scroll down to choose \"Downloads for open-source users\" for open-source development):\nQT installer download\n\n\nWhen downloaded, right clik on the Qt installer.run file, select properties, Permissions, and check Authorize execution of the file. Then, run your installer.\n\n\nCreate a Qt account if not already done, select where you want to install Qt.\nYou don&#8217;t need to install Qt SDK, just the Qt Creator. So just check the following components:\n\n\n\n\nQt x.x.x (last version proposed)\n\n\n\nWith Desktop gcc 64-bit (version of gcc is 7.5)\n\n\nAndroid (if you want to build SolAR for Android)\n\n\n\n\n\nDeveloper and Designer Tools\n\n\n\n\nand start the installation.\n\n\n\nInstall dependencies\n\nTo download dependencies, the SolAR framework uses the meta dependencies management tool Remaken supporting Conan, VCPKG and its native C++ packaging structure based on pkg-config description files.\n\n\nInstall Remaken\n\n\n\nIf Homebrew is not installed on your machine, you can use the following script to install it: Homebrew installer. Homebrew is used to install the last release of Remaken.\n\n\nsource ~/.profile to update brew eval modification to your ${HOME}/.profile. Try brew --version commands in terminal to check installation\n\n\nUse the following script to install and configure Remaken: Remaken installer. By default, Remaken installer will also install Conan, cmake and pkg_config which will be used afterwards. Try remaken --help, conan -h, and cmake -h commands in a terminal to check installation. This script will also add conan-community and bincrafters conan remotes. Conan will check these remotes for searching your dependencies.\n\n\nSolAR has its own conan remote to store pre-built dependencies for the common configurations used by the SolAR Framework. You will need to add this conan remote with the following command in a command prompt:\n\n\n\n\n\nconan remote add conan-solar https://artifact.b-com.com/api/conan/solar-conan-local\n\n\n\n\n\nThen, open a command prompt with administrator rights and run:\n\n\n\n\n\nremaken init --tag latest\n\n\n\nThis command will install the latest version of qmake building rules in your ${USER_HOME}/.remaken/rules folder.\n\n\nFinally, you need to configure your remaken profile according to your development environment. To do so, run the following command in a command prompt:\n\n\n\nremaken profile init --cpp-std 17 -b gcc -o linux -a x86_64\n\n\n\n\nSet conan profile\n\nAs we are using conan to download dependencies, you need to configure your default conan profile. To do so, open the default file available in your ${HOME}/.conan/profiles, and replace the configuration by the following one before saving it:\n\n\n\n[settings]\nos=Linux\nos_build=Linux\narch=x86_64\narch_build=x86_64\ncompiler=gcc\ncompiler.version=7\ncompiler.libcxx=libstdc++11\ncompiler.cppstd=17\nbuild_type=Release\n[options]\n[build_requires]\n[env]\n\n\n\nNow, you are ready to download your dependencies with remaken.\n\n\n\nUse Remaken\n\nRemaken uses a file called packagedependencies.txt to describe which depedencies to install, in which version, where to install them, where to download them, with which package manager and with which configuration.\n\n\nA global packagedepedencies.txt defining the common dependencies with specific packagedependencies_os.txt files defining dependencies which are specific for each os are available in the parent GIT repository SolAR, and can be downloaded on the following link:\n\n\n\n\npackagedependencies.txt\n\n\npackagedependencies-linux.txt\n\n\npackagedependencies-android.txt (optionnal, required for android cross building)\n\n\n\n\nCopy these files where you want on your computer, open a command prompt in the folder where you have copied the packagedependencies.txt and packagedependencies_os.txt files, and run remaken with the following command:\n\n\n\nremaken install packagedependencies.txt\n\n\n\nThis command will install all SolAR dependencies in release mode in your ${HOME}/.remaken/packages folder. You can go and have a cup of coffee while it&#8217;s downloading.\n\n\nTo download the dependencies in debug mode, run the following command:\n\n\n\nremaken install -c debug packagedependencies.txt\n\n\n\nThis is done, all your dependencies are downloaded and ready to use !\n\n\nSome of the module will download and build third parties using Conan which requires CMake (minimum version 3.10).\n\n\n\n\n\n\nBuild SolAR v0.9.0\n\n\nClone SolAR\n\nSolAR is made up of a multitude of projects (SolAR Framework, SolAR pipeline manager, modules, samples, etc.). To help you, we have created a parent repository with sub-modules regrouping all source codes of SolAR projects. You can clone it from the following url:\nhttps://github.com/SolarFramework/SolAR.git\n\n\n\n\n\n\n\n\nNo space in the path of the folder where you are cloning SolAR !\n\n\n\n\n\n\ngit clone https://github.com/SolarFramework/SolAR.git\n\n\n\nDo not forget to install and update recursively the submodules:\n\n\n\ncd SolAR\ngit submodule update --init --recursive\n\n\n\nIf you want to move all submodules on Master, launch the following command\n\n\n\ngit submodule foreach git pull origin master\n\n\n\nIf you do not want to download all the source codes of SolAR, you can have a look to the different repositories available on Github on the Community/Git page.\n\n\n\nBuild on Qt Creator\n\nCounting the framework, the pipeline manager, modules, module tests, samples, pipelines, pipeline tests, there are more than 60 QT projects on GitHub. In order to ease the building of all this projects, they are grouped in the following parent QT projects available into the root folder of SolAR:\n\n\n\n\nSolARCore\n\n\nSolARAllModules\n\n\nSolARAllModulesTests\n\n\nSolARAllSamples\n\n\nSolARAllPipelines\n\n\nSolARAllPipelineTests\n\n\n\n\nYou can open one of them or all in QT Creator.\n\n\nCheck by clicking on the Projects tab, and then on the Manage Kits&#8230;&#8203; button that your Qt x.x.x GCC 64 bit kit is well configured.\n\n\nNow, you have to configure your parent project before building them. In your project build settings of your kit, for each configuration (release and debug), add the following argument to the Builds Steps &gt; Make step:\n\n\n\n\nSolARCore: install\n\n\nSolARAllModules: install and install_deps\n\n\nSolARAllModulesTests: install and install_deps\n\n\nSolARAllSamples: install and install_deps\n\n\nSolARAllPipelines: install\n\n\nSolARAllPipelineTests: install and install_deps\n\n\n\n\nThe install step  will copy the built binaries into ${HOME}/.remaken/packages, and the install_deps step will also copy its dependencies.\n\n\n\n\n\nFigure 1. Add install and install_deps argument for Debug and Release mode.\n\n\nIf you open several projects, you will have to set their build order. You can do it in QT Creator by defining the dependencies of each project in the Projects menu, select your project, click and Dependencies, and check the projects that depend directly on the selected project (checking `Synchronize configuration' will synchronize all projects in Debug or Release configuration).\n\n\n\n\n\nFigure 2. Project dependencies settings\n\n\nTable 2. Project dependencies\n\n\n\n\n\n\nProject\nProject dependencies\n\n\n\n\nSolARAllModules\nSolARCore\n\n\nSolARAllModulesTests\nSolARAllModules\n\n\nSolARAllPipelines\nSolARAllModules\n\n\nSolARAllPipelineTests\nSolARAllPipelines\n\n\nSolARAllSamples\nSolARAllModules\n\n\nSolARCore\nNo dependency\n\n\n\n\nThen, in the Build menu, click on Rebuild All Projects for All Configurations, and go get a cup of coffee.\n\n\n\n\n\nQ&amp;A\n\n\nRemaken does not work\n\nBe sure to install, init and use Remaken from a command prompt with admin rights.\nYou can check that cmake, pkg-config and conan are well installed with the following command:\n\n\n\ncmake -version\n\n\n\n\npkg-config --version\n\n\n\n\nconan -v\n\n\n\n\n",
    id: 20
  });
  

index.add({
    title: null,
    content: "// builds lunr\nvar index = lunr(function () {\n  this.field('title')\n  this.field('content', {boost: 10})\n  this.ref('id')\n});\n\n{% assign count = 0 %}\n{% for page in site.pages %}\nindex.add({\n    title: {{page.title | jsonify}},\n    content: {{page.content | strip_html | jsonify}},\n    id: {{count}}\n  });\n  {% assign count = count | plus: 1 %}\n{% endfor %}\n\n\n{% for collection in site.collections %}\n  {% assign name = collection.label %}\n  {% assign sorted_pages = site[name] | sort:\"weight\" %}\n  {% for page in sorted_pages %}\n\n    index.add({\n      title: {{page.title | jsonify}},\n      content: {{page.content | strip_html | jsonify}},\n      id: {{count}}\n    });\n    {% assign count = count | plus: 1 %}\n\n  {% endfor %}\n{% endfor %}\n\n\nvar store = [];\n{% for page in site.pages %}\n  {% capture link %}{{ site.url }}{{ site.baseurl }}{{ page.url }}{% endcapture %}\nstore.push({\"title\": {{page.title | jsonify}},\n  \"link\": {{ link | jsonify }}\n});\n{% endfor %}\n\n{% for collection in site.collections %}\n  {% assign name = collection.label %}\n  {% assign sorted_pages = site[name] | sort:\"weight\" %}\n  {% for page in sorted_pages %}\n    {% capture link %}{{ site.url }}{{ site.baseurl }}{{ page.url }}{% endcapture %}\n    store.push({\"title\": {{page.title | jsonify}},\n      \"link\": {{ link | jsonify }}\n    });\n  {% endfor %}\n{% endfor %}\n\nfunction searchAndDisplay(query){\n  var resultdiv = $('#results');\n  var result = index.search(query);\n  // Show results\n  resultdiv.empty();\n  // Add status\n  resultdiv.prepend('Found '+result.length+' result(s)');\n  // Loop through, match, and add results\n  for (var item in result) {\n    var ref = result[item].ref;\n    var searchitem = ''+store[ref].title+'';\n    resultdiv.append(searchitem);\n  }\n}\n\n// builds search\n$(document).ready(function() {\n    var query = (decodeURI(location.search).split(\"q\" + '=')[1] || '').split('&')[0];\n    var formattedQuery = query.split(\"+\").join(\" \");\n    searchAndDisplay(formattedQuery);\n\n    $('input#search').on('keyup', function () {\n      var query = $(this).val();\n      searchAndDisplay(query);\n    });\n});\n",
    id: 21
  });
  

index.add({
    title: "Made with SolAR",
    content: ":page-layout: _auto\n= Made with SolAR\n:showtitle:\n:page-title: Made with SolAR\n:page-description: Made with SolAR\n:page-liquid:\n\nTo be done\n",
    id: 22
  });
  

index.add({
    title: null,
    content: "/* colors part */\n$blue: #00bee6;\n$purple: #be64ff;\n$red: #ff5050;\n$green: #00cd78;\n$yellow: #ffb400;\n$gray: #666666;\n$transparent-blue: rgba(0, 190, 230, .5);\n$transparent-purple: rgba(190, 100, 255, .5);\n$transparent-red: rgba(255, 80, 80, .5);\n$transparent-green: rgba(0, 205, 120, .5);\n$transparent-yellow: rgba(255, 180, 0, .5);\n$transparent-gray: rgba(255, 255, 255, .5);\n\nhtml {\n  min-height: 100%;\n}\n\nbody {\n   font-family: Arial, sans-serif;\n   font-size: 14px;\n   line-height: 1.42857143;\n   background-repeat: no-repeat;\n   background: rgb(76,86,95); /* Old browsers */\n   background: -moz-radial-gradient(top, ellipse cover, rgba(76,86,95,1) 0%,rgba(15,16,18,1) 100%); /* FF3.6-15 */\n   background: -webkit-radial-gradient(top, ellipse cover, rgba(76,86,95,1) 0%,rgba(15,16,18,1) 100%); /* Chrome10-25,Safari5.1-6 */\n   background: radial-gradient(ellipse at top, rgba(76,86,95,1) 0%,rgba(15,16,18,1) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */\n   filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c565f', endColorstr='#0f1012',GradientType=1 ); /* IE6-9 fallback on horizontal gradient */\n   color: #fff;\n}\n\np.mandatory {\n  text-align: right;\n  font-size: 12px;\n  margin-bottom: 0px;\n}\n\nh1 {\n  margin-top: 0px;\n}\n\n/*information/loading text in navbar*/\n.text-warning, .text-info, .text-error {\n  padding-top:15px;\n  font-weight: bold;\n  font-size: 16px;\n}\n.text-warning {\n  color: $yellow;\n}\n.text-info {\n  color: #FFFFFF;\n}\n.text-error {\n  color: $red;\n}\n\n.btn {\n  text-align: left;\n}\n\n@import 'navbar';\n\n@import 'toc';\n\n@import 'codeblockandscrollbar';\n\n.listingblock > .title {\n  color: $gray; /* To be overload by _colorperpage.scss */\n}\n\n.well {\n  background-color: transparent;\n  -webkit-box-shadow: none;\n  box-shadow: none;\n  border: none;\n  border-radius: 0px;\n  .sect1 + .sect1 {\n    margin-top: 50px;\n  }\n  h1 {\n    display: none;\n  }\n  h2 {\n    text-transform: uppercase;\n    text-align: center;\n    font-size: 13px;\n    color: white;\n    display: inline-block;\n    padding: 5px 20px;\n    margin-top: 0px;\n    position: absolute;\n    top: -12px;\n  }\n  a {\n    text-decoration: underline;\n  }\n}\n\n@import 'submenu';\n\n\n@import 'colorperpage';\n\n\n@import 'homepage';\n\n\n@import 'responsive';\n",
    id: 23
  });
  

index.add({
    title: "create module",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: create module\n:page-description: create module\n:page-layout: default\n:page-category: create\n:page-liquid:\n:toc:\n\n== Create a module [[CreateModule]]\n\n== What is a module ?\n\nA module consists of a shared library embedding a set of SolAR components as well as the corresponding factories to instantiate them. The management of modules is based on the https://github.com/b-com-software-basis/xpcf[XPCF] third party providing a lightweight cross platform component framework.\nXPCF provides the following features to manage SolAR modules:\n\n* introspection to figure out which components are available in the module\n* separate implementation from interface to create the concrete implementation of a SolAR component and to bind it to an abstract SolAR and XPCF component interfaces.\n* component creation\n\nEach module implementation is identified with a Universally Unique IDentifier (UUID) to nearly ensure the uniqueness of a component implementation when the system instantiates it.\n\nAs mentionned previoulsy, the third party XPCF can introspect the shared library of a module to obtain information about the embedded components and the interfaces they implement. Only, the introspection of a shared library requires to load it, what could become tricky when the shared library has been built on a different platform than yours (useful for authoring tools supporting cross-platform compilation such as Unity). For this reason, XPCF proposes to associate to each module a registry file in xml format that describes the module with:\n\n* the module UUID,\n* the components embedded in the module with their UUID,\n* the abstract component interfaces implemented by the components.\n\nThus, any system will be able to intropsect a module without the need to load the corresponding shared library.\n\n== Create a module with the wizard\n=== Download QTCreator wizards for XPCF\nCreating a new module from scratch can be a little bit tricky. To help you, a QTCreator wizard is available and will make the task much easier. +\nStart by installing this wizard by launching the _install.bat_ on Windows (in your ${REMAKEN_PKG_ROOT}/packages/win-cl-14.1/xpcf/[version]/wizards) or _install.sh_ on Linux (in your ${REMAKEN_PKG_ROOT}/packages/linux-gcc/xpcf/[version]/wizards). +\n\nYou can also download the wizard on the following link: +\nhttps://github.com/SolarFramework/Tools/releases/download/XPCFWizard_2_3_4/XPCF_qtcreator_wizards.zip +\nThen unzip the downloaded file, and run the _install.bat_ on Windows or the _install.sh_ on Linux.\n\n=== Create a SolAR module in QTCreator\n\nOpen QTCreator and create a new project (in File menu). +\n\nSelect `_XPCF project_` and `_XPCF Module template_` and click on `_Choose_` button. +\n\nimage::images\\QTCreatorModuleWizard1.png[create an SolAR Module in QT,600,600, align=\"center\", title=\"Create an SolAR Module in QT\"]\n\nThen, set the name of your module and its location (The creation a dedicated folder regrouping all module projects is recommended).\n\nimage::images\\QTCreatorModuleWizard2.png[Set module project name in QT,600,600, align=\"center\", title=\"Set module project name in QT\"]\n\nNext provide the details concerning your module. You can set a different name to the package for your module if you want to embed several modules in the same package. But by default, keep the same one. Also, you can define if you want to produce a static or a shared library. We highly recommend to use the shared library for modules. Also, for installation, all dependencies of your module can be copied in a recursive mode in your package folder. Thus, when you will deploy your module, you will be sure that all required third parties will be also deployed. For the link step, you can let the SolAR build pipeline find automatically the dependencies recursively. Finally, if you want to load your project in visual studio, check the box QTVS. Thus, you will be able to load the QTProject in visual studio via the plugin https://download.qt.io/development_releases/vsaddin/[QTtVisual Studio Tools].\n\nimage::images\\QTCreatorModuleWizard3.png[set module details in QT,600,600, align=\"center\", title=\"Set module details in QT\"]\n\nThen, define your build system with _qmake_. +\n\nFor the next step, you have to enter the directory where the xpcf binaries are located. Normally, you will find it in your __, in the folder _.remaken\\packages\\_. You have also to set the namespace of your module. In order to have easy access to all your modules by completion when coding, we recommend to use the  namespace _SolAR::MODULES::MyModule_ for any module.\n\nimage::images\\QTCreatorModuleWizard4.png[set XPCF version directory and namespace,600,600, align=\"center\", title=\"Set XPCF version directory and namespace\"]\n\nThen, you have to choose your remaken rules. You can choose to use your own remaken rules, but when it is not necessary, we recommend to use the ones available in your _/.remaken/rules_ folder (normally installed when you have installed SolAR). \n\nimage::images\\QTCreatorModuleWizard5.png[remaken rules selection,600,600, align=\"center\", title=\"Remaken rules selection\"]\n\nNext, choose your development kits. We recommend to use _MSVC 2017 64bit_ on Windows or _Clang_ on Linux. +\n\nFinally, no subproject to add here, if you want to add a version control, select it and click on the `_Finish_` button.\n\nYour module is now created, you have just to configure it in QTCreator. Click on `_Projects_` in the left menu, select the developement kits of your choice, and click on `_Configure Project_`.\n\nimage::images\\QTCreatorModuleWizard6.png[Configure Project,600,600, align=\"center\", title=\"Configure your project\"]\n\nFive files have been created, the project file _MyModule.pro_, a C++ file _MyModule_main.cpp_, a header file _MyModuleAPI.h_ defining the macro to export your interfaces, a _packagedependencies.txt_ file to manage the dependencies of your module, and finally a bcom_MyModule.pc.in used by https://www.freedesktop.org/wiki/Software/pkg-config/[pkg_config] to describe your module.\n\nBut let's take a closer look at these files.\n\n=== QTCreator project file\n\n.MyModule.pro\n----\n## remove Qt dependencies\nQT       -= core gui\nCONFIG -= qt\n\n## global defintions : target lib name, version\nINSTALLSUBDIR = SolARBuild\nTARGET = MyModule\nFRAMEWORK = $$TARGET\nVERSION=X.X.X #\n\nDEFINES += MYVERSION=$${VERSION}\nDEFINES += TEMPLATE_LIBRARY\nCONFIG += c++1z\n\ninclude(findremakenrules.pri) #\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += _NDEBUG=1\n    DEFINES += NDEBUG=1\n}\n\nDEPENDENCIESCONFIG = shared install_recurse #\n\n## Configuration for Visual Studio to install binaries and dependencies. Work also for QT Creator bby replacing QMAKE_INSTALL\nPROJECTCONFIG = QTVS #\n\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude ($$shell_quote($$shell_path($${QMAKE_REMAKEN_RULES_ROOT}/templatelibconfig.pri)))  # Shell_quote & shell_path required for visual on windows\n\n## DEFINES FOR MSVC/INTEL C++ compilers\nmsvc {\nDEFINES += \"_BCOM_SHARED=__declspec(dllexport)\"\n}\n\nINCLUDEPATH += interfaces/\n\ninclude (MyModule.pri)\n#SOURCES +=     MyModule_main.cpp\n#HEADERS +=     MyModuleAPI.h\n\nunix:!android {\n    QMAKE_CXXFLAGS += -Wignored-qualifiers\n#    QMAKE_LINK=clang++\n#    QMAKE_CXX = clang++\n}\n\nmacx {\n    DEFINES += _MACOS_TARGET_\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CFLAGS += -mmacosx-version-min=10.7 -std=c11 #-x objective-c++\n    QMAKE_CXXFLAGS += -mmacosx-version-min=10.7 -std=c11 -std=c++11 -O3 -fPIC#-x objective-c++\n    QMAKE_LFLAGS += -mmacosx-version-min=10.7 -v -lstdc++\n    LIBS += -lstdc++ -lc -lpthread\n}\n\nwin32 {\n\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275 /Od\n}\n\nandroid {\n    ANDROID_ABIS=\"arm64-v8a\"\n}\nheader_files.path = $${PROJECTDEPLOYDIR}/interfaces\nheader_files.files = $$files($${PWD}/interfaces/*.h*)\n\nxpcf_xml_files.path = $${USERHOMEFOLDER}/.xpcf/SolAR\nxpcf_xml_files.files=$$files($${PWD}/xpcf*.xml)\n\nINSTALLS += header_files\nINSTALLS += xpcf_xml_files\n\nOTHER_FILES += \\\n    packagedependencies.txt \\\n    packagedependencies-linux.txt \\\n    packagedependencies-mac.txt \\\n    packagedependencies-win.txt \\\n    packagedependencies-android.txt\n\n#NOTE : Must be placed at the end of the .pro\ninclude ($$shell_quote($$shell_path($${QMAKE_REMAKEN_RULES_ROOT}/remaken_install_target.pri))))  # # Shell_quote & shell_path required for visual on windows\n----\n [white]#Set the version number of your module,#\n [white]#This .pri file has been installed by the wizard. It will allow to find the remaken folder depending on the OS you are using.#\n [white]#The dependencies of your module will be installed recursively. More details are available on the https://github.com/b-com-software-basis/builddefs-qmake/[builddefs-qmake] project on GitHub.#\n [white]#The installation of your module will also work with Visual Studio. Warning, in QTCreator, this will replace the usual QMAKE_INSTALL.#\n [white]#Place at the end the .pri file to install your module.#\n\n=== Package Dependencies file [[Module_Dependencies]]\n\nAs mentionned previously, SolAR framework provides developers with a build pipeline allowing among other things to easily manage dependencies (download, version management, packaging during deployment step, etc.).\n\nTo define the dependencies used by your pipeline, just add to your _packagedependencies.txt_ a reference to the SolARFramework and to the third parties used by your module as shown below:\n\n/.packagedependencies.txt\n----\nSolARFramework|0.8.0|SolARFramework|SolARBuild@github|https://github.com/SolarFramework/SolarFramework/releases/download\nMyThirdParty1|x.x.x|MyThirdPaty1Folder|ThirdParty@github|https://github.com/MyGitHubProject/MyModule/releases/download #\nMyThirdParty2#stable|x.x.x|MyThirdParty2Folder|conan|conan-center|shared|MyThirdParty2BuildOption #\n----\n [white]#Your third party is available in the release of your github project. To know how to package your third party, check the > page#\n [white]#Your third party can be directly downloaded using https://www.freedesktop.org/wiki/Software/pkg-config/[conan] (for instance, from https://conan.io/center/[conan-center]).# \n\nYou will find bellow the syntax for each dependency (more information are available on the https://github.com/b-com-software-basis/remaken[Remaken] project on GitHub):\n\n----\ndependency_name|dependency_version|dependency_folder_name|dependency_path|dependency_download_url\n----\n\nXPCF and the build pipeline handle dependencies recursivity, meaning that you do not need to add the dependencies of the SolAR framework. \n\nYour third parties, should be available in your _/.remaken/packages//_ folder. To automatically download your dependencies, just run remaken where your _packagedependencies.txt_ is located.\n\nNumerous samples of packagedependencies.txt files can be found with the SolAR Modules you have surely installed on your machine.\n\n=== MyModuleAPI.h\n\nThe file _MyModuleAPI.h_ has been automatically created and it defines the macro _MYMODULE_EXPORT_API_ you will have to place in front of each component interface to export them in your shared library.\n\n=== MyModule_main.cpp\n\n/MyModule_main.cpp\n[source,cpp]\n----\n#include \n#include \n\nnamespace xpcf=org::bcom::xpcf;\n\n/**\n *  @ingroup xpcfmodule\n */\n/**\n  * Declare module.\n  */\n \nXPCF_DECLARE_MODULE(\"{5b066de7-2a9f-4dff-a730-ce82adafe2f6}\",\"SolAR::MODULES::MyModule\",\"MyModule module description\"); \n\n/**\n * This method is the module entry point.\n * XPCF uses this method to create components available in the module.\n *\n * Each component exposed must be declared inside a xpcf::tryCreateComponent() call.\n */\n \nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const xpcf::uuids::uuid& componentUUID,SRef& interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n    errCode = xpcf::tryCreateComponent(componentUUID,interfaceRef);\n    if (errCode != xpcf::XPCFErrorCode::_SUCCESS) {\n        errCode = xpcf::tryCreateComponent(componentUUID,interfaceRef);\n    }\n    return errCode;\n}\n\n/**\n  * The declarations below populate list of the components available in the module (it represents the module index).\n  * XPCF uses this index to introspect the components available in a module, providing the ability to generate the configuration file skeleton from the code.\n  */\n\nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::MODULES::MyModule::componentType)\nXPCF_ADD_COMPONENT(SolAR::MODULES::MyModule::otherComponentType)\nXPCF_END_COMPONENTS_DECLARATION\n----\nThis .cpp file has three main goals:\n\n [white]#It Declares the module to XPCF with a given UUID, a given namespace and a given name#\n [white]#It allows the XPCF component factory, thanks to the _XPCF_getComponent_ method, to retrieve and create the component from its UUID#\n [white]#it declares the components embedded in the module#\n\nEach time you will want to embed a new component into the module, you will have to add its creation in the _XPCF_getComponent_ method and to add it in the component declaration.\n\n=== MyModule.pc.in file\nThe SolAR build pipeline can use https://www.freedesktop.org/wiki/Software/pkg-config/[pkg-config] that helps to insert the correct compiler options on the command line so an application can use _gcc -o test test.c pkg-config --libs --cflags glib-2.0_ for instance, rather than hard-coding values on where to find glib (or other libraries). When you will install your module, this file will be directly copied to your binary folder _/.remaken/packages////_.\n\n=== The registry file [[RegistryFile]]\nAs mentionned previoulsy, a shared library has to be loaded for introspection, what is quite tricky when it has been built on a platform different from yours. For this reason, we always associate to a module a registry file describing information about the module itself and its components.\n\nCreate an xml file, name it _xpcf_MyModule_registry.xml_, and copy the following code in it (again replace _MyModule_ with the name of your module):\n\n.xpcf_MyModule_registry.xml\n[source,xml]\n----\n\n\n\n\n\n----\n [white]#Copy and paste the module UUID, name and description defined in the file _MyModule.cpp_. Update the path by replacing _MyModule_ by the name of your module and _MyModule_version_ by the version number of your module defined in your _.pro_ and in your _CMakeLists.txt_ files.#\n\nThis file is somewhat empty, but will be completed when adding components. It will be copied to the xpcf registry folder _+++HOME_USER_/.xpcf/+++_. ",
    id: 24
  });
  

index.add({
    title: "module api",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: module api\n:page-description: module api\n:page-layout: default\n:page-category: assemble\n:page-liquid:\n:toc:\n\n== Module API\n\n== Module API [[ModuleAPI]]\nIn order to create your SolAR pipeline, please refer to the list of available API of modules provided by SolAR :\n\n\n++++\n\n++++\n",
    id: 25
  });
  

index.add({
    title: "package &amp; download third parties",
    content: ":page-layout: _auto\n= package & download third parties\n\n\n== packaging\n\n. clone the following git repository:\ngit clone ssh://gitolite@forge.b-com.com/bcom-templates/builddefs/builddefs-scripts.git\n\n\nStarting from a fresh installed package (ie. result of a \"make install\"), run\nthe following perl script (under builddefs-scripts/xplatform)\n\n  $ bcom-packager.pl\n----\n  OPTIONS:\n      -s, --sourcedir                  => product root directory (where libs and includes are located)\n      -o, --osname                     => specify the operating system targeted by the product build. It is one of [win|mac|linux]. (defaults to the current OS environment)\n      -i, --includedir                 => relative path to include folder to export (defaults to the sourcedir provided with -s)\n      -l, --libdir                     => relative path to the library folder to export (defaults to the sourcedir provided with -s)\n      -r, --redistfile                 => relative path and filename of a redistribution file to use (such as redist.txt intel ipp's file). Only listed libraries in this file will be packaged\n      -d, --destinationdir             => package directory root destination (where the resulting packaging will be stored)\n      -p, --packagename                => package name\n      -v, --packageversion             => package version\n      -n, --ignore-mode                => forces the pkg-config generated file to ignore the mode when providing -L flags\n      -m, --mode [debug|release]       => specify the current product build mode. Binaries will be packaged in the appropriate [mode] folder\n      -a, --architecture [x86_64|i386] => specify the current product build architecture. Binaries will be packaged in the appropriate [architecture] folder\n      -w, --withsuffix suffix          => specify the suffix used by the thirdparty when building with mode mode\n      -u, --useOriginalPCfiles         => specify to search and use original pkgconfig files from the thirdparty, instead of generating them\n      -h, --help                       => display this help\n\n  EXAMPLES:\n      -s {path_to_root_sourcedir} --o win d {path_to_destination_dir} -p intel-tbb -v 2017.5 -l build/macos_intel64_clang_cc8.0.0_os10.11.6_release -m release -i include\n\n----\n\n. Use the artifactory packager scripts.\n\nUnder windows, use *builddefs-scripts/win/artiPackager.bat*\n\nUnder linux, use *builddefs-scripts/unixes/artiPackager.sh*\n\nUsage: run the .bat / .sh scripts where the packages are.\n\n== Using pkgm-bcom\n\n. Source: https://forge.b-com.com/www/bcom-templates//tools/pkgm-bcom-index/\n. You must have java installed on your machine: http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n. You will need to create an artifactory API_KEY: http://repository.b-com.com/webapp/#/profile\n. Download pkgm-bcom tool here: http://repository.b-com.com/bcom-devtools-generic-local/pkgm-bcom/1.0.0/multi/pkgm-1.0.0-fat.jar\n. In order to download dependencies described in a packagedependencies.txt file, you will need to launch:\n\n    java -jar [path to]/pkgm-1.0.0-fat.jar install -a x86_64 -c release -m shared -f packagedependencies.txt -k [YOUR artifactory API KEY]\n\n. NB: this will work only if third parties are available on artifactory repository\n\nFor example packagedependencies.txt can include the two following lines:\n\n  opencv|3.2.0|opencv|thirdParties|http://repository.b-com.com/argo-generic\n  boost|1.64.0|boost|thirdParties|http://repository.b-com.com/argo-generic\n",
    id: 26
  });
  

index.add({
    title: null,
    content: ":page-layout: _auto\nIf you open several projects, you will have to set their build order. You can do it in QT Creator by defining the dependencies of each project in the `Projects` menu, select your project, click and Dependencies, and check the projects that depend directly on the selected project (checking `Synchronize configuration' will synchronize all projects in Debug or Release configuration).\n\nimage::images\\Project_dependencies_Win.png[Edit build settings,800,800, align=\"center\", title=\"Project dependencies settings\"]\n\n.Project dependencies\n|===\n| Project | Project dependencies\n\n| SolARAllModules | SolARCore\n| SolARAllModulesTests | SolARAllModules\n| SolARAllPipelines | SolARAllModules\n| SolARAllPipelineTests | SolARAllPipelines\n| SolARAllSamples | SolARAllModules\n| SolARCore | No dependency\n|===\n",
    id: 27
  });
  

index.add({
    title: null,
    content: ":page-layout: _auto\nshowtitle:\n:page-title: project file\n:page-description: project file\n:page-layout: default\n:page-category: assemble\n:page-liquid:\n:toc:\n\n== Project File\n\n== Qt file\nHere is an example of a Qt project file that can be use as a starting point for any standalone project :\n[source]\n----\nTARGET = SolARImageOpenCVDynTest\nVERSION=0.5.2\n\nCONFIG += c++11\nCONFIG -= qt\nCONFIG += console\n\nDEFINES += MYVERSION=$${VERSION}\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += NDEBUG=1\n}\n\nwin32:CONFIG -= static\nwin32:CONFIG += shared\n\nDEPENDENCIESCONFIG = sharedlib\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude ($$(BCOMDEVROOT)/builddefs/qmake/templateappconfig.pri)\n\nSOURCES += \\\n    main.cpp\n\nunix {\n    LIBS += -ldl\n    QMAKE_CXXFLAGS += -DBOOST_LOG_DYN_LINK\n}\n\nmacx {\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CXXFLAGS += -fasm-blocks -x objective-c++\n}\n\nwin32 {\n    QMAKE_LFLAGS += /MACHINE:X64\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n\n    # Windows Kit (msvc2013 64)\n    LIBS += -L$$(WINDOWSSDKDIR)lib/winv6.3/um/x64 -lshell32 -lgdi32 -lComdlg32\n    INCLUDEPATH += $$(WINDOWSSDKDIR)lib/winv6.3/um/x64\n\n}\n\n----\n\nTo adapt this project to your use case, just change the name of the target and if required, add/modify the SOURCES and HEADERS attributes.\n\n== Cmake file\nHere is and example of a cmakelist.txt file that can be used for e.g. generate a Visual Studio solution. It will generate the same executable as the project file displayed above.\n\n[source]\n----\ncmake_minimum_required(VERSION 3.7.2)\n\n##################################################\nproject(\"SolARImageOpenCVDynTest\")\nset (SOURCES main.cpp)\n##################################################\n\n# various macros\ninclude(\"$ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/solarmacros.cmake\")\n# config setup\nsetup()\n# process packagedependencies.txt\nprocessPackagedependencies()\n\n# define the list of files to copy to build directory\n\n\nset(FILES_TO_COPY\n\n\t$ENV{BCOMDEVROOT}/thirdParties/opencv/${OPENCV_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}opencv_world${OPENCVVERSIONSUFFIX}.${LIBEXTENSION}\n\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_filesystem.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_system.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_timer.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_log.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_chrono.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_thread.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_date_time.${LIBEXTENSION}\n\n\t$ENV{BCOMDEVROOT}/bcomBuild/SolARModuleOpenCV/${SOLARMODULEOPENCV_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}SolARModuleOpenCV.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/${SOLARFRAMEWORK_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}SolARFramework.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/xpcf/${XPCF_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}xpcf.${LIBEXTENSION}\n\t)\n# define targets (library, install and uninstall)\ndefineTargets(\"executable\" \"${FILES_TO_COPY}\")\n\n\n----\n\nTo adapt this cmake file  to your use case, just change the name of the target and if required, add/modify the SOURCES and HEADERS attributes.\n",
    id: 28
  });
  

index.add({
    title: null,
    content: "// builds lunr\nvar index = lunr(function () {\n  this.field('title');\n  this.field('content', {boost: 10});\n  this.ref('id');\n});\n \n{% assign count = 0 %}\n{% for page in site.pages %}\n  {% if page.title != null %}\n    // do not take into account items that are from subpages (title == null),\n    // because we don't know in wich (potentially) multiples page(s) these supages can be includedt items that are from subpages (title ==null), because we don't know in wich (potentially) multiples page(s) these supages can be included\n    index.add({\n      \"title\": {{ page.title | jsonify }},\n      \"content\": {{ page.content | strip_html | jsonify }},\n      \"id\": {{ count }}\n    });\n    {% assign count = count | plus: 1 %}\n  {% endif %}\n{% endfor %}\n \n// builds reference data\nvar store = [];\n \n{% for page in site.pages %}\n  {% if page.title != null %}\n    // do not take into account items that are from subpages (title == null),\n    // because we don't know in wich (potentially) multiples page(s) these supages can be included\n    {% capture link %}{{ page.url | relative_url }}{% endcapture %}\n    store.push({\n      \"title\": {{page.title | jsonify }},\n      \"link\": {{ link | jsonify }}\n    });\n  {% endif %}\n{% endfor %}\n \nfunction searchAndDisplay(query){\n  var resultdiv = $('#results');\n  var result = index.search(query);\n  // Remove previous results\n  resultdiv.empty();\n  // Add status\n  resultdiv.prepend('Found '+result.length+' result(s) for keyword: '+query+'');\n  // Loop through, match, and add results\n  result.forEach(function(item) {\n    var ref = item.ref;\n    var searchitem = ''+store[ref].title+'';\n    resultdiv.append(searchitem);\n  });\n}\n \n// builds search\n$(document).ready(function() {\n  var query = (decodeURI(location.search).split('q=')[1] || '').split('&')[0];\n  var formattedQuery = query.split('+').join(' ');\n  searchAndDisplay(formattedQuery);\n \n  $('input#search').val(formattedQuery).on('keyup', function () {\n    var query = $(this).val();\n    searchAndDisplay(query);\n    console.log(\"inputsearch query=\"+query);\n  });\n});",
    id: 29
  });
  

index.add({
    title: "Search",
    content: "Search results\n\n\n",
    id: 30
  });
  

index.add({
    title: "standalone pipeline",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: standalone pipeline\n:page-category: assemble\n:page-description: standalone pipeline\n:page-liquid:\n:page-layout: default\n:toc:\n\n== Assemble a standalone {cpp} pipeline\n\n== What is standalone {cpp} pipeline ?\nA standalone {cpp} pipeline is a SolAR pipeline running in a standalone application. This pipeline will be defined in a _main.cpp_ class, and is very useful for pipeline debugging. We recommend starting with this approach to familiarize yourself with pipeline assembly.\n\n== Initialize your pipeline with the QTCreator wizard\n\n=== Download QTcreator wizards for XPCF\nCreating a new pipeline from scratch can be a little bit tricky. To help you, a QTcreator wizard is available and will make the task much easier.\nStart by uploading the QTcreator wizards for XPCF available on the following link:\nhttps://github.com/SolarFramework/Tools/releases/download/XPCFWizard_2_3_0/XPCF_qtcreator_wizards.zip\n\nunzip the downloaded file, and run the _install.bat_ for Windows or the _install.sh_ for Linux.\n\n=== Create a standalone SolAR pipeline in QTCreator\n\nOpen QTCreator and create a new project (in File menu).\n\nSelect `_XPCF project_` and `_XPCF Application template_` and click on `_Choose_` button.\n\nimage::images\\QTProjectAppCreation.png[create an XPCF C++ application in QT,600,600, align=\"center\", title=\"Create an XPCF C++ application in QT\"]\n\nThen, set the name of your application embedding your pipeline, and its location (Create a dedicated folder with all pipeline projects is recommended).\n\nimage::images\\QTProjectAppCreation2.png[Set pipeline project name in QT,600,600, align=\"center\", title=\"Set pipeline project name in QT\"]\n\nNext provide the details concerning your application. You can define if your dependencies are static or shared. We highly recommend to use the shared library for modules. Also, for installation, all dependencies of your application can be copied in a recursive mode in your installation folder. Thus, when you will install your application, you will be sure that all required third parties will be also there to run it. For the link step, you can let the SolAR build pipeline find automatically the dependencies recursively. Finally, if you want to load your project in visual studio, check the box QTVS. Thus, you will be able to load the QTProject in visual studio via the plugin https://download.qt.io/development_releases/vsaddin/[QT Visual Studio Tools].\n\nimage::images\\QTProjectAppCreation3.png[set application details in QT,600,600, align=\"center\", title=\"Set application details in QT\"]\n\nFor the next step, you have to enter the directory where the xpcf binaries are located. Normally, you will find it in your USER_HOME, in the folder _.remaken\\packages\\_.\n\nimage::images\\QTProjectAppCreation4.png[Set XPCF version directory,600,600, align=\"center\", title=\"Set XPCF version directory\"]\n\nThen, you have to choose your remaken rules. You can choose to use your own remaken rules, but when it is not necessary, we recommend to use the ones available in your _/.remaken/rules_ folder (normally installed when you have installed SolAR).\n\nimage::images\\QTProjectAppCreation5.png[remaken rules selection,600,600, align=\"center\", title=\"Remaken rules selection\"]\n\nChoose your development kits. We recommend to use _MSVC 2017 64bit_ on Windows or _Clang_ on Linux.\n\n\nThen, no subproject to add, if you want to add a version control select it, and click on Finish.\n\n\nYour project is now created, you have just to configure it in QTCreator. Click on _Projects_ in the left menu, select the developement kits of your choice, and click on _Configure Project_.\n\nimage::images\\QTProjectAppCreation6.png[Configure Project,600,600, align=\"center\", title=\"Configure your project\"]\n\nThree files have been created. First the project file _MyStandalonPipeline.pro_, secondly a C++ file _MyStandalonePipeline_main.cpp_, and finally a _packagedependencies.txt_ to manage the dependencies of your application.\n\nBut let's take a closer look at these files.\n\n=== QTCreator project file\n\n.MyStandalonePipeline.pro\n[source]\n----\nQT       -= core gui\nCONFIG -= qt\n\nTARGET = MyStandalonePipeline\nVERSION=X.X.X #\nDEFINES += MYVERSION=$${VERSION}\nCONFIG += c++1z\nCONFIG += console\n\ninclude(findremakenrules.pri) #\n\nCONFIG(debug,debug|release) {\n    TARGETDEPLOYDIR = $${PWD}/../bin/Debug\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    TARGETDEPLOYDIR = $${PWD}/../bin/Release\n    DEFINES += _NDEBUG=1\n    DEFINES += NDEBUG=1\n}\n\nwin32:CONFIG -= static\nwin32:CONFIG += shared\n\nDEPENDENCIESCONFIG = sharedlib install_recurse #\n\n## Configuration for Visual Studio to install binaries and dependencies. Work also for QT Creator by replacing QMAKE_INSTALL\nPROJECTCONFIG = QTVS #\n\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude ($$shell_quote($$shell_path($${QMAKE_REMAKEN_RULES_ROOT}/templateappconfig.pri)))  # Shell_quote & shell_path required for visual on windows\n\n#DEFINES += BOOST_ALL_NO_LIB\nDEFINES += BOOST_ALL_DYN_LINK\nDEFINES += BOOST_AUTO_LINK_NOMANGLE\nDEFINES += BOOST_LOG_DYN_LINK\n\nHEADERS += \\\n\nSOURCES += \\\nMyStandalonePipeline_main.cpp\n\nunix {\n    LIBS += -ldl\n    QMAKE_CXXFLAGS += -DBOOST_LOG_DYN_LINK\n}\n\nmacx {\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CXXFLAGS += -fasm-blocks -x objective-c++\n}\n\nwin32 {\n    QMAKE_LFLAGS += /MACHINE:X64\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275\n\n    # Windows Kit (msvc2013 64)\n    LIBS += -L$$(WINDOWSSDKDIR)lib/winv6.3/um/x64 -lshell32 -lgdi32 -lComdlg32\n    INCLUDEPATH += $$(WINDOWSSDKDIR)lib/winv6.3/um/x64\n }\n\nconfig_files.path = $${TARGETDEPLOYDIR}\nconfig_files.files=$$files($${PWD}/conf_MyPipeline.xml)\\\n\t\t\t\t\t$$files($${PWD}/camera_calibration.yml)\nINSTALLS += config_files\n\nOTHER_FILES += \\\n    packagedependencies.txt\n\n#NOTE : Must be placed at the end of the .pro\ninclude ($$shell_quote($$shell_path($${QMAKE_REMAKEN_RULES_ROOT}/remaken_install_target.pri)))) # # Shell_quote & shell_path required for visual on windows\n----\n [white]#Set the version number of your application,#\n [white]#This .pri file has been installed by the wizard. It will allow to find the remaken folder depending on the OS you are using.#\n [white]#The dependencies of your application will be installed recursively. More details are available on the https://github.com/b-com-software-basis/builddefs-qmake/[builddefs-qmake] project on GitHub.#\n [white]#The installation of your application will also work with Visual Studio. Warning, in QTCreator, this will replace the usual QMAKE_INSTALL.#\n [white]#Place at the end the .pri file to install your application.#\n\nFinally, click on `_Projects_` in the left menu of QTcreator, click on _Run_, set your working directory to the root directory of your project, and check _Add build library search path to PATH_ if not already done.\n\n=== Package Dependencies file\n\ninclude::_dependencies_file.adoc[]\n\nRight now, your project is configured.\n\n== What about Visual Studio ?\n\nYou can load your _.pro_ file created with the Wizard in Visual Studio (see above for more details how to configure the _.pro_ file). If you do not want to install QTCreator, create manually your _.pro_ based of the above description.\n\nMicrosoft Visual Studio provides a Qt Visual Studio Tools. This enables developers to import QT project files (.pro) into Visual Studio.\n\nInstall QT Visual Studio Tools:\n\n* In Visual Studio, select *Tools > Extensions and Updates > Online* to install and update QT Visual Studio Tools.\n\nImport the _.pro._ file into Visual Studio:\n\n* Select *Qt VS Tools > Open Qt Project File (.pro)* and choose your _.pro_ file.\n\nRight now, your project is configured.\n\n== Create the configuration file\n\ninclude::_configuration_file.adoc[]\n\nExamples of such configuration files are available in the samples directory that is provided with the SolAR installation.\n\nIf you need to use new modules please refer to the > section, and if you need more third parties, please refer to the > section.\n\n== Implement your pipeline\n\nThis section describes how to assemble different components to build a vision pipeline.\nFirst as already mentioned in the previous sections, it is supposed that the required components have been identified. And consequently, a configuration file, a dependencies file and a project file have been created.\n\n=== Main template of a standalone pipeline\n\nTo create a standalone {cpp} pipeline, you can start by replacing the main.cpp code with the following one:\n\n.main.cpp\n[source, cpp]\n----\n///**\n * Add your header with the copyright and license information concerning your pipeline\n */\n\n// Common headers // \n#include \"xpcf/xpcf.h\"\n#include \"core/Log.h\"\n\n// ADD HERE: Module traits headers. #include \"SolARModuleOpencv_traits.h\"\n// \n\n// ADD HERE: Component interfaces header. e.g. #include \"api/input/devices/ICamera.h\"\n// \n\n\n// Namespaces // \nusing namespace SolAR;\nusing namespace SolAR::datastructure;\nusing namespace SolAR::api;\n\nnamespace xpcf  = org::bcom::xpcf;\n\n// Main function\nint main(int argc, char *argv[])\n{\n\n#if NDEBUG // \n    boost::log::core::get()->set_logging_enabled(false);\n#endif\n    LOG_ADD_LOG_TO_CONSOLE(); // \n\n// Instantiate component manager and load the pipeline configuration file // \n    SRef xpcfComponentManager = xpcf::getComponentManagerInstance();\n    if(xpcfComponentManager->load(\"MyStandalonePipelineConfiguration.xml\")!=org::bcom::xpcf::_SUCCESS)\n    {\n        LOG_ERROR(\"Failed to load the configuration file MyStandalonePipelineConfiguration.xml\")\n        return -1;\n    }\n\n// ADD HERE: instantiate concrete components and bind them to abstract component interfaces\n    // e.g. SRef camera = xpcfComponentManager->resolve();\n    // \n\n// ADD HERE: Declare here the data structures used to connect components\n    // \n\n// ADD HERE: The pipeline initialization\n    // \n\n// ADD HERE: The pipeline processing\n    while (true)\n    {\n      // \n    }\n\n    return 0;\n}\n----\n [white]#The _xpcf_ header is required to instantiate components. _log_ header is recomended if you want to log your pipeline.#\n [white]#Add the traits header files of the modules used by the pipeline.#\n [white]#Add the component interface header files of the components used by the pipeline.#\n [white]#Add SolAR and XPCF namespaces directives to shorten the calls to SolAR api and datastructures.#\n [white]#Add this line to remove irrelevant logs in release mode.#\n [white]#Add this line to push logs in the console. You can also push logs to a log file by using the macro _LOG_ADD_TO_FILE(\"path/logfilename.log\", \"r\")_.#\n [white]#Create an instance of an XPCF ComponentManager and use it to load the configuration file of your standalone pipeline.#\n [white]#Instantiate concrete components embedded into modules thanks to the XCPF Component Manager. The implementation of the component is automatically resolved according to the factory field defined in your configuration file. Here, an OpenCV camera will be instantiated if you request a component of type ICamera. Thanks to that, swapping a component by another one will just consists of editing your configuration file.  More details are given in the next section >#.\n [white]#Declare all the data structures used to exchange data between components. Have a look to the data structures defined in the SolARFramework in the > section.#\n [white]#if required, add the code to initialize your pipeline (e.g. start a camera, load a reference image, etc.).#\n [white]#Create the loop of your pipeline by calling the different processing functions of your components with data structure as input and/or output attributes. More details on how to call a function of a component are given in the next section >.#\n\n=== Instantiate a component [[InstantiateComponent]].\n\nThanks to XPCF, instantiation of a component is very easy and this operation is done at run-time. The configuration of the components will be initialized with values declared in the configuration file.\nThe syntax is the following for e.g. a component that display an image in a window:\n\n[code, cpp]\n----\nSRef camera = xpcfComponentManager->resolve();\n----\nAs you have only one implementation of a _IImageViewer_ in your configuration file (defined in the OpenCV module), it will be instantiate automatically.\n\nIf you want to instantiate several instance of the same component but with different configurations, in the configuration file fill in the name attribute for each configuration with a specific value (i.e. \"Configuration1\"), and call the _create_ method to instantiate the component with the corresponding configuration name (soon available for the _resolve_ method):\n\n[code, cpp]\n----\nSRef camera2 = xpcfComponentManager->create(\"Configuration1\")->bindTo();\n----\n\nIf you want to use several implementations of the same component in your pipeline, you can define in your configuration file different binding with corresponding names.\nYou can then ask to instantiate a dedicated component implementation thanks to this binding name:\n[code, cpp]\n----\nSRef videoAsCamera = xpcfComponentManager->resolve(\"VideoAsCamera\");\n----\n\n=== Use a component.\n\nOnce a component is created, any public function  described in its API can be used to build your pipeline.\nFor instance :\n```\nif (viewerConfImage->display(image) == FrameworkReturnCode::_STOP )\n```\n\n=== Pipeline sample\n\nWe will present next the implementation of the simplest pipeline that consists in capturing an image from a camera and display it in a window. For this implementation, we will need only one module: _SolARModuleOpenCV_.\n\n- as the example relies on SolARModuleOpencv, include the module traits\n```\n#include \"SolARModuleOpencv_traits.h\"\n```\n- as the example contains components that implement virtual interfaces, include the corresponding header files\n```\n#include \"api/image/IImageLoader.h\"\n#include \"api/display/IImageViewer.h\"\n```\n\n- as the modules/components to be used are listed in a configuration file (yml), don't forget to load it via xpcf :\n```\nxpcfComponentManager->load(\"conf_ImageLoader.xml\")\n```\n\nHere the full sample code for this standalone pipeline:\n\n\n[source,c]\n----\n///**\n * Add your header with the copyright and license information concerning your pipeline\n */\n\n// Common headers\n#include \"xpcf/xpcf.h\"\n#include \"core/Log.h\"\n\n// Module traits headers. #include \"SolARModuleOpencv_traits.h\"\n#include \"SolARModuleOpencv_traits.h\" // \n\n// Component interfaces header. e.g. #include \"api/image/IImageLoader.h\"\n#include \"api/input/devices/ICamera.h\" // \n#include \"api/display/IImageViewer.h\"\n\n// Namespaces\nusing namespace SolAR;\nusing namespace SolAR::datastructure;\nusing namespace SolAR::api;\n\nnamespace xpcf  = org::bcom::xpcf;\n\n// Main function\nint main(int argc, char *argv[])\n{\n\n#if NDEBUG\n    boost::log::core::get()->set_logging_enabled(false);\n#endif\n    LOG_ADD_LOG_TO_CONSOLE();\n\n// Instantiate component manager and load the pipeline configuration file\n    SRef xpcfComponentManager = xpcf::getComponentManagerInstance();\n    if(xpcfComponentManager->load(\"MyStandalonePipelineConfiguration.xml\")!=org::bcom::xpcf::_SUCCESS)\n    {\n        LOG_ERROR(\"Failed to load the configuration file MyStandalonePipelineConfiguration.xml\")\n        return -1;\n    }\n\n    // declare and instantiate components // \n    auto camera = xpcfComponentManager->resolve();\n    auto imageViewer = xpcfComponentManager->resolve();\n\n    if (!camera || !imageViewer)\n    {\n        LOG_ERROR(\"One or more component creations have failed\");\n        return -1;\n    }\n\n// Declare here the data structures used to connect components\n    SRef image; // \n\n// The pipeline initialization\n\n    // start the camera // \n    if (camera->start() != FrameworkReturnCode::_SUCCESS)\n    {\n        LOG_ERROR (\"Camera cannot start\");\n        return -1;\n    }\n\n// The pipeline processing // \n    while (true)\n    {\n        if(camera->getNextImage(image)==SolAR::FrameworkReturnCode::_ERROR_)\n            break;\n        if (imageViewer->display(image) == FrameworkReturnCode::_STOP )\n            break;\n     }\n    return 0;\n}\n----\n [white]#As the example relies on _SolARModuleOpencv_, we include the corresponding module traits header file.#\n [white]#As the example assemble two components, a camera and an image viewer, we include the corresponding component interface header files.#\n [white]#We instantiate our two components based on openCV implementations and we bind them to their abstract component interfaces.#\n [white]#We declare a shared reference of a SolARImage that will be used to pass the image captured by the camera to the image viewer.#\n [white]#We initialize the pipeline by starting the camera. In our configuration file, you will find for the camera first an ID corresponding to the camera you want to start, and secondly a path to an yml camera description file defining its intrinsic parameters. This file can be generated by calibrating the camera (see > section for more information).#\n [white]#Finally, we implement the core of the pipeline by capturing the current image from the camera, and by passing this image to the image viewer.#\n\nIMPORTANT: Don't forget to re-run qmake before building your pipeline for QT Creator and re-import _.pro_ file for Visual Studio.\n\nAs there is no generic way to implement a pipeline, we encourage the readers to take a look at the many examples provided by SolAR in the Samples directory that comes with the installation of SolAR.\nFor each sample, you will find a configuration file, a dependencies file and a project file to help you to build your own pipeline together with sources codes.\n",
    id: 31
  });
  

index.add({
    title: "Tags",
    content: "Tags\n\n{% capture site_tags %}{% for tag in site.tags %}{{ tag | first }}{% unless forloop.last %},{% endunless %}{% endfor %}{% endcapture %}\n\n\n{% assign tag_words = site_tags | split:',' | sort %}\n\n\n\n\n\n  {% for item in (0..site.tags.size) %}{% unless forloop.last %}\n    {% capture this_word %}{{ tag_words[item] }}{% endcapture %}\n    \n      {{ this_word }}\n        ({{ site.tags[this_word].size }})\n      \n    \n  {% endunless %}{% endfor %}\n\n\n\n\n  {% for item in (0..site.tags.size) %}{% unless forloop.last %}\n    {% capture this_word %}{{ tag_words[item] }}{% endcapture %}\n    {{ this_word }}\n    {% for post in site.tags[this_word] %}{% if post.title != null %}\n      \n        \n          {{ post.title }}\n        \n        \n          {{ post.date | date_to_string }}\n        \n      \n      \n    {% endif %}{% endfor %}\n  {% endunless %}{% endfor %}\n\n",
    id: 32
  });
  

index.add({
    title: "module tests",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: module tests\n:page-description: module tests\n:page-layout: default\n:page-category: create\n:page-liquid:\n:toc:\n\n== Tests\n\n== Tests\n\nDefine unit tests, based on boost framework .\nYou can know more about boost with this link : http://www.boost.org/[http://www.boost.org,role=\"external\", window=\"_blank\"]\n\nYour Unit tests for a specific component, should be placed in the component directory/unittest.\nIf you have used the SolARComponent template, this directory should be already there.\n\nimage::images\\400px-Unittestdirectory.png[Unit test directory]\n\n* Open \\{yourcomponent}/unittest/\\{yourcomponent}unittest.pro\n\n* You have to describe your unit tests in the file  \\{yourcomponent}unittest.cpp\n\nFor example\n\n[source,cpp]\n----\n#define\nBOOST_TEST_MODULE \\{Yourcomponent}UnitTest\n\n#include  \n#BOOST_AUTO_TEST_CASE(TestLoadImage) \n{ // test execution instructions\n}\n----\n\n [white]#Please note your code contains include of boost#\n [white]#You have to define the *name* of your test thanks to the boost macro \"BOOST_AUTO_TEST_CASE\"#.\n\nIn this example , the definition of the test case \"TestLoadImage\" for your component.\n\nIt means, that when you will execute the unit test, it will executes this test \"TestLoadImage\" following the instructions in this declaration.\nYou can define several test cases.\n\nInside your test, please write a kind of demo main function, but where you check results of your component function thanks to macro BOOST CHECK and/or BOOST_TEST.\n\nYou will find easily information about BOOST macro on Internet http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/index.html [boost.org information,role=\"external\", window=\"_blank\"] .\n\nNOTE: There is no \"main\" function, as it is automatically generated by boost (used in unit tests).\n\n* Please ensure that it contains sufficient tests cases to verify your code is OK (normal case, error cases).\n\nExample here : // Case normal, with an existing image file.\n\nWARNING: remplacer ici par le nouveau code source SolAR\n[source,cpp]\n----\nBOOST_AUTO_TEST_CASE(TestLoadImage)\n{ // To simplify this example test, let's suppose we'll test 'float'.\n // Some test are stupid, but all should pass.\n int result= 0;\n std::shared_ptr myArgoImage0 = getArgoImageInstance();\n\n....\nBOOST_CHECK( myArgoImage0 !=  NULL);\n....\n\n// getArgoImageInstance should not return a null pointer result\n\nmyArgoImage0->LoadImage(\"../test.jpg\");\nBOOST_TEST( result= = 0,\"ARGO ERROR: Load Image should return 0\");\n// As the image indicated exists, loadImage should return 0, as a normal case\n\n}\n\nBOOST_AUTO_TEST_CASE(TestLoadImageInexistante)\n{\n// Some test are stupid, but all should pass.\nint result= 0; std::shared_ptr\nmyArgoImage0 =  getArgoImageInstance();\n\n....\nBOOST_TEST(( myArgoImage0 !=  NULL),&quot;ARGO ERROR: ArgoImage should not return null pointer&quot;);\n\nresult=  myArgoImage0-&gt;LoadImage(&quot;../test2.jpg&quot;);\nBOOST_TEST( result= = -1,&quot;ARGO ERROR: Load Image should return -1&quot;);\n....\n\n// As the image indicated does not exist, loadImage should return -1, an error\n\n }\n----\n",
    id: 33
  });
  

index.add({
    title: null,
    content: ":page-layout: _auto\n\n:showtitle:\n:page-title: third parties packaging\n:page-category: assemble\n:page-description: third parties packaging\n:page-liquid:\n:page-layout: default\n:toc:\n\n== Third party packaging\n\n== Package your third parties [[package_your_third_parties, Package your third parties]]\nThe SolAR framework is using the meta dependencies management tool https://github.com/b-com-software-basis/remaken[Remaken] supporting https://conan.io/[Conan], https://github.com/microsoft/vcpkg[VCPKG] and its native C++ packaging structure based on https://www.freedesktop.org/wiki/Software/pkg-config/[pkg-config] description files. +\n\nRemaken uses a _packagedependencies.txt_ file defining all dependencies of your project (more information in the https://github.com/b-com-software-basis/remaken[documentation of remaken]). This file will be interpreted by the QMake build script tools used by the SolAR framework. Thus,  by maintaining a simple dependency file describing the third parties used by your project, you will be able to download the dependencies, link and build you project, and install and deploy your solution with all its dependencies in a very simple way.\n\nLet's describe now how to package the third parties required by your module in order to be compliant with the dependency manager and the build and install pipeline used by SolAR. Two solutions are presented next: The Remaken native solution and Conan.\n\n=== Remaken native solution\nTo create your package, you have to create the following folder structure:\n\n-DependencyName +\n--DependencyVersion (X.X.X) +\n---interfaces +\n----_here your header files_ +\n---lib +\n----architecture (x86_64, arm64, ...) +\n-----mode (shared or static) +\n------release +\n-------_your libraries here in release mode_ +\n------debug +\n-------_your libraries here in debug mode_ +\n---bcom-DependencyName.pc +\n---packageDependencies.txt (if your Dependency requires third-parties) +\n---DependencyName_remakeninfo.txt +\n\n==== bcom-DependencyName.pc\nThis file is used by pkg-config to provide the necessary details for compilng and linking a program to a library.\n\nIf this file is not already provided with your third party, you will have to create it:\n\n.bcom-DependencyName.pc\n[source]\n----\nlibname=DependencyName\nprefix=/usr/local\nexec_prefix=${prefix}\nincludedir=${prefix}/include\nlibdir=${exec_prefix}/lib\n\nName: DependencyName\nDescription: The DependencyName library\nVersion: 1.0.0\nRequires:\nLibs: -L${libdir} -l${libname}\nLibs.private: ${libdir}/${pfx}${libname}.${lext}\nCflags: -I${includedir}\n----\n\nFor more information concerning the syntax of this pkg-config file, you can take a look to the https://people.freedesktop.org/~dbn/pkg-config-guide.html[pkg-config guide].\n\n==== packageDependencies.txt\n\nRemaken and the SolAR build pipeline support the recursive dependency download, link, and installation. But in order to do so, your package must inform its own dependencies in the _packageDependencies.txt_.\nTo know how to add a sub-dependency to your dependency, take a look to the https://github.com/b-com-software-basis/remaken[Remaken documentation] on github, or check the numerous samples of _packagedependencies.txt_ available in the SolAR framework.\n\n==== DependencyName_remakeninfo.txt\nThis file is specific to remaken, and define the platform, the C++ version and the runtime version used to build your dependency. This file is similar to the _conaninfo.txt_ used by conan. \n\n.DependencyName_remakeninfo.txt\n----\nplatform=win-cl-14.1\ncppstd=17\nruntime=dynamicCRT\n----\n\n==== Artifact Packager\nWhen the previous files, your interfaces and you binaries are ready and well-placed in the folder structure detailed above, you can package the dependency by using the tool https://github.com/SolarFramework/Tools/releases/tag/ArtifactPackager[ArtifactPackager].\n\nJust run the artifact packager at the root folder of your package, and it will automatically create two folders, one for the debug version and the other one for the release version, each of them containing a zip file. The name format of the created files includes the name of your dependency, its version, the supported architecture, its build mode (shared or static) as well as its configuration (debug or release). This format of package name must be respected and will be used by remaken to find the dependency required for a requested development environment.  \n\n==== Share your package online\n\nIn order for Remaken to find the package corresponding to the requested dependency, with the good version, for the good architecture (x86_64 or arm64), mode (share or static) and configuration (debug or release), you have to respect the following  formatting rules concerning the URL to download your package: _URL_root/DependencyName/version/platform/package_name.zip_\n\nWhere:\n\n* *URL_root* is the URL where you host your packages. For example, for the SolAR project, most of the dependencies are stored in the releases space of the _binaries_ repository with the following URL: https://github/SolarFramework/binaries/releases/download. This is the URL that is entered in the _packagedependencies.txt_ file.\n* *DependencyName* is the name of your dependency (tinyXML, OpenCV, Ceres, G2O, etc.).\n* *version* with the X.X.X format.\n* *platform* win, linux, android, etc.\n* *package_name* the file name of the package created by the Artifact Packager.\n\nTIP: On GitHub, when a new release or a new dependency is published, we respect for each release the following tag in order to respect this previous URL format: _DependencyName/version/platform_. \n\n=== Conan\n\nThird party packaging can quickly become tedious, especially when source package manager such as Conan already provide you a solution to download ready-to-use packages for a large range of popular third parties hosted on public repositories (https://bintray.com/conan/conan-center[Conan center], https://bintray.com/bincrafters/public-conan[Bincrafters]).\n\nTo add your Conan package to your solution using Remaken, you can take a look at the https://github.com/b-com-software-basis/remaken[Remaken documentation]. \n\n",
    id: 34
  });
  

index.add({
    title: "tools",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: tools\n:page-description: tools\n:page-layout: default\n:page-category: use\n:page-liquid:\n:toc:\n:toclevels: 1\n\n== Tools\n\n\n== Camera Calibration [[CameraCalibration]]\n\n=== Introduction\n\nSolAR provides a program based on  https://docs.opencv.org/2.4/doc/tutorials/calib3d/camera_calibration/camera_calibration.html[\"OpenCV\",role=\"external\", window=\"_blank\"] that can be used to calibrate your camera. This program is available in the SolARModuleOpenCV repository. A chessboard image (chessboard.png) and a input configuration file are provided.\n\nThis tutorial is a simplified version of the one provided by OpenCV,  feel free to visit OpenCV website to get details on the actual implementation.\n\nThe calibration process uses a chessboard. You can print the following one:\n\nimage::..\\use\\images\\chessboard.png[chessboard,400,400, align=\"center\"]\n\n===  steps\n\n* Download the zip file with the CameraCalibration executable according to your operating system https://github.com/SolarFramework/binaries/releases/tag/Calibration0.3[\"exec\",role=\"external\", window=\"_blank\"]\n\n* Plug your camera device\n\n* Run the program SolARCameraCalibrationOpenCV.exe\n\nBy default, the camera Id is supposed to be 0 and this is correct most of the time. But if you have several cameras plugged to your computer, you can launch your CameraCalibration execution file with the Id of your camera in the parameters:\n\n....\nSolARCameraCalibrationOpenCV.exe 1\n....\n\nWhen launch, you will visualize the following window:\n\nimage::images/CameraCalibration/run.jpg[]\n\n* Press the 'g' key to start the process.\n\nA number of positive detections (default = 10) will be taken with a minimum period of time between two detections (default value = 2 seconds). The will be further explained in the last paragraph : *input/output files*.\nA positive detection is when the chessboard is correctly identified. This is illustrated with a frozen picture displaying corners and lines :\n\nimage::images/CameraCalibration/detect.jpg[]\n\nPlease, notice the bottom-right counter that indicates the number of positive detections so far.\n\nWhen all the positive detections are obtained, the calibration is performed and the process is completed, then a bottom-right message indicates \"Calibrated\" :\n\nimage::images/CameraCalibration/completed.jpg[]\n\n* Press [Esc] to close the camera view and to exit the program.\n\nAn output calibration file has been generated :\n\nimage::images/CameraCalibration/outFile.jpg[]\n\nThis file can be used directly in SolARModuleOpenCV tests and samples if a calibration file is required.\n\n=== Input/output files\n\nThe input/output file names are hard coded in the code.\n\nimage::images/CameraCalibration/fileNames.jpg[]\n\nThe input file is calibration_config.yml. An example is given which is described below :\n\n****************************\nINPUT\n****************************\n----\ncalibration_config.yml content :\n# the number of inner corners on board width\nchessboard_width: 9\n# the number of inner corners on board height\nchessboard_height: 6\n# square size in some user-defined units\nsquare_size: 0.026\n#fix aspect ratio (fx/fy)\napsect_ration: 1\n# number of frames to calibrate the camera : 10 is advised for a high calibration quality, you can put less if you are not so exigent\nnb_frames: 10\n# OpenCV Flags for camera calibration\nflags: 0\n# delay between each frame in milliseconds : 2 is good to let you enough time to move your camera and focus on the chessboard.\ndelay: 2000\n----\n\n\nThe output file is camera_calibration.yml. It contains the result of the calibration and the format is described below :\n****************************\nOUTPUT\n****************************\n\n----\nThis program generates a file camera_calibration.yml.\nCheck the file date, to be sure that it has been generated when you run the SolARCameraCalibration.\nThe data in this file define the calibration parameters of your camera, and will hemp for computer vision and especially pose estimation.\n\ncalibration_time: \"Wed Dec  6 14:02:31 2017\"\nimage_width: 640\nimage_height: 480\nboard_width: 9\nboard_height: 6\nsquare_size: 2.6000000536441803e-02\nflags: 0\ncamera_matrix: !!opencv-matrix\n   rows: 3\n   cols: 3\n   dt: d\n   data: [ 6.2358844756875726e+02, 0., 3.1296501379528701e+02, 0.,\n       6.2510924611650637e+02, 2.6595453191051286e+02, 0., 0., 1. ]\ndistortion_coefficients: !!opencv-matrix\n   rows: 5\n   cols: 1\n   dt: d\n   data: [ 5.0406145631272294e-03, -7.3194070034412229e-01,\n       8.8401137738982200e-03, -4.1912068994392751e-03,\n       2.7609935737342024e+00 ]\n----\n\n=== Video\nThis calibration requires that the chessboard is detected (positive detections) with, as far as possible, different poses of the camera. This is illustrated in the following video.\n\nvideo::../videos/CameraCalibration/CameraCalibration.mp4[width=640px, options=\"\"]\n",
    id: 35
  });
  

index.add({
    title: "unity",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: unity\n:page-description: unity\n:page-layout: default\n:page-category: use\n:page-liquid:\n:toc:\n:imagesdir: ../images\n\n== Unity [[Unity]]\n\n== Unity\n\nIntegrate SolAR pipelines in Unity Engine give opportunities to developers of\nAR services to get access to fully configurable SolAR based solutions to design AR applications. +\n\nSolAR has now a *Plugin for Unity*\n\n== Install Unity\n\n* Refer to https://store.unity.com/download?ref=personal\n* *Download the last version of Unity Hub*. The hub gives you the possibility to get access to different versions of Unity.\n* Our actual version (our test are based on)  is **2019.3.3f1**\n\n== Create a new Unity project\n\n* *New project*\n\n[#img-newunity]\nimage::../use/images/newunity.png[NewUnityProject,450,250,align=\"center\"]\n\n[.text-center]\n*Interface to create a new Unity project*\n\nWARNING: It's recommended that you use a 3D project set-up.\n\n* *Documentation*\n\n* All documentation for Unity is available here : https://docs.unity3d.com/2018.4/Documentation/Manual/\n\nNOTE: If you are a Unity newbie, check tutos online to help you.\n\n== SolAR Plugin for Unity\n\n=== For whom ?\n\nFor users who want to simply design AR services: Choose a pipeline, configure it in the inspector, and experience AR at run-time. +\n\n    Easy to use, understandable for everyone.\n\n=== Download\n\n* go on https://github.com/SolarFramework/SolARUnityPlugin/releases/tag/0.8.0\n* click on _SolARUnityPackage.unitypackage_\n\nThis package provides user with the minimum requirements to load a SolAR pipeline in Unity and include three pipelines (Fiducial marker, natural image marker, and a SLAM).\n\n=== Project Structure\n\nThe plugin version will add the following hierarchy in the Assets folder of your unity project:\n\n* `_Plugins_`: Host the binaries of the SolAR Framework, of the the pipeline manager that will handle the load of SolAR pipelines as well as the relative third parties (boost and xpcf).\n* `_SolAR_`\n** `_Editor_`\n** `_Objects_` : Some 3D objects to augment the scene.\n** `_Pipelines_`: The xml configuration files for the different SolAR pipelines. It is mandatory to put these pipeline configuration file in or under this folder.\n** `_Scenes_`: Sample scenes for simply testing the SolAR plugin.\n*** `_SolARPlugin_`: Scripts for Editor inspector dedicated to the -SolARPipelineLoader_, and a build script to deploy the solution on various platforms\n** `_Prefabs_`: All the prefabs required to simply use SolAR in Unity.\n** `_Materials_`: Materials used to display the video stream of the camera in the background.\n** `_Scripts_`\n*** `_SolARPlugin_`: SolARPipelineLoader script\n*** `_Swig_`\n**** `_SolARPlugin_`: The c# scripts required by the _SolARPipelineLoader_ automatically generated from SolAR C++ classes thanks to SWIG.\n** `_Shaders_`: Shaders used to display the video stream of the camera in the background.\n* `_StreamingAssets_`\n*** `_CameraCalibration_`: Some camera calibration files used by the pipelines handling their own camera.\n*** `_Markers_`: files describing the markers. You can edit these files to provide the exact size of the markers defined in meters, or create them to add new markers. +\n\n=== How works the SolAR Plugin for Unity ?\n\nThe SolAR plugin for Unity is a simple interface to load any SolAR pipelines assembled by the SolAR pipeline assemblers and use them to design AR services with Unity. +\n +\nTo load a SolAR pipeline in Unity, simply drag and drop the _SolARPipelineLoader_ prefab (in SolAR/Prefabs/novice) in your scene hierarchy. The _SolARPipelineLoader_ has the following parameters:\n\n* *Camera*: is the virtual camera whose position and orientation will be automatically updated at runtime according to the camera pose computed by the SolAR pipeline.\n* *Use Unity Webcam*: Check it if you want to replace the camera used by the pipeline by a Unity camera. If checked, you will be able to select a camera among those available on your computer. For a better experience, you can set the intrinsic parameters of the camera. For that, you will need to calibrate it (see >).\n* *Custom_Canvas*: For video see-through AR, the system has to display the video stream of the camera on background. If unchecked, a Canvas with the video stream of the selected camera will be automatically created when the application will start. If you want to manage yor canvas by yourself, you can check this option and drag and drop your canvas and its material.\n* *Select Pipeline Folder*: A button to select the folder where the available SolAR pipelines are stored in your Unity project. These pipelines must be stored anywhere under the folder _Assets/SolAR/Pipelines/_.\n\nSet your _SolARPipelineLoader_ by dragging and dropping your main camera from your scene hierarchy to the _Camera_ parameter in the _SolARPipelineLoader_ inspector. +\n\nThen you can put any object in your scene hierarchy to visualize it in augmentation (you can drag and drop the SolAR can available in the SolAR objects). The camera will automatically move relatively to the coordinate system of your marker (positionned in the center of the marker, x-axis pointing to the left, y-axis pointing to the top, z-axis pointing backward), so place your object in (0,0,0) if you want it to be positionned in the center of your marker. +\n\nIMPORTANT: For each object with a renderer, add the TAG _SolARObject_ to make it disappear when the pose provided by the pipeline is wrong.\n +\n\n=== Test SolAR pipelines\n\nSimply load the sample scene _SolAR/Scenes/NoviceVersion_.\n\nNow you can choose a SolAR pipeline among the fiducial, the natural image or the SLAM:\n\n* Select the _SolARPipelineLoader_ object in your scene hierachy.\n* Select the _PipelineFiducialMarker_ in the drop-down menu under the button _Select Pipelines Folder_.\n\nYou will see a list of parameters relative to the different components of the selected pipeline. A tooltip provides user with information relative to each parameter when he move the pointer over the parameter (only if the configuration file of the pipeline defines descriptions for the configuration parameters).\n\nFinally, you can print the following fiducial marker, play the application, and present the marker in front of the camera. That's it, you should visualize the SolAR robot appearing on your fiducial marker.\n\nimage::../use/images/FiducialMarker.gif[FiducialMarker,450,250,align=\"center\"]\n\nNow, stop the application, select the _SolARPipelineLoader_ object in your scene hierarchy, and select the _PipelineNaturalImageMarker_. Print the following image marker, and play the application. Changing pipeline is as simple as that ! +\n\nimage::../use/images/graf1.png[NaturalImageMarker,450,250,align=\"center\"]\n\nFinally, you can test the SLAM pipeline. To initialize the SLAM, you will need to target the fiducial maker with your camera. When it is done, the SolAR robot should appear. Here, as the SLAM pipeline build a 3D map to localize your camera, it does not matter if the fiducial marker does not remain in its field of view. \n\nWARNING: For a better AR experience, it is preferable to enter the actual size of the marker in meters. You can do it by editing the marker files available in the folder _Assets/StreamingAssets/Markers/_. By editing these files, you will also be able to change the fiducial marker pattern or the image of reference for the natural image marker pipeline.\n\n== Full SolAR C# wrapper (deprecated)\n\n=== For whom ?\n\nFor vision expert who want ot directly assemble SolAR pipeline in Unity thanks to a full C# wrapping of SolAR.\n\n* go on https://github.com/SolarFramework/SolARUnityPlugin/releases\n* click on _Assets_\n* click on _SolARPlugin_win.unitypackage_\n\n=== Project Structure\nThe unitypackage adds our project’s hierarchy in your Unity project. +\n\n\n* `_Objects_` : our 3D object\n* `_Plugins_` : our DLLs from SolAR\n* `_Scenes_` : Expertversion scene\n* `_SolAR_`\n*** `_Editor_`\n**** `_SolARPluginExpert_' : own Editor inspector for our PipelineLoader\n*** `_Materials_`\n*** `_Pipelines_`\n*** `_Scripts_`\n**** `_SolARPluginExpert_` : all our C# scripts\n***** `_Samples_` : pipelines examples\n*** `_Shaders_`\n*** `_Swig_`\n**** `_SolARPluginExpert_` : full wrapping of SolAR\n* `_StreamingAssets_`\n*** `_CameraCalibration_` : `_design for our cameras_`\n*** `_Configuration_` : xml files for our pipelines\n*** `_Markers_` : files describing our markers. Print our markers or make yours.\n\n[.text-center]\n**Our Scene, our project's folders and some explanations*#\n[#img-expertEditor]\nimage::../use/images/expertEditor.png[NewbieScene,800,300, align=\"center\"]\n\n=== Make your own pipelines\n\nWARNING: You have to be in Unity Editor with Expert version package imported.\n\nNOTE: We give you pipelines examples in Scripts/SolARPluginExpert/Samples +\n\n*To create a new pipeline :* +\n +\n\n* Create a new script C* \"MyPipeline.cs\"\n* Add *_using properties_* in your file that give you components available. (see example code)\n\n using SolAR.Datasctructure  //our Datasctructure\n using XPCF.Api              //XPCF is the heart of SolAR\n\n* Put your class in *_namespace_* *SolAR.Samples*\n\n namespace SolAR.SAmples {\n  class MyPipeline\n }\n\n* Your class have to base upon AbstractPipeline (C# interface)\n\n class MyPipeline : AbstractPipeline\n\n** This inheritance means you must use different methods.\n\n*** *A constructor* taking a IComponentManager as parameter. +\n    This constructor is the place where you instantiate your components.\n\n*** *GetMarkerSize()* method to define your marker size and use it at the basis of your pipeline.\n\n*** *SetCameraParameters(...)* method to give intrinsic and distorsion parameters to certain components.\n\n*** *Proceed* function. Core function of a pipeline where you have to connect components to each others.\n\nNOTE: Components have to be declare with *_readonly_* property\n\nWARNING: You have to create a new XML files to fix your pipeline configuration. +\n         Examples in StreamingAssets/Configuration.\n",
    id: 36
  });
  

index.add({
    title: "unity pipeline",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: unity pipeline\n:page-description: unity pipeline\n:page-layout: default\n:page-category: assemble\n:page-liquid:\n:toc:\n\n== Assemble {cpp} pipeline for Unity\n\n== What is a {cpp} pipeline for Unity ?\nA {cpp} pipeline is a shared library embedding an implementation of the IPipeline interface defined by the SolAR framework. Thus, this pipeline can be loaded at run-time and run by any third party application such as a {cpp} application or by Unity. To provide configuration capabilities to a pipeline, it is considered by SolAR as a component embedded in a module. For this reason, readers are encouraged to have a look at the > section.\n\nWhile SolAR is dedicated to computer vision pipelines, for now, the pipeline interface is only dedicated to pose estimation pipeline. To be more specific, the pipelines built to be used in Unity are pipelines that take on hand camera frames and that deliver on the other hand camera pose estimation.\n\nNew pipeline interfaces will be soon added for other vision task such as 3D reconstruction, object recognition, etc.\n\n== Initialize your pipeline step-by-step\n\n=== Create your pipeline project\n\n* *QT Creator*\n\nOpen QTCreator and create a new project (in File menu).\n\nimage::../assemble/images/WizardModule.png[App wizard QT,900,500,align=\"center\"]\n\nThen, set the name of your application (e.g. _MySolARPipeline_) that will use a SolAR pipeline, and its location.\n\nNext, define your build system with _qmake_. For the next step, choose your development kits. We recommend to use _MSVC 2017 64bit_ on Windows or _Clang_ on Linux.\n\nYour project is now created and the result is a _.pro_ file like following:\n\n.MyPipeline.pro\n----\n## remove Qt dependencies\nQT       -= core gui\nCONFIG -= qt\n\n## global defintions : target lib name, version\nTARGET = MyPipeline\nINSTALLSUBDIR = SolARBuild\nFRAMEWORK = $$TARGET\nVERSION=X.X.X #\n\nDEFINES += MYVERSION=$${VERSION}\nDEFINES += TEMPLATE_LIBRARY\nCONFIG += c++1z\n\ninclude(findremakenrules.pri) #\n\n\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += _NDEBUG=1\n    DEFINES += NDEBUG=1\n}\n\nDEPENDENCIESCONFIG = sharedlib recursive install #\n\n## Configuration for Visual Studio to install binaries and dependencies. Work also for QT Creator by replacing QMAKE_INSTALL\nPROJECTCONFIG = QTVS #\n\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude ($$shell_quote($$shell_path($${QMAKE_REMAKEN_RULES_ROOT}/templatelibconfig.pri)))  # Shell_quote & shell_path required for visual on windows\n\n\n\n## DEFINES FOR MSVC/INTEL C++ compilers\nmsvc {\nDEFINES += \"_BCOM_SHARED=__declspec(dllexport)\"\n}\n\nINCLUDEPATH += interfaces/\n\nHEADERS += interfaces/MyPipelineAPI.h \\\n\nSOURCES +=    src/MyPipeline_main.cpp \\\n              src/component.cpp\n\nunix:!android {\n    QMAKE_CXXFLAGS += -Wignored-qualifiers\n}\n\nmacx {\n    DEFINES += _MACOS_TARGET_\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CFLAGS += -mmacosx-version-min=10.7 -std=c11 #-x objective-c++\n    QMAKE_CXXFLAGS += -mmacosx-version-min=10.7 -std=c11 -std=c++11 -O3 -fPIC#-x objective-c++\n    QMAKE_LFLAGS += -mmacosx-version-min=10.7 -v -lstdc++\n    LIBS += -lstdc++ -lc -lpthread\n}\n\nwin32 {\n    LIBS += User32.Lib\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275\n}\n\nandroid {\n    ANDROID_ABIS=\"arm64-v8a\"\n}\n\nheader_files.path = $${PROJECTDEPLOYDIR}/interfaces\nheader_files.files = $$files($${PWD}/interfaces/*.h*)\n\nconfiguration_files.path = $${PROJECTDEPLOYDIR}/configuration\n#configuration_files.files = $$files($${PWD}/tests/TestMyPipeline/PipelineMyPipeline.xml)\n\nINSTALLS += header_files\nINSTALLS += xpcf_xml_files\nINSTALLS += configuration_files\n\nOTHER_FILES += \\\n    packagedependencies.txt\n\n#NOTE : Must be placed at the end of the .pro\ninclude ($$shell_quote($$shell_path($${QMAKE_REMAKEN_RULES_ROOT}/remaken_install_target.pri)))) # Shell_quote & shell_path required for visual on windows #\n----\n [white]#Set the version number of your pipeline,#\n [white]#This .pri file has been installed by the wizard. It will allow to find the remaken folder depending on the OS you are using.#\n [white]#The dependencies of your pipeline will be installed recursively. More details are available on the https://github.com/b-com-software-basis/builddefs-qmake/[builddefs-qmake] project on GitHub.#\n [white]#The installation of your pipeline will also work with Visual Studio. Warning, in QTCreator, this will replace the usual QMAKE_INSTALL.#\n [white]#Place at the end the .pri file to install your pipeline.#\n\n\n==== Visual Studio\n\nYou can also simply create your application with Visual Studio by using the _.pro_ file (see above for more details how to configure the _.pro_ file).\n\nMicrosoft Visual Studio provides a Qt Visual Studio Tools. This enables developers to import QT project files (.pro) into Visual Studio.\n\nInstall QT Visual Studio Tools: \n\n* In Visual Studio, select *Tools > Extensions and Updates > Online* to install and update QT Visual Studio Tools.\n\nImport the _.pro._ file into Visual Studio: \n\n* Select *Qt VS Tools > Open Qt Project File (.pro)* and choose your _.pro_ file. \n\nRight now, your project is configured.\n\n=== Select your dependencies\n\ninclude::_dependencies_file.adoc[]\n\n=== Create the configuration file [[PipelineConfigurationFile]]\n\ninclude::_configuration_file.adoc[]\n\n\n== Implement your pipeline\n\n=== Using QT Creator Wizard\n\nRefer to Create/Create_Component part.\nYou can create a Pipeline like a component using Qt creator wizard. This component has to inherit of IPiepline interface.\nThen, follow below instructions.\n\n=== IPipeline API\n\nA virtual class named IPipeline has been defined in SolAR framework and is located in  [aqua]#api/pipeline/IPipeline.h# . +\nAny SolAR pipeline should implement this class, that means that six methods are to be implemented in the corresponding source code :\n\n* *init*: Initialize the pipeline by providing a reference to the component manager loaded by the PipelineManager. You will have to instantiate all the components used by your pipeline and initialize by for instance starting the camera, initialize component with intrinsic parameter of the camera, etc.\n* *getCameraParameters*: Provide third party applications with the calibration parameters of the camera. Useful hen you want to set the parameter of the virtual camera with the ones from the real one.\n* *start*: Start the pipeline with a texture buffer that will be updated when a new frame will be processed and ready for display.\n* *stop*: Stop the pipeline.\n* *update*: A methode that provide the new pose of the camera.\n* *loadSourceImage*: If there is no camera in your pipeline, you can feed it with an external image (for instance, an image capture by the Unity web camera).\n\nA full description of these methods is available in the [aqua]#api/pipeline/IPipeline.h# file.\n\n=== Pipeline Template\n\nTo implement your pipeline, you have to fill in the header file _MyPipeline.h_ and the source file _MyPipeline.cpp_. Next, we provide you with templates for these to files.\n\n.MyPipeline.h\n[source, cpp]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n#ifndef MYPIPELINE_H\n#define MYPIPELINE_H\n\n// \n#if _WIN32\n#ifdef MyPipeline_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllexport)\n#else //MYPIPELINE_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllimport)\n#endif //MYPIPELINE_API_DLLEXPORT\n#else //_WIN32\n#define MYPIPELINE_EXPORT_API\n#endif //_WIN32\n\n// Mandatory include file // \n#include \"xpcf/core/traits.h\"\n#include \"xpcf/component/ConfigurableBase.h\"\n#include \"api/pipeline/IPipeline.h\"\n#include \"xpcf/threading/BaseTask.h\"\n\n// Add here the header file for the data structures required by your pipeline\n// e.g. #include \"datastructure/Image.h\"\n// \n\n// Add here the header file for the component interfaces required by your pipeline\n// e.g. #include \"api/input/devices/ICamera.h\"\n// \n\nnamespace SolAR { // \nusing namespace datastructure;\nusing namespace api;\nnamespace PIPELINES {\n\n/**\n * @class MyPipeline\n * @brief A short description of your pipeline\n */\n// \nclass MYPIPELINE_EXPORT_API MyPipeline : public org::bcom::xpcf::ConfigurableBase,\n    public api::pipeline::IPipeline\n{\npublic:\n    MyPipeline();\n    ~MyPipeline();\n\n    //// @brief Initialization of the pipeline\n    /// Initialize the pipeline by providing a reference to the component manager loaded by the PipelineManager.\n    /// @param[in] componentManager a shared reference to the component manager which has loaded the components and configuration in the pipleine manager\n    FrameworkReturnCode init(SRef xpcfComponentManager) override;\n\n    /// @brief Provide the camera parameters\n    /// @return the camera parameters (its resolution and its focal)\n    pipeline::CameraParameters getCameraParameters() override;\n\n    /// @brief Starts the pipeline and provides a texture buffer which will be updated when required.\n    /// @param[in] textureHandle a pointer to the texture buffer which will be updated at each call of the update method.\n    FrameworkReturnCode start(void* imageDataBuffer) override;\n\n    /// @brief Stop the pipeline.\n    FrameworkReturnCode stop() override;\n\n    /// @brief update the pipeline\n    /// Get the new pose and update the texture buffer with the image that has to be displayed\n    SinkReturnCode update(Transform3Df& pose) override;\n\n    /// @brief load the source image\n    SourceReturnCode loadSourceImage(void* sourceTextureHandle, int width, int height) override;\n\n    void unloadComponent () override final;\n\nprivate:\n  // Add here the declaration of the shared references on components required by your pipeline (e.g. SRef m_camera;)\n  // \n\n  // Threads // \n  bool pipelineLoop();\n  xpcf::DelegateTask* m_pipelineLoopTask = nullptr;\n\n  // optionally, add here some parameters of you rmodule that can be configured\n  // int m_myPipelineParameter; // \n};\n\n}\n}\n\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::PIPELINES::MyPipeline, // \n                             \"\",\n                             \"My pipeline\",\n                             \"A sample pipeline used for documentation\");\n\n#endif // MYPIPELINE_H\n----\n [white]#Add the required declarations to export the pipeline functions embedded in your shared library. Just replace in a case sensitive manner \"MyModule\" by the name of your module.#\n [white]#These include files are mandatory. They correspond to the xpcf traits file as here we declare the module traits directly in this file, to the XPCF configurableBase header file if you want to configure your pipeline through an external xml file, and to the SolAR IPipeline header file, as your pipeline implement this SolAR interface.#\n [white]#The header files of the SolAR data structures required to connect your components.#\n [white]#The header files of the SolAR component interfaces required by your pipeline.#\n [white]#SolAR and XPCF namespaces directives to shorten the calls to SolAR api and data structures.#\n [white]#Declare your pipeline class, and add the functions defined as abstract in the IPipeline interface.#\n [white]#Declaration of the components used by the pipeline (thanks to their abstract interfaces). We are using a shared reference of the components to ease their use in multi-threaded pipelines.#\n [white]#Declare a xpcf task and the function running the pipeline loop in a dedicated thread.#\n [white]#You can declare parameters for the pipeline. Some of these parameters may be configurable.#\n [white]#Finally, add the trait of your pipeline. To generate an UUID, you can use a https://www.uuidgenerator.net/[online UUID generator]#\n\n.MyPipeline.cpp\n[source, code]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n// Mandatory header file // \n#include \"xpcf/module/ModuleFactory.h\"\n#include \"core/Log.h\"\n\n// Header to your pipeline declaration // \n#include \"MyPipeline.h\"\n\nnamespace xpcf=org::bcom::xpcf;\n\n// Declaration of the module embedding MyPipeline // \nXPCF_DECLARE_MODULE(\"\", \"MyPipelineModule\", \"The module embedding MyPipeline\")\n\n// Add this function required by the XPCF component factory // \nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid& componentUUID,SRef& interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n    errCode = xpcf::tryCreateComponent(componentUUID,interfaceRef);\n\n    return errCode;\n}\n\n// Add the declaration of the component (here a pipeline) to XPCF // \nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::PIPELINES::MyPipeline)\nXPCF_END_COMPONENTS_DECLARATION\n\n// Macro used by the XPCF factory to define a component/pipeline // \nXPCF_DEFINE_FACTORY_CREATE_INSTANCE(SolAR::PIPELINES::MyPipeline)\n\nnamespace SolAR { // \nusing namespace datastructure;\nusing namespace api::pipeline;\nnamespace PIPELINES {\n\nMyPipeline::MyPipeline():ConfigurableBase(xpcf::toUUID())\n{\n   addInterface(this);\n   // Add here the declaration of the component implementation you want to inject in your interfaces\n   // e.g. declareInjectable(m_camera);\n   // If a sepcific named binding is needed \n   // e.g. declareInjectable(m_camera, \"VideoAsCamera\");\n   // \n   // Add here the mapping of your pipeline properties with your variables of your pipeline claa\n   // e.g. declareProperty(\"myPipelineProperty\", m_MyPipelineVariable); \n   // \n}\n\nMyPipeline::~MyPipeline()\n{\n\n}\n\nvoid MyPipeline::onInjected()\n{\n    // ADD HERE: Things to do when your pipline has been injected\n}\n\nxpcf::XPCFErrorCode MyPipeline::OnConfigured()\n{\n  // ADD HERE: Things to do when the variables of your pipeline class have just been set according to the properties defined in your configuration file.\n}\n\nbool MyPipeline::pipelineLoop() //\n{\n  // ADD HERE: the code connecting the component of your pipeline\n\n  return true;\n}\n\nFrameworkReturnCode MyPipeline::init(SRef xpcfComponentManager)\n{\n  try {\n    // ADD HERE: Thinks to do to initialize your pipeline\n    //e.g. load a marker or set camera parameters for components requiring them.\n    // \n    \n  }\n  catch (xpcf::Exception e)\n  {\n     LOG_WARNING(\"One or more components cannot be created: {}\", e.what());\n     return FrameworkReturnCode::_ERROR_;\n  }\n\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nCameraParameters MyPipeline::getCameraParameters()\n{\n  CameraParameters camParam;\n  // ADD HERE the code to return camera parameters\n\n  return camParam;\n}\n\nSourceReturnCode MyPipeline::loadSourceImage(void* sourceTextureHandle, int width, int height)\n{\n   // ADD HERE the code to take external image as input of your pipeline\n\n   return SourceReturnCode::_NOT_IMPLEMENTED;\n}\n\n\nFrameworkReturnCode MyPipeline::start(void* imageDataBuffer)\n{\n  // ADD HERE the code to start your pipeline\n  // e.g. start the camera\n\n  // create and start a thread for the loop of the pipeline // \n  auto pipelineLoopThread = [this](){;pipelineLoop();};\n  m_pipelineLoopTask = new xpcf::DelegateTask(pipelineLoopThread);\n  m_pipelineLoopTask->start();\n\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nFrameworkReturnCode MyPipeline::stop()\n{\n  // ADD HERE the code to stop your pipeline\n  if (m_pipelineLoopTask != nullptr)\n    m_pipelineLoopTask->stop(); // \n  return FrameworkReturnCode::_SUCCESS;\n}\n\nSinkReturnCode MyPipeline::update(Transform3Df& pose)\n{\n  // ADD HERE the code to update the pose of the camera\n\n  return SinkReturnCode::_NOT_IMPLEMENTED;\n}\n\n}\n}\n----\n [white]#Required header file corresponding to the XPCF module factory.#\n [white]#Obviously, add the header file corresponding to your pipeline declaration.#\n [white]#Declare your module to XPCF. generate a UUID for your module by using an https://www.uuidgenerator.net/[online UUID generator].#\n [white]#Implement the method _XPCF_getComponent_ required by the XPCF factory to instantiate the componen t(here a pipeline).#\n [white]#Add your component/pipeline to XPCF.#\n [white]#Add the definition of your pipeline to the XPCF component factory.#\n [white]#Embed your pipeline in the _SolAR/PIPELINES_ namespace.#\n [white]#If you have declare the component interfaces required for your pipeline in its header file, you can map component implementatations on them. The choice of the component implementations to map on your interfaces will be solved at runtime according to what is described in your xml configuration file. By default, the resolution chooses the first component alias declared in the configuration file that fits your interface. If you have several components alias declared in your configuration file, you can force the choice by defining a specific binding. In your pipeline, if you need several instances of a component based on different implementations, you can name your binding and pass it to the _DeclareInjectable_ function. Do not forget to add _autoalias=true\" at the beginning of your xml configuration file if you want to automatically create aliases for all declared components based on their names.#  \n [white]#To set a variable of the pipeline class as configurable and map on it a property defined in the xml configuration file, you have to declare the property. Here, if an xml element with the name \"myPipelineProperty\" is specified in the configuration file, when exiting the constructor, its value will be set to the variable _m_myPipelineVariable_.#\n [white]#Implement the loop of the pipeline by connecting components. This loop will run in a dedicated thread.#\n [white]#If required, add the code to initialize your pipeline (e.g. load a reference image, initialize some component with the intrinsic parameters of the camera, etc.).#\n [white]#Start the pipeline loop thread when the start method is called.#\n [white]#Stop the pipeline loop thread when the stop method is called.#\n\n=== Pipeline sample\nWe will present next the implementation of the simplest pipeline that consists in capturing an image from a camera and make it available for a third party application. For this implementation, we will need only one module: _SolARModuleOpenCV_.\n\n.MyPipeline.h\n[source, cpp]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n#ifndef MYPIPELINE_H\n#define MYPIPELINE_H\n\n#if _WIN32\n#ifdef MyPipeline_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllexport)\n#else //MYPIPELINE_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllimport)\n#endif //MYPIPELINE_API_DLLEXPORT\n#else //_WIN32\n#define MYPIPELINE_EXPORT_API\n#endif //_WIN32\n\n// Mandatory include file\n#include \"xpcf/core/traits.h\"\n#include \"xpcf/component/ConfigurableBase.h\"\n#include \"api/pipeline/IPipeline.h\"\n\n// Add here the header file for the data structures required by your pipeline\n// e.g. #include \"datastructure/Image.h\"\n#include \"datastructure/Image.h\" // \n\n// Add here the header file for the component interfaces required by your pipeline\n// e.g. #include \"api/input/devices/ICamera.h\" // \n#include \"api/input/devices/ICamera.h\"\n#include \"api/sink/ISinkPoseImage.h\"\n#include \"api/source/ISourceImage.h\"\n\n\n\nnamespace SolAR {\nusing namespace datastructure;\nusing namespace api;\nnamespace PIPELINES {\n\n/**\n * @class MyPipeline\n * @brief A short description of your pipeline\n */\nclass MYPIPELINE_EXPORT_API MyPipeline : public org::bcom::xpcf::ConfigurableBase,\n    public api::pipeline::IPipeline\n{\npublic:\n    MyPipeline();\n    ~MyPipeline();\n\n    //// @brief Initialization of the pipeline\n    /// Initialize the pipeline by providing a reference to the component manager loaded by the PipelineManager.\n    /// @param[in] componentManager a shared reference to the component manager which has loaded the components and configuration in the pipleine manager\n    FrameworkReturnCode init(SRef xpcfComponentManager) override;\n\n    /// @brief Provide the camera parameters\n    /// @return the camera parameters (its resolution and its focal)\n    pipeline::CameraParameters getCameraParameters() override;\n\n    /// @brief Starts the pipeline and provides a texture buffer which will be updated when required.\n    /// @param[in] textureHandle a pointer to the texture buffer which will be updated at each call of the update method.\n    FrameworkReturnCode start(void* imageDataBuffer) override;\n\n    /// @brief Stop the pipeline.\n    FrameworkReturnCode stop() override;\n\n    /// @brief update the pipeline\n    /// Get the new pose and update the texture buffer with the image that has to be displayed\n    SinkReturnCode update(Transform3Df& pose) override;\n\n    /// @brief load the source image\n    SourceReturnCode loadSourceImage(void* sourceTextureHandle, int width, int height) override;\n\n    void unloadComponent () override final;\n\nprivate:\n  // Add here the declaration of the shared references on components required by your pipeline (e.g. SRef m_camera;)\n  SRef m_camera; // \n  SRef m_sink;\n  SRef m_source;\n\n  // Threads\n  bool pipelineLoop();\n  xpcf::DelegateTask* m_pipelineLoopTask = nullptr;\n\n  // optionally, add here some parameters of your module that can be configured\n  // int m_myPipelineParameter;\n\n  // Other attributes\n  bool m_externalInputImageMode = false; // \n};\n\n}\n}\n\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::PIPELINES::MyPipeline,\n                             \"855c83b7-f4ec-48ab-8e89-56018ea9e169\",\n                             \"My pipeline\",\n                             \"A sample pipeline used for documentation\");\n\n#endif // MYPIPELINE_H\n----\n [white]#include the header file of a SolAR image to connect the camera component to the sink component.#\n [white]#include the component interface headers for a camera component, a sink component and a source component. A sink component handles an output buffer feed by the pipeline a read by external third parties. Reciprocally, a source component handles an input buffer feeds by external third parties and used by the pipeline.#\n [white]#Declaration of the three components used by this pipeline, a camera, a sink component handling the pose and the output image, and a source component handling an input image.#\n [white]#Add an attribute to know if the pipeline use as input an image coming from a third party.#\n\n.MyPipeline.cpp\n[source, cpp]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n// Mandatory header file\n#include \"xpcf/module/ModuleFactory.h\"\n#include \"core/Log.h\"\n\n// Header to your pipeline declaration\n#include \"MyPipeline.h\"\n\nnamespace xpcf=org::bcom::xpcf;\n\n// Declaration of the module embedding MyPipeline\nXPCF_DECLARE_MODULE(\"855c83b7-f4ec-48ab-8e89-56018ea9e169\", \"MyPipelineModule\", \"The module embedding MyPipeline\")\n\n// Add this function required by the XPCF component factory\nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid& componentUUID,SRef& interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n    errCode = xpcf::tryCreateComponent(componentUUID,interfaceRef);\n\n    return errCode;\n}\n\n// Add the declaration of the component (here a pipeline) to XPCF\nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::PIPELINES::MyPipeline)\nXPCF_END_COMPONENTS_DECLARATION\n\n// Macro used by the XPCF factory to define a component/pipeline\nXPCF_DEFINE_FACTORY_CREATE_INSTANCE(SolAR::PIPELINES::MyPipeline)\n\nnamespace SolAR {\nusing namespace datastructure;\nusing namespace api::pipeline;\nnamespace PIPELINES {\n\nMyPipeline::MyPipeline():ConfigurableBase(xpcf::toUUID())\n{\n   addInterface(this);\n   // Add here the declaration of the component implementation you want to inject in your interfaces\n   // e.g. declareInjectable(m_camera);\n   // If a sepcific named binding is needed \n   // e.g. declareInjectable(m_camera, \"VideoAsCamera\");\n   // \n   DeclareInjectable(m_camera);\n   DeclareInjectable(m_sink);\n   DeclareInjectable(m_source);\n\n   // Add here the mapping of your pipeline properties with your variables of your pipeline claa\n   // e.g. declareProperty(\"myPipelineProperty\", m_MyPipelineVariable); \n\n}\n\nMyPipeline::~MyPipeline()\n{\n\n}\n\nvoid MyPipeline::onInjected()\n{\n    // ADD HERE: Things to do when your pipline has been injected\n}\n\nxpcf::XPCFErrorCode MyPipeline::OnConfigured()\n{\n  // ADD HERE: Things to do when the variables of your pipeline class have just been set according to the properties defined in your configuration file.\n}\n\nbool MyPipeline::pipelineLoop() //\n{\n  // ADD HERE: the code connecting the component of your pipeline\n  SRef image;\n\n  if (m_externalInputImageMode)\n  {\n    if (m_source->getNextImage(image) == SourceReturnCode::_NEW_IMAGE)\n      m_sink->set(image);\n  }\n  else\n  {\n    if (m_camera->getNextImage(image) == SolAR::FrameworkReturnCode::_ERROR_LOAD_IMAGE)\n      return false;\n    m_sink->set(image);\n  }\n  return true;\n}\n\nFrameworkReturnCode MyPipeline::init(SRef xpcfComponentManager)\n{\n  try {\n    // ADD HERE: Thinks to do to initialize your pipeline\n    //e.g. load a marker or set camera parameters for components requiring them.\n    \n  }\n  catch (xpcf::Exception e)\n  {\n     LOG_WARNING(\"One or more components cannot be created: {}\", e.what());\n     return FrameworkReturnCode::_ERROR_;\n  }\n\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nCameraParameters MyPipeline::getCameraParameters()\n{\n  CameraParameters camParam;\n  // ADD HERE the code to return camera parameters\n  if (m_camera) // \n    {\n        camParam  m_camera->getCameraParameters();\n    }\n  return camParam;\n}\n\nSourceReturnCode MyPipeline::loadSourceImage(void* sourceTextureHandle, int width, int height)\n{\n   // ADD HERE the code to take external image as input of your pipeline\n   m_externalInputImageMode = true; // \n   return m_source->setInputTexture((unsigned char *)sourceTextureHandle, width, height);\n}\n\n\nFrameworkReturnCode MyPipeline::start(void* imageDataBuffer)\n{\n  // ADD HERE the code to start your pipeline\n  m_sink->setImageBuffer((unsigned char*)imageDataBuffer); // \n\n  if (m_camera->start() != FrameworkReturnCode::_SUCCESS) // \n    return FrameworkReturnCode::_ERROR_;\n\n  // create and start a thread for the loop of the pipeline\n  auto pipelineLoopThread = [this](){;pipelineLoop();};\n  m_pipelineLoopTask = new xpcf::DelegateTask(pipelineLoopThread);\n  m_pipelineLoopTask->start();\n\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nFrameworkReturnCode MyPipeline::stop()\n{\n  // ADD HERE the code to stop your pipeline\n  if (m_pipelineLoopTask != nullptr)\n    m_pipelineLoopTask->stop();\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nSinkReturnCode MyPipeline::update(Transform3Df& pose)\n{\n  // ADD HERE the code to update the pose of the camera\n\n  return SinkReturnCode::_NOT_IMPLEMENTED;\n}\n\n}\n}\n----\n [white]#We declare the injection of the 3 components required for this pipeline.#\n [white]#Implementation of the pipeline loop. If an input image has been updated, we will access to it through the source component and we pass it to the sink component. If not, we read the last image captured by the camera and we pass it to the sink component.#\n [white]#A simple code to get camera parameters and return it.#\n [white]#Set the _m_externalInputImageMode_ to true to inform the pipeline that it run with external input images, and put the image in the buffer of the source component.#\n [white]#Set the image buffer for the sink component.#\n [white]#Start the camera.#\n\n== Export your pipeline for Unity\n\n=== General\n\nFirst of all, you must follow the installation instructions of Unity and of the SolAR plugin for unity available in the section >.\n\nThen, copy the shared binaries of your pipeline, of its modules and of the dependencies of its modules in the _Assets/Plugins_ folder of your Unity project.\n\nCopy the configuration file of your pipeline in the _Assets/SolAR/Pipelines_ folder of your Unity project. When copied, edit the configuration file and replace all module paths so they are relative to your Unity project (_./Assets/Plugins_).\n\nNow, in the Unity editor, you can select again your pipeline folder in the inspector of your SolARPipelineLoader, and select in the pipeline list your pipeline.\n\n\nIf you want to export your pipeline, create a new Unity package with:\n\n* The shared binaries stored in the Unity plugin folder relative to:\n** Your pipeline\n** The modules used by your pipeline\n** The third parties of the modules used by your pipeline\n* The pipleline configuration file stored under _Assets/SolAR/Pipelines/_.\n\n=== Unity Android Deployment [[UnityAndroidDeployment]]\n\nFor Unity platform we proceed to a change in the path of the pipeline configuration file to match applications public path. Your pipeline configuration will be available from the device and could be edited directly to manage its components, parameters, etc.\n\n==== Deployment details\n**/!\\ Only https://developer.android.com/ndk/guides/abis#arm64-v8a[arm64-v8a] architecture are supported by SolAR.**\n\nWhile you launch build for Android platform : \n\n* On Unity\n** Unity pre-build process will be called to generate `./Assets/StreamingAssets/SolAR/Android/android.xml`. This file will list every file in under your `./Assets/StreamingAssets/`. \n\n** Path of pipelines xml in `./Assets/StreamingAssets/SolAR/Pipelines/` are set to match Android filesystem to the public application directory. This will let your xml available on your device and you could edit them.\n\n** This file will be read to clone every asset included in the Android private JAR to Android application public path\n\n** APK is built and it includes Unity StreamingAssets and libraries\n\n* On Android\n\n** While the application is launched for the first time, it will look for `android.xml` in the private application JAR. Then if this file doesn't exist in the device application public path (`/storage/emulated/0/Android/com.bcom/SolARDemo/files/StreamingAssets/SolAR/Android`) it will be read and all of his content lists will be cloned into this path. Otherwise, the already present one will be read and cloned. If you don't want to **overwrite** an asset at each application launching you can set the overwrite attribute for a dedicated file to false.\n\n** The pipeline selected by the application will be load (from public application path) and his path to `./Assets/Plugins` will be matched with Android private JAR path (`/data/app/com.bcom/SolARUnityPlugin-[only-known-on-running]==/lib/arm64/`).\n\n** Application is initialized correctly. You can change the pipeline selected with SolARMenu in the right-hand corner.\n\n\nimage::../assemble/images/AndroidPipeline.jpg[Android pipeline,1100,600,align=\"center\",title=\"Android pipeline\"]\n\n== Test your pipeline in {cpp}\n\nTo test your pipeline in {cpp}, have a look to the section >.\n",
    id: 37
  });
  

index.add({
    title: "on windows",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: on windows\n:page-category: install\n:page-description: on windows\n:page-liquid:\n:page-layout: default\n:toc:\n:solar-version: 0.7.0\n:solar-version_: 0_7_0\n\n== Install On Windows\n\n== Test SolAR\n\nWe provide you with a set of samples to test the possibilities of the SolAR framework. Each .zip file corresponds to stand-alone applications, including all necessary SolAR .dll and .exe files.\n\n.Available Samples\n|===\n| Natural Image Marker | https://github.com/SolarFramework/NaturalImageMarker/releases/download/NaturalImageMarker%2F{solar-version}%2Fwin/SolAR_Natural_{solar-version_}.zip[v{solar-version} download link] (v0.9.0 coming soon)\n| Fiducial Marker | https://github.com/SolarFramework/FiducialMarker/releases/download/FiducialMarker%2F{solar-version}%2Fwin/SolAR_Fiducial_{solar-version_}.zip[v{solar-version} download link] (v0.9.0 coming soon)\n| SLAM | https://github.com/SolarFramework/Sample-Slam/releases/download/SLAM%2F{solar-version}%2Fwin/SolAR_SLAM_{solar-version_}.zip[v{solar-version} download link] (v0.9.0 coming soon)\n| Triangulation | https://github.com/SolarFramework/Sample-Triangulation/releases/download/Triangulation%2F{solar-version}%2Fwin/SolAR_Triangulation_{solar-version_}.zip[v{solar-version} download link] (v0.9.0 coming soon)\n|===\n\nIMPORTANT: Print the marker image included in .zip file to perform the test.\n\n== Install development environment [[InstalDevEnv]]\n\nThe SolAR framework uses a dedicated pipeline to link and compile code as well as internal tools for third party downloads which should make your job much easier.\nAs you will see later, the SolAR framework is based on _QMake_ originally created by the Qt Company, but is compliant with most IDE including Visual Studio.\n\n=== Install your IDEs\n\n==== Visual Studio\n\nYou will have to install Visual Studio to get the corresponding compiler and debugger on your machine. The community version 2017 has been tested and is available on the following link: link:++https://my.visualstudio.com/Downloads?q=visual%20studio%202017&wt.mc_id=o~msft~vscom~older-downloads++[Visual Studio installer]\n\nWe recommend to install at least the following features:\n\n* Desktop Development C++\n* Game development with Unity (useful to develop and debug Unity applications)\n* Mobile development in C++ (to build for Android)\n\n==== QT Creator\n\nAs SolAR is using QMake file to setup the projects, we highly recommend to install _Qt Creator_. Moreover, you will have access to wizards which will help you create new SolAR modules, components and pipelines.\n\nDownload the last version of QTCreator on the following link (scroll down to choose \"Downloads for open-source users\" for open-source development):\nhttps://www.qt.io/download[QT installer download]\n\nWhen downloaded, run the _Qt Installer_ +\n\nCreate a _Qt_ account if not already done, select where you want to install _Qt_. You don't need to install _Qt_ SDK, just the _Qt Creator_. So just check the following components:\n\n* Qt x.x.x (last version proposed)\n** with MSVC 2017 64-bit\n** Android (if you want to build SolAR for Android)\n* Developer and Designer Tools\n** Qt Creator x.x.x CDB Debugger Support\n** Debugging Tools for Windows\n\nand start the installation.\n\n==== QT Visual Studio Tool\n\nIf you are more comfortable with Visual Studio, you will have to install the Visual Studio plugin called _QT Visual Studio Tool_ which will allow you to open Qt projects. To do so, Open Visual Studio, click on `_Tools_` menu, then on `_Extensions and Updates_`. Search for _Qt Visual Studio Tools_, and install it. To complete this installation, you must restart Visual Studio.\n\n=== Install dependencies\n\nTo download dependencies, the SolAR framework uses the meta dependencies management tool https://github.com/b-com-software-basis/remaken[Remaken] supporting https://conan.io/[Conan], https://github.com/microsoft/vcpkg[VCPKG] and its native C++ packaging structure based on https://www.freedesktop.org/wiki/Software/pkg-config/[pkg-config] description files.\n\n==== Install Remaken [[InstallRemaken]]\n\n    * Start by downloading and installing _Remaken_ available on the following link: https://github.com/b-com-software-basis/remaken/releases/download/1.7.1/Setup_Remaken_1.7.1.exe[Remaken installer version 1.7.1]\n    * Launch the remaken installer *with administrator rights*. By default, the dependencies will be installed in your `C:/Users/%Username%` directory, but you can change it by setting another location for your _REMAKEN_PKG_ROOT_ environement variable. By default, Remaken will install Conan, pkg_config and CMake which will be used afterwards. It will also add conan-community and bincrafters conan remotes. Conan will check these remotes for searching your dependencies.+\n    * SolAR has its own conan remote to store pre-built dependencies for the common configurations used by the SolAR Framework. You will need to add this conan remote with the following command in a command prompt:\n\n----\nconan remote add conan-solar https://artifact.b-com.com/api/conan/solar-conan-local\n----\n\n    * Then, open a command prompt *with administrator rights* and run:\n\n----\nremaken init --tag latest\n----\n\nThis command will install the latest the qmake building rules in your `C:/Users/%Username%/.remaken/rules` folder.\n\nFinally, you need to configure your remaken profile according to your development environment. To do so, run the following command in a command prompt:\n\n----\nremaken profile init --cpp-std 17 -b cl-14.1 -o win -a x86_64\n----\n\n// TIP: You can install anohter version of the qmake rules by passing it with _--tag_ parameter, but we recommend to install the default one..\n\n==== Set conan profile\n\nAs we are using conan to download dependencies, you need to configure your default conan profile. To do so, open the default file available in your `C:/Users/%Username%/.conan/profiles`, and replace the configuration by the following one before saving it:\n----\n[settings]\nos=Windows\nos_build=Windows\narch=x86_64\narch_build=x86_64\ncompiler=Visual Studio\ncompiler.cppstd=17\ncompiler.version=15\nbuild_type=Release\n[options]\n[build_requires]\n[env]\n----\n\nNow, you are ready to download your dependencies with Remaken.\n\n==== Use Remaken\n\nRemaken uses a file called _packagedependencies.txt_ to describe which depedencies to install, in which version, where to install them, where to download them, with which package manager and with which configuration. +\n\nA global _packagedepedencies.txt_ defining the common dependencies with specific _packagedependencies_os.txt_ files defining dependencies which are specific for each os are available in the parent GIT repository _SolAR_, and can be downloaded on the following link:\n\n* https://raw.githubusercontent.com/SolarFramework/SolAR/master/packagedependencies.txt[packagedependencies.txt]\n* https://raw.githubusercontent.com/SolarFramework/SolAR/master/packagedependencies-win.txt[packagedependencies-win.txt]\n\nCopy these files where you want on your computer, open a terminal in the folder where you have copied the _packagedependencies.txt_ and _packagedependencies_os.txt_ files, and run remaken with the following command:\n\n----\nremaken install packagedependencies.txt\n----\n\nThis command will install all SolAR dependencies in release mode in your _C:/Users/%Username%/.remaken/packages_ folder. You can go and have a cup of coffee while it's downloading.\n\nTo download the dependencies in debug mode, run the following command:\n\n----\nremaken install -c debug packagedependencies.txt\n----\n\nThis is done, all your dependencies are downloaded and ready to use !\n\nSome of the module will download and build third parties using Conan which requires CMake (minimum version 3.10).\n\n== Build SolAR v0.9.0\n\ninclude::installClone.adoc[]\n\n=== Build on Qt Creator\nCounting the framework, the pipeline manager, modules, module tests, samples, pipelines, pipeline tests, there are more than 60 QT projects on GitHub. In order to ease the building of all this projects, they are grouped in the following parent QT projects available into the root folder of SolAR:\n\n* SolARCore\n* SolARAllModules\n* SolARAllModulesTests\n* SolARAllSamples\n* SolARAllPipelines\n* SolARAllPipelineTests\n\nYou can open one of them or all in QT Creator.\n\nCheck by clicking on the `_Projects_` tab, and then on the `_Manage Kits..._` button that your _QT MSVC2017 64bit_ kit is well configured (Microsoft Visual C++ Compiler should be in version _15.x.x.x (x86_amd64)_ if your are using Visual Studio 2017). +\n\ninclude::projectDependencies.adoc[]\n\nThen, in the `Build` menu, click on `Rebuild All Projects for All Configurations`, and go get a cup of coffee.\n\nNOTE: When using visual compiler on QT creator, you do not need to add a make step to install built binaries. In the children project files (.pro), you will find a line with `PROJECTCONFIG = QTVS`. This configuration will automatically manage installation step according to the argument set to variable `DEPENDENCIESCONFIG`, and it also works for visual studio. For more information, see the documentation of the builddefs-qmake project on https://github.com/b-com-software-basis/builddefs-qmake[GitHub].\n\n=== Build on Visual Studio\n\nYou have first to set the path of Qt for _Qt Visual Studio Tool_. Click on the `_Qt Vs Tools_` tab, and then on `_Qt Options_`. Add a new Qt Version (for instance name: _5.14.1 MSVC207_64_, path: _C:\\Qt\\5.14.1\\msvc2017_64_). +\nWhen this is done, simply open the Qt parent projects by cliking on the `_Qt VS Tools_` tab, and on `_Open Qt Project File (.pro)_`. Then build your projects. It's done!\n\n== Q&A\n\n=== Conan Error when installing dependencies: PermissionError: [WinError 5]\nSome Conan recipes are renaming the unzipped folders embedding the source code of the dependence as soon as they are downloaded locally. Unfortunately, your antivirus or the Windows Search Indexing can lock it. We recommend to deactivate Windows Search Indexing on Conan folders, and check your antivirus to avoid any control after unzipping the conan package. If you have still a problem, you will have to add __time.sleep()__ before renaming your unzipped folder in your problematic conan recipes (see the following thread for more details: https://github.com/conan-io/conan/issues/5205).\n\n=== Remaken does not work\nBe sure to install, init and use Remaken from a command prompt with admin rights.\nYou can check that _cmake_, _pkg-config_ and conan are well installed with the following command:\n\n----\ncmake -version\n----\n\n----\npkg-config --version\n----\n\n----\nconan -v\n----\n\nIf not, sometimes the remaken setup encounters conflicts with a version of Python already installed on your machine. If it is the case, install cmake by your own with pip:\n\n----\npip install cmake\n----\n",
    id: 38
  });
  

index.add({
    title: null,
    content: ":page-layout: _auto\n.Example.xml\n[source,xml]\n----\n\n\n\n\n  \n    \n    \n  \n\n\n\n    \n      \n    \n \n \n\n  \n    \n    \n  \n  \n    \n        y\n        y\n        y\n    \n  \n\n\n\n----\n\n\n|===\n| Node | Function | Attributes + \n[_Required_ by default]\n.1+| module\n| *Use that node to add a module to your pipeline.* +\nEach module is composed of components that you can use in your pipeline. | \n\t\t   *uuid* = Each module has an uuid that has to be give here. +\n\t\t   *name* = The name of the module used +\n\t\t   *path* = The path to the module used +\n\t\t   *description* = You can describe a little bit the module function.\n.1+| component\n| *Use that node to use the component in your pipeline.* +\nEach component inherits from interface. | \n\t\t   *uuid* = Each component has an uuid that has to be give here. +\n\t\t   *name* = The name of the component used +\n\t\t   *description* = You can describe the component function.\n.1+| interface\n| *This node is linked to component node.* +\n | \n\t\t   *uuid* = Each interface has an uuid that has to be give here. +\n\t\t   *name* = The name of the interface used +\n\t\t   *description* = You can describe the interface function.\n|  |  | \n.1+| factory\n| [_Optional_] +\n *Declare a factory to manage components.* Composed of bindings +\n | \n \n.1+| bindings\n| *Gives opportunity to put priority on components using the same interface.* Composed of bind node +\n | \n\n.1+| bind\n| *bind a component on an interface to make priority or name on it.* +\n | \n\t\t*interface* = Interface to bind +\n\t\t*to* = target component of the bind (component of a module added) +\n\t\t*name* = [_Optional_] Name of the bind (link interface->component) +\n|  |  | \n.1+| properties\n| *Root Node for parameters declaration of each component* +\n | \n \n.1+| configuration\n| *Configure component's parameters* +\n | \n\t\t*component* = name of the component to configure\n\n.1+| property\n| *Change a parameter* +\n | \n\t\t*name* = name of the parameter to configure +\n\t\t*type* = string / bool / Float / Integer / UnsignedInteger ... +\n\t\t*value* = parameter value with type respect.\n.1+| value\n| *Use to define a vector. Refer to the example above.* +\n | \n|===",
    id: 39
  });
  




  
  
  



var store = [];

  
store.push({"title": "GIT",
  "link": "https://solarframework.github.io///community/GIT/"
});

  
store.push({"title": "About",
  "link": "https://solarframework.github.io///about/"
});

  
store.push({"title": "for Android development",
  "link": "https://solarframework.github.io///install/android/"
});

  
store.push({"title": "api",
  "link": "https://solarframework.github.io///create/api/"
});

  
store.push({"title": "best practises",
  "link": "https://solarframework.github.io///community/best_practices/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///create/build/"
});

  
store.push({"title": "create a component",
  "link": "https://solarframework.github.io///create/component/"
});

  
store.push({"title": "contribution workflow",
  "link": "https://solarframework.github.io///community/contribution_workflow/"
});

  
store.push({"title": "C++",
  "link": "https://solarframework.github.io///use/cplusplus/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///feed.xml"
});

  
store.push({"title": "get modules",
  "link": "https://solarframework.github.io///assemble/get_modules/"
});

  
store.push({"title": "Install",
  "link": "https://solarframework.github.io///install/"
});

  
store.push({"title": "Community",
  "link": "https://solarframework.github.io///community/"
});

  
store.push({"title": "Create",
  "link": "https://solarframework.github.io///create/"
});

  
store.push({"title": "Use",
  "link": "https://solarframework.github.io///use/"
});

  
store.push({"title": "Assemble",
  "link": "https://solarframework.github.io///assemble/"
});

  
store.push({"title": "Home",
  "link": "https://solarframework.github.io///"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///install/installClone/"
});

  
store.push({"title": "How to install",
  "link": "https://solarframework.github.io///install/installassemble_back/"
});

  
store.push({"title": "install",
  "link": "https://solarframework.github.io///install/installcreate_back/"
});

  
store.push({"title": "on linux",
  "link": "https://solarframework.github.io///install/linux/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///js/lunr-feed.js"
});

  
store.push({"title": "Made with SolAR",
  "link": "https://solarframework.github.io///made_with_solAR/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///assets/styles/main.css"
});

  
store.push({"title": "create module",
  "link": "https://solarframework.github.io///create/module/"
});

  
store.push({"title": "module api",
  "link": "https://solarframework.github.io///assemble/moduleapi/"
});

  
store.push({"title": "package &amp; download third parties",
  "link": "https://solarframework.github.io///argodoc/packageanddownload/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///install/projectDependencies/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///assemble/project_file/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///js/search.js"
});

  
store.push({"title": "Search",
  "link": "https://solarframework.github.io///search/"
});

  
store.push({"title": "standalone pipeline",
  "link": "https://solarframework.github.io///assemble/standalone_c_plus_plus/"
});

  
store.push({"title": "Tags",
  "link": "https://solarframework.github.io///tags/"
});

  
store.push({"title": "module tests",
  "link": "https://solarframework.github.io///create/tests/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///create/third_parties_packaging/"
});

  
store.push({"title": "tools",
  "link": "https://solarframework.github.io///use/tools/"
});

  
store.push({"title": "unity",
  "link": "https://solarframework.github.io///use/unity/"
});

  
store.push({"title": "unity pipeline",
  "link": "https://solarframework.github.io///assemble/unity_pipeline/"
});

  
store.push({"title": "on windows",
  "link": "https://solarframework.github.io///install/windows/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///community/xpcfConfXML_doc/"
});



  
  
  


function searchAndDisplay(query){
  var resultdiv = $('#results');
  var result = index.search(query);
  // Show results
  resultdiv.empty();
  // Add status
  resultdiv.prepend('<p class="">Found '+result.length+' result(s)</p>');
  // Loop through, match, and add results
  for (var item in result) {
    var ref = result[item].ref;
    var searchitem = '<div class="result"><div class="result-body"><li><a href="'+store[ref].link+'" class="post-title">'+store[ref].title+'</a></li></div>';
    resultdiv.append(searchitem);
  }
}

// builds search
$(document).ready(function() {
    var query = (decodeURI(location.search).split("q" + '=')[1] || '').split('&')[0];
    var formattedQuery = query.split("+").join(" ");
    searchAndDisplay(formattedQuery);

    $('input#search').on('keyup', function () {
      var query = $(this).val();
      searchAndDisplay(query);
    });
});
