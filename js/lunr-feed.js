// builds lunr
var index = lunr(function () {
  this.field('title')
  this.field('content', {boost: 10})
  this.ref('id')
});



index.add({
    title: "GIT",
    content: "GIT\n\nTable of Contents\n\nGIT\nAccess to code source here\n\nThe direct links to repositories\n\n\nHow to contribute\nAccess to Pull Requests\nAccess to issues\n\n\n\nGIT\n\n\n\n\n\nAccess to code source here\n\n\nTo get access to the list of all SolAR repositories: https://github.com/SolarFramework\n\n\nThe direct links to repositories\n\n\n\n\n\n\n\n\n\nName\nGitHub url\n\n\nFramework\nSolARframework\nhttps://github.com/SolarFramework/SolARFramework\n\n\nbuild_scripts\nhttps://github.com/SolarFramework/build-scripts\n\n\nModules\nSolARModuleOpenCV\nhttps://github.com/SolarFramework/SolARModuleOpenCV\n\n\nSolARModuleNonFreeOpenCV\nhttps://github.com/SolarFramework/SolARModuleNonFreeOpenCV\n\n\nSolARModuleTools\nhttps://github.com/SolarFramework/SolARModuleTools\n\n\nSolARModuleFBOW\nhttps://github.com/SolarFramework/SolARModuleFBOW\n\n\nSolARModuleOpenGV\nhttps://github.com/SolarFramework/SolARModuleOpenGV\n\n\nSolARModuleCeres\nhttps://github.com/SolarFramework/SolARModuleCeres\n\n\nSolARModuleOpenGL\nhttps://github.com/SolarFramework/SolARModuleOpenGL\n\n\nSamples\nNatural Image Marker\nhttps://github.com/SolarFramework/NaturalImageMarker\n\n\nFiducial Marker\nhttps://github.com/SolarFramework/FiducialMarker\n\n\n Sample-Slam\nhttps://github.com/SolarFramework/Sample-Slam\n\n\nSample-Triangulation\nhttps://github.com/SolarFramework/Sample-Triangulation\n\n\n\n\n\n\n\nHow to contribute\n\n\nPlease refer to our contribution workflow section\n\n\n\n\nAccess to Pull Requests\n\n\nhttps://solarframework.github.io/SolAR-githubPullRequests.html\n\n\n\n\nAccess to issues\n\n\n\n\nFor open issues visit https://github.com/issues?q=user%3ASolarFramework+is%3Aopen\n\n\n\n\n",
    id: 0
  });
  

index.add({
    title: "About",
    content: "About\n\nAbout us\n\n\n\n\n\nWho initiated Solar ?\n\n\nThe SolAR initiative was launched by the b&lt;&gt;com Institute of Research and Technology, and is open to any contributors or users who share the SolAR goals.\n\n\n\n\n\n\n\n\n\nOur first Contributors\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nContact US\n\n\nFor any requests, please contact us.\n\n\n",
    id: 1
  });
  

index.add({
    title: "API",
    content: "\nTable of Contents\n\nSolAR API\n\n\n\nSolAR API\n\n\n\n",
    id: 2
  });
  

index.add({
    title: "api",
    content: "\n:page-description:API\n:page-layout: default\n:page-category: assemble\n:page-liquid:\n:toc:\n\n\nAPI\n\n\n\n\n\nAPI\n\n\nIn order to build your Pipeline, please refer to the list of available API in the SolAR framework :\n\n\n\n",
    id: 3
  });
  

index.add({
    title: "best practises",
    content: "BEST practises\n\nTable of Contents\n\nBest practices\nSolAR guidelines\n\nComponent Interfaces\nModules and Components\nComponent Implementations\nModules\nPipepline Management\n\n\nLogs to help debugging\ncoding rules\n\nProject organization\nFiles\nC / C++ Coding Rules\nLanguage features\nLibraries and headers\nNaming conventions\nDesign conventions\nLayout conventions\nTracing and debugging\nError handling\nMiscellaneous conventions\nDocumentation\nC/C++ Performance rules\nTools\n\n\nAppendix A.\tRules management\n\nI.\tResponsibility\nII.\tDeviation\nIII.\tTraining\nIV.\tControl\n\n\n\n\n\nBest practices\n\n\n\n\n\nSolAR guidelines\n\n\nThe following rules shall be used for every addition/modification to the SolAR project.\nThis encompasses the SolAR framework and the GUI interface and unless otherwise specified, these rules shall apply to both.\n\n\nComponent Interfaces\n\n1.1. Solar component interfaces are virtual base classes. They shall inherit from class org::bcom::xpcf::IComponentIntrospect\n\n\n1.2. SolAR Interfaces are defined in a dedicated header file (.h) whose name shall begin with a capital I followed with the name of the abstract class it refers to, e.g. ICamera.h.\n\n\n1.3. SolAR Interfaces shall not contain member variables, it is an abstract class without committing to a particular implementation of the class. If you need member variables, declare them in the implementation of the component\n\n\n1.4. A component interface must be a abstract class, meaning that all its methods must be virtual.\n\n\n1.5. Solar Framework is organized hierarchically via dedicated directories and namespaces. Currently, concerning the interfaces, this organization is as follows :\n\n\n\n\n\n\n\n\nDirectory\nnamespace\n\n\n\n\nSolARFramework/interfaces/api/display\nSolAR::api::display\n\n\nSolARFramework/interfaces/api/features\nSolAR::api::features\n\n\nSolARFramework/interfaces/api/geom\nSolAR::api::geom\n\n\nSolARFramework/interfaces/api/image\nSolAR::api::image\n\n\nSolARFramework/interfaces/api/input/devices\nSolAR::api::input::devices\n\n\nSolARFramework/interfaces/api/input/files\nSolAR::api::input::files\n\n\nSolARFramework/interfaces/api/sink\nSolAR::api::sink\n\n\nSolARFramework/interfaces/api/solver/map\nSolAR::api::solver::map\n\n\nSolARFramework/interfaces/api/solver/pose\nSolAR::api::solver::pose\n\n\n\n\n1.6. Namespaces should use lower case.\n\n\n1.7. Any new interface must fall into one of these categories. Yet, if needed, one may ask the SolAR Team to add a new one to fulfill a particular need not covered by the current organization.\n\n\n1.8. If possible, an abstract interface of a component must define only one processing method. Exception may be allowed if your processing method need take as an input or output only one or a collection of several objects, as for instance:\n\n\n\nvirtual void drawCircle(SRef&lt;Point2Df&gt; point, unsigned int radius, int thickness, std::vector&lt;unsigned int&gt; &amp; bgrValues, SRef&lt;Image&gt; displayImage) = 0;\n virtual void drawCircles(std::vector&lt;SRef&lt;Point2Df&gt;&gt;&amp; points, unsigned int radius, int thickness, SRef&lt;Image&gt; displayImage) = 0;\n\n\n\nor if the processing method can take as input our output parameter an object or an inherited object, as for instance:\n\n\n\nvirtual void drawCircles(std::vector&lt;SRef&lt;Point2Df&gt;&gt;&amp; points, unsigned int radius, int thickness, SRef&lt;Image&gt; displayImage) = 0;\nvirtual void drawCircles(std::vector&lt;SRef&lt;Keypoint&gt;&gt;&amp; keypoints, unsigned int radius, int thickness, SRef&lt;Image&gt; displayImage) = 0;\n\n\n\n1.9. A 128-bit UUID (Universal Unique IDentifier) shall be associated to any virtual interface and explicitly quoted in the interface header file, preferably after the class definition.\n\n\nThe syntax is the following :\n\n\n\nXPCF_DEFINE_INTERFACE_TRAITS(SolARnamespaces::IInterfaceClassName,\n                             &quot;aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee&quot;,\n                             &quot;Interface description&quot;);\n\n\n\nAn example :\n\n\n\nXPCF_DEFINE_INTERFACE_TRAITS(SolAR::api::display::I2DOverlay,\n                             &quot;62b8b0b5-9344-40e6-a288-e609eb3ff0f1&quot;,\n                             &quot;SolAR::I2DOverlay interface&quot;);\n\n\n\n1.10. The header file shall contain Doxygen documentation code in order to automatically generate the interface description web page during the continuous integration process used by the Solar Integration Team.\nIn particular the purpose of the interface shall be documented, as well as each virtual method with its input/ouput parameters.\nFor instance for class documentation:\n\n\n\n/**\n * @class I2DOverlay\n * @brief Drawing interface to overlay 2D information on top of an image.\n *\n * This class provides drawing methods to overlay 2D debug informations on top of an image.\n */\n\n\n\nand for method documentation:\n\n\n\n/// @brief Draw a Squared Binary Pattern.\n/// @param[in] pattern The squared binary pattern to display.\n/// @param[in,out] displayImage The image on which the squared binary pattern will be drawn (on the whole image).\nvirtual void drawSBPattern (SRef&lt;SquaredBinaryPattern&gt; pattern, SRef&lt;Image&gt; displayImage) = 0;\n\n\n\n\nModules and Components\n\nModules are the placeholders for the components. Basically, they are defined to reflect a particular type of implementation, based e.g. on a particular technology or a particular provider, etc &#8230;&#8203;\n\n\nA component cannot exist by itself. It must be included in a module but a module may contain only one component if needed.\n\n\nThey are are few rules that modules and components must conform to in order to be usable by SolAR. This is explained in the following.\n\n\n\n\nModules are delivered as shared libraries (windows or linux)\n\n\nThe recommended naming convention is  ModuleName, where name should reflect a characteristic of the module, e.g. ModuleOpencvFree.\n\n\nComponents are declared inside a namespace according to the following naming convention : SolAR::MODULES::NAMEOFMODULE\n\n\nA 128-bit UUID (Universal Unique IDentifier) shall be associated to every module\n\n\nA 128-bit UUID (Universal Unique IDentifier) shall be associated to every component included in a module\n\n\nA Module exports its components via a dedicated Export API defined in a header file named NameOfModuleAPI.h, such :\n\n\n\n\n\n/**\n * Copyright and license notice ......\n */\n\n#ifndef NAME_API_H\n    #define NAMEOFMODULE_API_H\n    #if _WIN32\n        #ifdef NameOfModule_API_DLLEXPORT\n            #define NAMEOFMODULE_EXPORT_API __declspec(dllexport)\n        #else //NameOfModule_API_DLLEXPORT\n            #define NAMEOFMODULE_EXPORT_API __declspec(dllimport)\n        #endif //NameOfModule_API_DLLEXPORT\n    #else //_WIN32\n        #define NAMEOFMODULE_EXPORT_API\n    #endif //_WIN32\n    #include \"NameOfModule_traits.h\"\n#endif //NAMEOFMODULE_API_H\n\n\n\nand where 'NameOfModule_traits.h'  exposes the list of components contained in the module. Follows a generic example of this file.\n\n\n\n#define NAMEOFMODULE_TRAITS_H\n\n#include &quot;xpcf/component/ComponentTraits.h&quot;\n\nnamespace SolAR {\nnamespace MODULES {\nnamespace NAME {\nclass Component1;\nclass Component2;\n}\n}\n}\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::MODULES::NAME::Component1,\n                             &quot;aaaaaaaa-bbbb-cccc-dddd-eeeeeeee&quot;,\n                             &quot;SolAR::MODULES::NAME::Component1 definition&quot;)\n\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::MODULES::NAME::Component1,\n                             &quot;ffffffff-gggg-hhhh-iiii-jjjjjjjj&quot;,\n                              &quot;SolAR::MODULES::NAME::Component2 definition&quot;)\n\n\n#endif // NAMEOFMODULE_TRAITS_H\n\n\n\n\n\nThere will be a code file named NameOfModule.cpp that shall contain the Module UUID as well as which components are included and exposed in the module. The syntax is as follows.\nNameOfModule.cpp:\n\n\n\n\n\n#include \"xpcf/module/ModuleFactory.h\"\n\n#include \"component1.h\"\n#include \"component2.h\"\n\nnamespace xpcf=org::bcom::xpcf;\n\nXPCF_DECLARE_MODULE(\"kkkkkkkk-llll-mmmm-nnnn-oooooooo\", \"ModuleName\")\n\n\nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid&amp; componentUUID,SRef&lt;xpcf::IComponentIntrospect&gt;&amp; interfaceRef)\n{\n     xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n     errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::NAME::component1&gt;(componentUUID,interfaceRef);\n     if (errCode != xpcf::XPCFErrorCode::_SUCCESS)\n     {\n         errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::NAME::component2&gt;(componentUUID,interfaceRef);\n     }\n    return errCode;\n}\n\nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::MODULES::Name::component1)\nXPCF_ADD_COMPONENT(SolAR::MODULES::Name::component2)\nXPCF_END_COMPONENTS_DECLARATION\n\n\n\nIn the above mentioned code, a two-component module is considered.\n\n\nEach component is implemented via a class (.cpp/.h).\n\n\nComponents should be implemented for processing.\nIt should take in parameters and deliver out components and data.\n\n\n2.1. Data structures should be implemented for the data flow, meaning the data that will be exchanged between components at runtime thanks to the processing methods of the components. To optimize vision pipelines developped thanks to the SolAR Framework, it is of real need to take care to data structure optimization (reduce the memory copy, favour a quick access to data, etc.)\n\n\n2.2. A data structure must be defined in a namespace SolAR::datastructure\n\n\n2.3. The header and cpp files must be put under the datastructure directory.\n\n\n2.4. The header file shall contains Doxygen documentation code in order to automatically generate the data structure description web page during the continuous integration process used by the Solar Integration Team.\nFor instance for class documentation:\n\n\n\n/**\n  * @class Image\n  * @brief Specifies the Image base class.\n  *\n  * This class provides an image abstraction for SolAR\n  */\n\n\n\nand for method documentation:\n\n\n\n/** @brief  reserves new space depending on the image layers and bitspercomponent infos\n  *  @param width: width of the image\n  *  @param height: height of the image\n  */\n  void setSize(uint32_t width, uint32_t height);\n\n\n\n\n\n\n\n\n\nPlease refer to existing SolAR component interfaces and take them as examples.\n\n\n\n\n\n\nComponent Implementations\n\nA component implements a low-level vision processing in order to offer much more flexibility. They can be be interconnected together to create  high-level and real-time vision pipeline (localization, 3D reconstruction, etc.).\n\n\nThat is why a component should take in parameters and deliver out data structures to ease their connection (data flow).\n\n\nWhen you intent to  create a component, first verify that :\n\n\n\n\na SolAR interface already exists for your kind of components. If so, please use the specified interface.\nif no, or if you think the existing interfaces do not totally fit your need, please contact the SolAR team.\n\n\n\n\nPlease look at the organization of existing modules and components.\n\n\n3.1. Any component must be embedded in a module. Modules are used to easily publish one or a group of components to the solAR community. If you want to create a new module, please copy the existing structure of SolAR modules.\n\n\n3.2. Your components should have explicit names (that means, that ideally, we do not need to read documentation to understands what it is for and on which third party it is based). Please refer to existing components for naming examples.\n\n\n3.3. Your components must inherit from component interfaces defined by the SolARFramework. If no component interface fit your need or if you think an existing interface should be extended, please contact the SolAR team.\n\n\n3.4. Your components can define their own attributes which should be defined as private. No attributes can be shared by other components. If you want to shared data between components, pass them as attribute of the processing method.\n\n\n3.5. Your components can define their own methods which should be defined as private. The only public methods should be the ones defined by the abstract interfaces.\n\n\n3.6. Processing methods should not pass control or configuration parameters, but only the parameters representing the input and output dataflow of the component. If a parameter does not have vocation to change at each pass of the pipeline, this parameter must be moved as a private attribute of the component.\n\n\n3.7. All methods defined by the abstract interface you are inheriting must be implemented in your component.\n\n\n3.8. Your component should inherit from ConfigurableBase if you want to configure it thanks to an external file (please refer to other components, for instance ImageFilter). So you won&#8217;t have to recompile your pipeline if you want to change the configuration of its components.\n\n\nexample :\n\n\n\nSolARImageFilterBinaryOpencv::SolARImageFilterBinaryOpencv():ConfigurableBase(xpcf::toUUID&lt;SolARImageFilterBinaryOpencv&gt;())\n{\n    addInterface&lt;api::image::IImageFilter&gt;(this);\n}\n\n\n\n3.9. If you want to initialize the value of component attributes at runtime thanks to an external file, you need to wrap it to a naming string. Thus, you will be able to configure your pipeline by editing an external file defining this attribute by its given name.\nexample :\n\n\n\n    params-&gt;wrapInteger(&quot;min&quot;, min);\n\n\n\n3.10. There is no need to implement a setParameter and a getParameter method in a SolAR component. To configure a parameter at runtime in your code, get the wanted property of your component through the IConfigurable interface and set it to the desired value.\n\n\nexample :\n\n\n\nauto rIConfigurable_imageFilterBinary = imageFilterBinary-&gt;bindTo&lt;xpcf::IConfigurable&gt;();\nauto imageFilterBinary_property=rIConfigurable_imageFilterBinary-&gt;getProperty(&quot;min&quot;);\nimageFilterBinary_property-&gt;setIntegerValue(-1);\n\n\n\n3.11. All Dataflow parameters of a processing method that are not modified by the function must be const.\n\n\n3.12. All Dataflow parameters of a processing method that are SRef and that can be instantiated by the method must be a reference on a SRef, otherwise do not use a reference on a SRef. In the following example, the ouptut image of a ImageConvertor can be auotmatically instantiated according to the size of the input image:\n\n\n\nvirtual FrameworkReturnCode convert(SRef&lt;Image&gt; imgSrc, SRef&lt;Image&gt;&amp; imgDst) = 0;\n\n\n\n3.13. The namespace of your component must respect the following form: modules::module_name, where module_name refers to the name of your module.\n\n\n3.14. The namespaces of your component should use lower case.\n\n\n\n\n\n\n\n\nPlease refer to existing SolAR component implementations and take them as examples.\n\n\n\n\n\n\n\n\n\n\n\nPlease refer to existing SolAR components and take them as examples.\n\n\n\n\n\n3.15. Each parameter of each method of your component should be tested in your code, to detect bad parameter values. When an incorrect value is detected, the method should return an errorcode. This will help developers for implementing and debugging their pose estimation solution.\n\n\n3.16. Each component should have a corresponding \"simple\" unit test . The unit test should test component creation, configuration, and simple use of this component, with normal cases. The unit test should be commented, to help other contributors to understand your component.\n\n\n3.17. Each component should have unit tests with limit cases, as bad instanciation (bad values of attributes), bad use of components (for example: try to load an image that does not exist), and test every error code of each method.\n\n\n\nModules\n\n4.1. A Module is a group of components with the same implementation basis :\n\n\n\n\nsame third parties\n\n\nsame authors\n\n\nsame Intellectual Properties\n\n\n\n\n4.2. For each module, there should be a XML file describing the components with their UID. Please refer to SolarModuleTools example, and XPCF documentation to do it.\n\n\n4.3. In each module, there should be a Module unit test project, gathering the unit tests of all components.\n\n\n\nPipepline Management\n\nSolAR architecture is based on a pipeline manager called XPCF and implemented by b&lt;&gt;com.\nPlease refer to the XPCF github project link: https://github.com/b-com-software-basis/xpcf [XPCF GITHUB repository] to know more about XPCF.\n\n\n\n\n\n\n\n\nPlease be aware that components must be interoperable thanks to XPCF, and that is why thoses guidelines should be used.\n\n\n\n\n\n\n\n\nLogs to help debugging\n\n\nA SolARLog tool has been defined in order to help you to debug and test your programs.\n\n\nSolarLog is based on spdlog, and is managed as a singleton, so that you will have at maximum 2 loggers : 1 console and 1 file.\n\n\nYou have  2 log modes\n\n\n\n\nconsole\n\n\nfile\n\n\n\n\nPlease initiate your console logger with  LOG_ADD_LOG_TO_CONSOLE or file logger thanks to  LOG_ADD_LOG_TO_FILE.\n\n\nYou will easily find examples in SolAR sample codes.\n\n\nPlease use one of this macro to log your data, depending on the severity you want :\n\n\n\n\nLOG_TRACE: create a TRACE of INFO level\n\n\nLOG_INFO(fmt, &#8230;&#8203;) : create a log of INFO level\n\n\nLOG_DEBUG(fmt, &#8230;&#8203;) : create a log of DEBUG level\n\n\nLOG_CRITICAL(fmt, &#8230;&#8203;) : create a log of CRITICIAL level\n\n\nLOG_WARNING(fmt, &#8230;&#8203;) : create a log of WARNING level\n\n\nLOG_ERROR(fmt, &#8230;&#8203;)  : create a log of ERROR level\n\n\nLOG_FLUSH : can be used to force logs flush (console or file mode)\n\n\nLOG_RELEASE : is used to release the logger (should be used at the end of a program).\n\n\n\n\n\n\ncoding rules\n\n\nProject organization\n\nIn order to ease the source code management, we should follow the same hierarchy for each module. A module typically becomes one dynamic or static library (dll or lib). To make the code more accessible and friendly for everyone, developers should follow the rules below:\n\n\n\nFiles\n\n\n\n\n\n\n\nC++/C modules\n- Project-wide definitions must be in a dedicated header file (for instance definitions.h)\n- Each module may have a common .h file that contains all common constants, macros, enum, structures… It should not contain elements that are not common to classes in the module.\n\n\nC++/C source files\nC++/C source files should contain the implementation of only one class (except for very small private utility classes related to that class).\nSee Naming conventions for naming conventions.\n\n\nC++/C headers files\nC++/C headers files should contain the declaration of only one class (except for very small public utility classes related to that class).\nSee Naming conventions for naming conventions.\n\n\nDirectory layout for each module\nThe directory layout for each module should be as described in:\n coding_rules.adoc chapter Project organisation\n\n\n\n\n\nC / C++ Coding Rules\n\n\n\n\n\n\n\nNOT VALIDATED\nTIP: Write here if you validate with your name and your comment\n\n\n\n\n\nWhy restricting C++?\n\n\nEven if compilers now correctly compile even the most advanced C++ language features, some advanced features make the code overly complex and difficult to maintain.\n\n\nWhy restricting C?\n\n\nC can be written in many ways to do the same things but some ways are more obfuscated and offers less robustness.\n\n\nThen, what language to use?\nb&lt;&gt;com is using a mix of C and C++ based on existing code, external dependencies (like platform types, SDK, etc).\n\n\nThat’s why the following rules makes sense in our environment and, in order to facilitate porting and code review, developers must use the set of rules defined below. An example of code and header can be found in annexes A1 and A2.\n\n\n\nLanguage features\n\nAs it is very easy to make unreadable and non-understandable C code, here are a few rules/restrictions to follow for the C language itself:\n\n\n\n\n\n\n\n\nTemplates\nTemplates should be used following the \"KISS\" principle. Extreme template programming must be avoided and replaced with ad-hoc design to ensure code maintainability.\n\n\nExceptions\nExceptions must not be used outside package boundary (i.e. outside a static or dynamic library no exception must be thrown).\n\n\nOperator overload\nOperator overloading should be used appropriately.\n\n\nWeird language features of C++\nWeird language features of C++ must not be used, especially:\n- static variables that invoke constructors at initialization time  (except for some very special cases, such as the singleton pattern)\n- run-time type information (‘casts’ can fail at run-time)\n\n\nBit fields\nBit fields must not be used for the following reasons: they are not portable because the implementation of bit fields is left to the compiler manufacturer according to the platform; and usage of bit fields is usually inefficient in terms of code size. Use one variable instead of each bit field.\nConsider using the STL bitset template class instead.\n\n\nNamespaces\nNamespaces may be used for std classes to avoid the full Class::methName statement. But for internal classes with ambiguous names, try to always use their full class name.\n\n\n'goto' keyword\nThe 'goto' keyword should not be used, and if it is, it can only be used to jump to the end of a method for error recovery.\nBy considering the architecture of a method, this keyword can nearly always be avoided.\nSee annex A3 for examples.\n\n\n‘continue’ and ‘break’ keywords\nThe ‘continue’ statement should not be used; the ‘break’ statement should not be used except inside switch statements.\n\n\n‘return’\nThe 'return' keyword may be used anywhere in the code.\nHowever, it requires that the no dynamic allocation rule is respected (see below) and that no vital code is skipped.\nIt also requires that all synchronization is made through C++11 lock_guard objects.\n\n\nC++ types\nTypes such as bool, etc. may be used if they are not platform dependant.\n\n\nC++ iostreams\nIostreams should be used.\n\n\nDynamic memory allocations\nDynamic memory allocation should be avoided.\nMost of the time, C++ offers semantics that allows no dynamic allocation design.\nmalloc/free, new/delete should be used during initialization sequence (in the class constructors for instance)\nDuring run time, explicit memory allocations should not be used to avoid memory fragmentation and leaks.\nIf an array is needed at some point during the execution of the program, this need should preferably be planned and reserved at the initialization sequence.\nLocal arrays are recommended if they are small in size (no more than 16-32 values).\n\n\nArrays\nuse STL&#8217;s vector&lt;T&gt; and array&lt;T&gt; instead of old C-style arrays, as C-style arrays don&#8217;t behave as expected with C++ objects.\n\n\nDynamically allocation of member (aggregated/composed) object\ndynamic allocation of a \"local\" object must occur only when the inner object lifetime is different from the \"hosting\" class (aggregation case) OR when the used framework doesn&#8217;t allow the creation of the object upon class creation (for instance, when no default constructor is available).\nWhen dynamically allocating inner objects, prefer the use of STL&#8217;s shared_ptr or unique_ptr (depending on the inner object lifetime), to ensure proper behavior upon exception throwing &#8230;&#8203;\n\n\nClass instantiations during run time\nAll the necessary classes, arrays, structures should be present, allocated and initialized before run time (during the initialization sequence) except for transient objects (objects operated by a pipeline should be created at the beginning and destroyed at the end for instance)\n\n\nConstants\nConstants must be declared using static const or enum for enumeration of constants. #define must be avoided (language evolution tends to avoid #statements).\n\n\nconst\nconst keyword MUST be used. It must be used appropriately.\nUsed on method parameters, it clearly shows when a parameter is an input, input/output or output parameter.\nUsed for methods, it clearly shows that const methods leave the underlying object members unmodified. (typically getters should be const methods).\n\n\n\n\nC++11\n\n\n\n\n\n\n\n\nMove semantics\nMove semantics must not be used. In most cases, move semantics can be replaced with designing the method using C++ references upon output parameters, or with the use of STL shared_ptr.\n\n\nLambdas expressions\n\n\n\nThreads\nC++11 threads and related facilities (mutex, scoped lock_guard, future &#8230;&#8203;) must be used\n\n\nLiterals\n\n\n\nRange for\nRange for must be used to work on containers as it improves the code readibility\n\n\nauto\nauto keyword use is recommended when it simplifies the code readibility.\nIt allows to avoid explicit typing of objects when there&#8217;s not a strong interest to :\n- for iterators\n- for temporary objects\n\n\nsmart pointers\nSTL&#8217;s smart pointers must be used. When possible, it should replace most of old C-style pointers (DLL boundary issue ?)\n\n\nFunction objects\nstd::function, std::bind, std::mem_fn &#8230;&#8203; readibility, maintainability issues ?\n\n\nSTL containers initializer list\n\n\n\nDate and time\nSTL chrono, useful also for performance counters\n\n\nSTL\narray&lt;T&gt;, bitset&lt;T&gt;\n\n\n\n\n\nLibraries and headers\n\n\n\n\n\n\n\nSTL containers\nSTL should be used for container types, such as vectors, lists, maps, etc. (but must not be used across DLL boundaries).\n\n\nC++ strings\nThe C++ string object should be used for string manipulation (but must not be used across DLL boundaries).\n\n\nC++ 'cin', 'cout', 'cerr'\nThe C++ 'cin', 'cout', 'cerr' must not be used (except inside unit test code and command line tools).\n\n\nC 'stdin', 'stdout', 'stderr'\nThe C 'stdin', 'stdout', 'stderr' must not be used (except inside unit test code and command line tools).\n\n\nC headers/libraries\nC headers/libraries may be used.\n\n\nSystem specific headers/libraries\nSystem specific headers/libraries must not be used\n(except in system specific source code – in that case it should be clearly isolated and identified). The code should use as little as possible the windows SDKs (tradeoff between using existing code and code created from scratch).\n\n\nMultiple header include\nTo avoid multiple definitions, each header must have:\n#ifndef HEADERNAME_H\n#define HEADERNAME_H\n&lt;header&gt;\n#endif // HEADERNAME_H\n\n\nInclude inside header files\n#include should not be inside header files in order to avoid include files obfuscation, and to prevent some cases of bad build of a project which shares dependencies with a non-rebuilt project.\n\n\nFunction and variable declaration\nFunction and variable declarations must be done in header files (and not in other files).\n\n\n#pragma once\nUse of #pragma once is prohibited :\n- even if it is supported by a vast majority of c++ compilers, it is not a standard directive of the language\n- although it protects from header naming conflict, it doesn&#8217;t prevent from ncluding a header twice if it exists in more than one location in a project as files are excluded based on their filesystem-level identity.\n\n\n\n\n\nNaming conventions\n\n\n\n\n\n\n\nNOT VALIDATED\nTIP: Write here if you validate with your name and your comment\n\n\n\n\n\n\n\n\n\n\n\nAbout names\n- Words must be in English.\n- Words inside the name must start with an uppercase letter. Other letters of the word must be lowercase letters (except for constants).\n- Names should not contain underscores '_' (except for constants and the prefixes as specified bellow).\n- Names should not contain abbreviations (except if the abbreviation is widely used in the particular field, such as ESDescriptor for “elementary stream descriptor”).\n- Names should be explicit according to what they will do, avoid generic names (like i, a, x…).\n\n\nC++ source files\nC++ source files must begin with the name of the class followed by ‘.cpp’.\n\n\nC source files\nC source files must begin with the name of the class followed by ‘.c’.\n\n\nC++/C headers files\nC++/C header files must begin with the name of the class followed by ‘.h’.\n\n\nC++ template headers files\nC++ template header files must begin with the name of the class followed by ‘.[inl|tpl]’.\n\n\nC++ template source files\nC++ template source files must begin with the name of the class followed by ‘.[ipp|tcc]’.\n\n\nClasses,\nstructures,\nglobal functions, structure tags, typedefs,\nenumerated values\nClass names, structure names, global functions, structure tags, typedefs, enumerated values must have their name beginning with an uppercase.\nExample MatrixBase\n\n\nMethods\nMethod names must begin with a lowercase letter (except for constructors and destructors).\nExample\treadAccessUnit()\n\n\nPrivate members\nPrivate member variable names must be prefixed with 'm_' and start with a lowercase letter.\nExample\tm_accessUnitList\n\n\nPrivate static members\nIf used, private static member variable names must be prefixed with 's_' and start with a lowercase.\nExample\ts_socketCounter\n\n\nLocal variables\nLocal variable names must start with a lowercase letter.\nExample\tdataLength\n\n\nConstants\nConstants must be all uppercase with each word separated by “_”.\nExample\tMAX_LENGTH\n\n\n\n\n\nDesign conventions\n\n\n\n\n\n\n\nMultiple inheritance\nPolymorphism\nMultiple inheritances should not be used, except if the additional classes are pure virtual (equivalent to Java interfaces).\n\n\nClasses with public virtual methods\nClasses with public virtual methods must have a virtual destructor (or else the destructor will not be called). When possible, use the appropriate compiler warning to be warn when destructor isn&#8217;t declared virtual while some public methods are.\n\n\nStatic member variables\nStatic member variables must not be used (these are basically “global variables”). (except for singleton design pattern)\n\n\nPublic member variables\nPublic member variables must not be used (except in pure “struct-like” classes). Instead, getter and/or setter methods should be provided to access member variables.\nExample\tint getMember()\n{\n&#8230;&#8203;.return m_member;\n}\nError setMember(int variable)\n{\n&#8230;&#8203;.if (variable&#8230;&#8203;)\n&#8230;&#8203;.{\n&#8230;&#8203;&#8230;&#8203;..m_variable = variable;\n&#8230;&#8203;&#8230;&#8203;..return NoErr;\n&#8230;&#8203;.}\n&#8230;&#8203;.return Error_NUMBER;\n}\n\n\nUnsigned/signed types\nSigned and unsigned computations should not be mixed. Signed and unsigned doesn’t work well together and are, in many cases, not comparable one another.\nSituations like “comparing unsigned values with potentially negative values” or “use signed computations to be casted into unsigned variables” makes the code vulnerable.\n\n\nSigned types\nUnsigned types  should be used.\nSigned types should only be used when the value for the variable or parameter in question could sensibly be negative.\n\n\n'enum' type\nFor variables or parameters that may take one of a set of values whose representation is arbitrary, the enum type should be used.\nExample\tenum CM_Colors { CM_RED, CM_GREEN, CM_BLUE };\n\n\nDynamic length structure\nIt is recommended to avoid structures with dynamic length. However, if they are used, the size should be bounded in size in order to avoid unlimited memory occupation.\n\n\nPreprocessor definitions\nThe definition and use of preprocessing flags (#ifdef/#ifndef) in the source code should be limited; in particular, there should not be any OS or compiler specific code.\nHowever, if specific code is present, it should be isolated and clearly identified.\nMost of the time, a different design approach allows to avoid inlined OS preprocessor definitions (namespace or inheritance usage for instance).\n\n\nCode under conditional compilation flags\nCode under #if, #ifdef, #ifndef should be limited. Theses sections, if not build with the rest of the code, can easily be broken without notice.\n\n\nInline\nInline may be used instead of macro for functions that are called often and when they are more than one line long.\n\n\nRange of variables\nConsider the range of each variable: each variable should remain local to a code block as much as possible.\nVariable like the for iterator can remain local to the loop. If the if condition statement block needs a local variable: declare it inside the statement block. This variable will not be visible outside the block, preventing misuse.\nNote for Intel compilers: before ICC11, declaring a variable into a for statement for (int myVariable;…) resulted in having the variable defined locally to the function containing the for. With ICC11, this variable exists only with the for statement code block.\nExample\tif (myCondFct())\n{\n&#8230;&#8203;.\tint myLocalVar = methodVar * m_aMember;\n&#8230;&#8203;.useMyLocalVar(myLocalVar);\n}\naMethodThatCanNotUseMyLocalVarHere();\nmyLocalVar is only used in the if statement block. If someone attempts to use it outside, the project will not build. This variable only serves that code block and it is not useful outside. The code is easier to read, no need to monitor myLocalVar, or wonder if it is used elsewhere…\n\n\nScope of variables\nAvoid using one variable for multiple purposes (the compiler handles this optimization process better than anybody).\n\n\nCode organization\nIt is recommended to differentiate:\n- Functions dedicated to computing.\n- Functions dedicated to schedule and control the computing functions.\n- Functions dedicated to data flow management.\nExample\tError computeFunc(UInt32* res, UInt32* sourceTable)\n{\n&#8230;&#8203;.// compute code\n&#8230;&#8203;.res = sourceTable[0] * sourceTable[1] + MY_CONST;\n&#8230;&#8203;.return NoErr;\n}\nError dataFlowFunc(MyStruct destStruct, MyStruct* sourceStruct)\n{\n&#8230;&#8203;.// copy struct\n&#8230;&#8203;.memcpy(destStruct, sourceStruct, sizeof(destStruct));\n&#8230;&#8203;.return NoErr;\n}\nError controlFunc(MyStruct* destStruct, MyStruct* sourceStruct, UInt32* sourceTable)\n{\n&#8230;&#8203;.Error err;\n&#8230;&#8203;.UInt32 res;\n&#8230;&#8203;.err = computeFunc(&amp;res, sourceTable);\n&#8230;&#8203;.if (err == NoErr)\n&#8230;&#8203;.{\n&#8230;&#8203;&#8230;&#8203;..err = dataFlowFunc(destStruct, sourceStruct);\n&#8230;&#8203;.}\n&#8230;&#8203;.return err;\n}\n\n\nThread concurrency\nUse threads with caution. It is recommended to ask architecture experts about the use of threads. Use C++11 threads' library.\n\n\nSingleton design pattern\nThis pattern should not be used unless absolutely needed. When used, special care should be taken to consider concurrent access issues; the unique instance should be automatically created in the first call of “getInstance”; and the constructor should be declared as private.\nSometimes, a statically created singleton is the prefered choice (more than the dynamically created one).\n\n\nCasts\nCasts should not be used unless absolutely needed. C-style casts must be prohibited and replaced with C++ casts.\nExample\tUInt16 var1;\nUInt32 var2;\nUInt64 myResult;\nmyResult = var1 * var2;\nmyResult = (UInt64) var1 * var2;\nmyResult = UInt64(var1) * UInt64(var2);\n\n\n\n\n\n\n\n\n\n\nDon&#8217;t put two methods calls on the same line. Don&#8217;t put break keyword in switch/case statement at the end of a processing line.\n\n\n\n\n\n\nLayout conventions\n\n\n\n\n\n\n\nTabs\nTabs must not be used. Spaces must be used for indentation. Editors should be set to fill with spaces, not tabs. Tab settings tend to be different for editors, printers and web pages.\nNote: This is obviously an arbitrary choice, but mixing tabs and spaces causes much difficulty in reviewing code…\n\n\nIndentation\nIndentation offset must be set to 4 spaces and is performed according to the following rules:\n- code surrounded by braces must be indented by one level.\n\n\nBlank lines\nA blank line should be used to separate logically distinct sections of code.\n\n\nCurly brackets\nCompound statements (if, else, else if, while, for, switch, do) must ALWAYS make use of curly brackets, even where the \"associated\" body only consists of a single line. Structures must use curly brackets around the clause.\n\n\nCurly brackets\nCurly brackets should appear at the beginning of the next line or at the end of the line.\nExample\tif (a == b) {\n&#8230;&#8203;.c = 0;\n}\nelse {\n}\nif (a == b)\n{\n&#8230;&#8203;.c = 0;\n}\nelse\n{\n}\n\n\nParentheses\nAlthough C++ has precedence rules that should ensure a given expression is evaluated in the same order regardless of the compiler, additional parentheses should be used where the order of evaluation is not obvious.\n\n\nMultiple parentheses\nParentheses on multiple lines must be aligned on the previous parentheses with the same level. Operators must be at the end of the lines.\nExample\tif (a == b) &amp;&amp; &#8230;&#8203;..(c == d ||\n&#8230;&#8203;.(e == f))\nif (a == b) &amp;&amp; (c == d ||\n&#8230;&#8203;.(e == f))\n\n\nFunctions\nEach function should perform a single well-defined operation.\nFunctions should not be too long. Up to 2 pages of printout or about 100 lines of source code is reasonable. These figures include comments and blank lines.\n\n\nSource files\nSources files must be small. 1000 lines of source code is reasonable (including comments and blank lines).\nThese files are easier to read and faster to compile (Intel compiler can compile several source files in parallel).\n\n\nHeader files\nHeader files must be small. 100 lines for headers are reasonable.\n\n\nSwitch\nCase/default from a switch statement are written on the same column as the switch keyword. break; and other lines are indented.\n The break keyword must ALWAYS be on its own line. Mixing the break keyword with processing code makes the code confused : it can be interpreted as \"fall-off\" code when break is at the end of long lines.\nExample\tswitch (getStyle(config))\n{\ncase STYLE_GOOD:\n&#8230;&#8203;.// Ah, it&#8217;s so good!\n&#8230;&#8203;.break;\ncase STYLE_BAD:\n&#8230;&#8203;.// Oh no, it&#8217;s bad!\n&#8230;&#8203;.break;\ndefault:\n&#8230;&#8203;.// Hmmm!\n&#8230;&#8203;.break;\n}\n\n\nInstructions\nPut one instruction per line.\n\n\nfor\nAlways put curly brackets in for clause. for instructions must be on their own lines (not on the for line)\n\n\n\n\n\nTracing and debugging\n\n\n\n\n\n\n\nBoost::log\nBoost::log is the recommended framework to log, as it provides great functionality out of the box without the need for extra/complex configuration\n\n\n\n\n\nError handling\n\n\n\n\n\n\n\nDefault error codes and types\nThe default error codes and error types should be declared in a common b&lt;&gt;com header file.\n\n\nType of value returned for error codes\nThe type of value returned for error codes should be Error.\nExample\tError parseString(char *str);\n\n\nMemory allocation\nA method that attempts to allocate memory must provide an allocation failure mechanism, typically by returning an error code. Note that other methods that call such a method must also provide a failure mechanism, and so on&#8230;&#8203; Memory allocation should not be performed in constructors as constructors don’t return error code.\n\n\nFile management\nThe success of a file opening must be checked and if not successful, the error must be handled appropriately.\nFiles must be closed when no longer used or when an error to exit occurs.\nWhen closing the file, the return value must be checked.\n\n\nFunction call\nThe success of a function call must be checked and if not successful, the error must be handled appropriately. The error codes returned by functions must be tested and treated.\n\n\nInit/deinit functions\nAfter calling constructors and before destructors, it is sometimes necessary to call init and deinit functions to permit error handling on structures that might fail (as these errors cannot be handled in constructors and destructors.\n\n\n\n\n\nMiscellaneous conventions\n\n\n\n\n\n\n\nCompiler warnings\nSource code must not have any warnings when compiled on any targeted platform with any targeted compiler (with a reasonably high warning level – at least level 3).\n\n\nC – C++ interfacing\nAll C public interfaces (*.h) which may be compiled with a C++ compiler must wrap the contents of the file with the pair of macros BEGIN_EXTERN_C and END_EXTERN_C.\nExample\tBEGIN_EXTERN_C\nEND_EXTERN_C\n\n\nC++ interfacing\nAll C class headers (*.h) which may be compiled with a C compiler must include a C API and ensure the non visibility of C code by putting it within an “#ifdef __cplusplus … #endif” statement.\n\n\nDynamic library export\nThe definition of each class or function that is exported in a dynamic library must be preceded by the XX_EXTERN keyword, XX being the prefix for the module to which the class belongs.\n\n\nPortability\nSee http://www.mozilla.org/hacking/portable-cpp.html for more miscellaneous recommendations on portability on various platforms. If a rule differs from b&lt;&gt;com coding rules, follow the b&lt;&gt;com coding rule.\n\n\n\n\n\nDocumentation\n\n\n\n\n\n\n\nCopyright\nEach b&lt;&gt;com source and header file must use the template copyright header comment.\n(See Annex A1: .h)\nSource from other origins (Open Source for example) may have their own license. In this case, the license must be respected. The headers of third party files must be left intact (then it should not be replaced by b&lt;&gt;com copyright).\n\n\nPrimary documentation\nof a class\nThe primary documentation of a class must appear in the header file.\n\n\nClass description\nEach class must have a description before the class declaration.\n(see Annex A1: class description)\n\n\nMethods\nEach method (public, protected and private) must have a short description before the method declaration.\n(see Annex A1: setup method description)\nA method that is already sufficiently documented in the superclass may omit the description or have a single-line comment '// see superclass'\n(see Annex A1: clone method description)\n\n\nMember variable\nEach member variable must have a description either before the member variable declaration or on the same line.\n(see Annex A1: member description)\n\n\nComments\nComments are written in English. Do not use accented characters in source files.\nAll comments should be “DOxygen” compatible (see Tools). All tags must start with ‘@’ and not ‘\\’.\nEach block of code should be commented. Algorithms must be commented.\nBugs from Bugzilla must not be referenced in the code.\n\n\n/*…/\nThis type of comment block must be used for comments that apply either to a class, a function, a structure, an enum, a member… which is present below the comment block.\n(see Annex A1: class description)\n\n\n//\nThis comment line should be used inside the code to comment lines in C++ sources. They should be used even for block of comments.\n(see Annex A2)\n\n\n/…/\nThis comment block should not be used for C++ except for the template copyright block on top of the file and for method and variable documentation.\n\n\n\n\n\nC/C++ Performance rules\n\nBecause we need performance for all code types to achieve close-to-realtime target, these rules replace corresponding rules in previous chapters in order to ensure better software performance.\nFor C++, to improve performance, classes must act as evolved structures/handlers. They must point at a set of non reentrant methods (avoiding static code, allowing parallelism, allowing instantiation).\n\n\n\n\n\n\n\n\n'goto' keyword\nThe 'goto' keyword must not be used.\n\n\n‘continue’ and ‘break’ keywords\nThe ‘continue’ statement must not be used; the ‘break’ statement must not be used outside of switch statements.\n\n\nC++ &#8594; C convertibility\nC++ source must always be convertible into C code. If the rules associated with classes are followed, a class can be immediately converted into a structure and a bunch of methods with, as parameter, a handle on the structure that represents the former members.\n\n\nRecursive code\nRecursive code must not be used for performance reasons and lack of control over the code and because no parallelization and optimization are possible.\n\n\n?No class as class member?\nA class must not contain another class as a member except through pointers.\n\n\nStructures must not contain arrays\nA structure (class or struct) must not contain arrays except through pointers.\nThe size of the structures must remain reasonable.\n\n\nDynamic memory allocation\nDynamic memory allocation must not be used.\nmalloc/free, new/delete must be used during initialization sequence (into the class creators for instance)\nDuring run time, explicit memory allocation must not be used to avoid memory fragmentation and leaks.\nIf an array is needed at some point during the execution of the program, this need must be planned and reserved at the initialization sequence.\nLocal arrays are tolerated if they are small in size (no more than 16-32 values).\n\n\nClass instantiations during run time\nAll the necessary classes, arrays, structures must be present, allocated and initialized before run time (during the initialization sequence).\n\n\nDynamic length structure\nDynamic length structures must not be used (in order to avoid unlimited memory occupation).\n\n\n\n\n\nTools\n\n\n\n\n\n\n\nUncrustify\nMost of the code formatting rules described in this document can be enforced using “uncrustify”.\n\n\nDOxygen\nDOxygen extract comments from the source code and generates documentation. It is recommended to check the comment structure with this tool.\nRefer to the online manual (http://www.stack.nl/~dimitri/doxygen/index.html) for a complete description of DOxygen rules.\n\n\n\n\n\n\n\nAppendix A.\tRules management\n\n\nI.\tResponsibility\n\nThe Development group manager is responsible of these rules.\n\n\n\nII.\tDeviation\n\nAny b&lt;&gt;com source code must follow these rules. Third party package follow their own rules and should not be modified to follow these rules.\n\n\n\nIII.\tTraining\n\nAny C/C++ developers and integrators must be trained to these rules.\n\n\n\nIV.\tControl\n\nThe compliancy with these coding rules can be performed with Uncrustify tool with the appropriate config file (see tools).\n\n\n\n",
    id: 4
  });
  

index.add({
    title: null,
    content: "\nTable of Contents\n\nbuild scripts for windows &amp; linux\nINIT\nfromscratch-cmake.sh\nfromscratch-nonfree-cmake.sh (optional)\ncheckout.sh\n\nInteractive mode\nNon interactive mode\n\n\nupdateGit.sh\n\nInteractive mode\nNon interactive mode\n\n\ncmake-build.sh\n\n./build-scripts/cmake-build.sh list\n./build-scripts/cmake-build.sh clean\n/build-scripts/cmake-build.sh [target]\n./build-scripts/cmake-build.sh all\n\n\n\n\n\nbuild scripts for windows &amp; linux\n\n\n\n\n\nINIT\n\n\nYou should first install cmake, and check the addition of cmake to your path.\nhttps://cmake.org/download/\n\n\nPlease use first fromscratch-cmake.sh to download the entire SolAR framework (nonfree excepted ), and then select the branch you want to work on.\n\n\n\n\n\n\n\n\nplease note that the updateGit.sh will select the required branch for every GIT repository where the specified branch exists.\n\n\n\n\n\n$ ./build-scripts/fromscratch-cmake.sh\n\n\n$ ./build-scripts/updateGit.sh develop\n\n\n\n\nfromscratch-cmake.sh\n\n\nIn a directory that only contains build-scripts/ folder, you may launch:\n\n\n\n        $ ./build-scripts/fromscratch-cmake.sh\n\n\n\nThis command will first get all dependencies (third parties libraries) for you. Then it will\ncreate a source/ directory, and will clone all sources/ into that directory.\nFinally sources will be built and installed.\n\n\n\n\nfromscratch-nonfree-cmake.sh (optional)\n\n\nThis command is similar to fromscratch-cmake.sh. The only difference is that it allows the download of non free dependencies\n(e.g non free libs that are part of opencv-contrib libraries). Some non free libraries and non free samples will also be built and installed.\n\n\n\n\ncheckout.sh\n\n\nThis script is used to position a switch a specific git repository to a desired branch.\nTwo usages are possible:\n\n\nInteractive mode\n\nThis mode will display the list of all possible branches to switch to,\nand will let the user enter the number of desired branch.\nExample:\n\n\n\n        $ ./build-scripts/checkout.sh sources/SolARFramework\n        REPOSITORY: SolARFramework\n        CURRENT BRANCH: feature/xpcf_v2\n\n\n\n\nSELECT BRANCH TO CHECKOUT\n1) calib_with_file               8) feature/transform3d\n2) develop                       9) feature/xpcf_v2\n3) feature/KP_AKAZE2            10) feature_TransformClass\n4) feature/cmake                11) master\n5) feature/non_free_VS_Update   12) readmeSolARframework\n6) feature/pose_helper          13) splitOpencv\n7) feature/slam                 14) triangulation\n#? 2\nSwitched to branch 'develop'\nYour branch is behind 'origin/develop' by 2 commits, and can be fast-forwarded.\n  (use \"git pull\" to update your local branch)\n\n\n\n\nNon interactive mode\n\nIn this mode user will pass the desired branch name as a parameter. Example:\n\n\n\n        $ ./build-scripts/checkout.sh sources/SolARFramework feature/xpcf_v2\n\n\n\n\nREPOSITORY: SolARFramework\nCURRENT BRANCH: develop\n\n\n\n\nSELECT BRANCH TO CHECKOUT\nSwitched to branch 'feature/xpcf_v2'\nYour branch is up to date with 'origin/feature/xpcf_v2'.\n\n\n\n\n\n\nupdateGit.sh\n\n\nThis script will update all your SolAR git repositories, and will allow the user to switch to desired branches.\nIn order to be used, the sources and scripts must be organized as follows:\n\n\n\n        $ ls -l\n        drwxr-xr-x                 build-scripts/\n        drwxr-xr-x                 sources/\n\n\n\n\n        $ ls -l sources/\n        drwxr-xr-x                 SolARFramework/\n        drwxr-xr-x                 Modules/\n        drwxr-xr-x                 Samples/\n\n\n\nInteractive mode\n\n\n$ ./build-scripts/updateGit.sh\n\n\n\nIn this mode, the script \"checkout.sh\" will be called for those repositories: sources/SolARFramework, sources/Modules/SolAR* (ex: SolARModuleOpenCV) and all repositories\nunder sources/Samples folder.\n\n\n\nNon interactive mode\n\nThis mode will allow a user to pass a desired branch name (that has to be common to all repositories)\nExample:\n\n\n\n$ ./build-scripts/updateGit.sh develop\n\n\n\nThis command will switch sources/SolARFramework, sources/Modules/SolAR* (ex: SolARModuleOpenCV) and all repositories\nunder sources/Samples folder to \"develop\" branch.\n\n\nNote that in all cases repositories will be updated based on latest commits on github. Errors may occur if local changes\nhave not been commited or stashed.\n\n\n\n\n\ncmake-build.sh\n\n\nUsage:\nbuild-scripts/cmake-build.sh [target to build]\nex : build-scripts/cmake-build.sh SolARFramework\nex : build-scripts/cmake-build.sh all (to build all targets)\nex : build-scripts/cmake-build.sh clean (to delete build folder)\nex : build-scripts/cmake-build.sh list (to list all targets)\n\n\n./build-scripts/cmake-build.sh list\n\nThis command will list all the possible targets that the script can build.\nExample :\n\n\n\n        $ ./build-scripts/cmake-build.sh list\n        Available targets:\n        SolARFramework, SolARModuleOpenCV, SolARModuleNonFreeOpenCV, SolARModuleTools, NaturalImageMarker, FiducialMarker\n\n\n\n\n./build-scripts/cmake-build.sh clean\n\nThis command will delete te build directory (containing all cmake cache files,  built libraries, and executables).\n\n\n\n/build-scripts/cmake-build.sh [target]\n\nThis command will build a specific target. Example :\n\n\n\n        $ build-scripts/cmake-build.sh SolARFramework\n\n\n\nIf build/ directory doesn&#8217;t exist, it  will be created. Then a release/ and debug/ directory will be created, and SolARFramework\nwill be built and installed in these two modes.\n\n\n\n./build-scripts/cmake-build.sh all\n\nThis command will build and install all targets listed in \"./build-scripts/cmake-build.sh list\" output.\n\n\n\n",
    id: 5
  });
  

index.add({
    title: "create a component",
    content: "Create a component\n\nTable of Contents\n\nCreate a component\nWhat is a component ?\nCreate a component with the wizard\nCreate a component step-by-step\n\nCreate a component header\nCreate your component sources\nEmbed your component in its module\n\n\n\n\n\nCreate a component\n\n\n\n\n\nWhat is a component ?\n\n\nA SolAR component is element embedding processing (and soon storage) capabilities. Components are designed to be connected together in order to create a full pipeline. For this reason, a component defines ideally one (potentially several) processing function defining input (the data to process) and ouptut (the processed data). For interoperability issues, the component has to implement a SolAR component interface defined by the SolAR Framework API available  here.\n\n\nAs each component implementation can require dedicated configuration parameters, the SolAR framework provides an easy-to-use mechanism to initialize them at load-time with a external xml configuration file.\n\n\nFinally, when a SolAR component is implemented, it has to be embedded in a SolAR module for its publication to the SolAR pipeline assemblers.\n\n\n\n\nCreate a component with the wizard\n\n\nWe are aware that creating a component and embedding it into a module can be a little tedious. A QTCreator wizard should be soon available to automate file generation and make the component creation easier for you. But for now, follow the instructions below to create a component and add it to a module step-by-step.\n\n\n\n\nCreate a component step-by-step\n\n\nCreate a component header\n\nCreate with your IDE a header file and put it in the interfaces folder of your module project. Then copy the following code in it:\n\n\nMyComponent.h\n\n/**\n * Your header defining your copyright and your license\n */\n\n#ifndef MYCOMPONENT_H\n#define MYCOMPONENT_H\n\n// mandatory include files\n#include &quot;api/componentType/ISolARComponentInterface.h&quot; (1)\n#include &quot;MyModuleAPI.h&quot; (2)\n//#include &quot;xpcf/component/ComponentBase.h&quot; (3)\n#include &quot;xpcf/component/ConfigurableBase.h&quot;\n\n// Optional include files\n#include &quot;ThirdPartyLibrary/ClassA.h&quot; (4)\n\nnamespace SolAR {\nusing namespace datastructure;\nnamespace MODULES {\nnamespace MYMODULE { (5)\n  /**\n   * @class MyComponent\n   * @brief A short description of MyComponent with its UUID to publish it in the API documentation\n   */\n  class MYMODULE_EXPORT_API MyComponent : public org::bcom::xpcf::ConfigurableBase, (6)\n                                          public api::componentCategory::ISolARComponentInterface (7)\n  {\n  public:\n      ///@brief MyComponent constructor;\n      SolARProjectOpencv();\n      ///@brief MyComponent destructor;\n      ~SolARProjectOpencv() = default;\n\n      /// @brief Processing method\n      /// @param[in] input1 the first input parameter.\n      /// @param[in] input2 the second input parameter.\n      /// @param[out] output1 the first output parameter.\n      /// @param[out] output2 the second output parameter.\n      /// @return A framework return code\n      FrameworkReturnCode myComponentProcesingFunction(const int input1, (8)\n                                                       const SRef&lt;SolARDataStructure&gt; input2,\n                                                       int output1,\n                                                       SRef&lt;SolARDatastructure&gt; output2) override;\n\n      org::bcom::xpcf::XPCFErrorCode onConfigured() override final; (9)\n\n      void unloadComponent () override final; (10)\n\n  private: (11)\n      int                       m_configurableAttribute;\n      ThirdPartyLibrary::ClassA m_nonConfigurableAttribute;\n  };\n}\n}\n}\n\n#endif // MYCOMPONENT_H\n\n\n\n\n\n1\nThe SolAR component interface header implemented by your component among the ones defined by the SolAR Framework API available here.\n\n\n2\nThe API definition header file of your module to export the interfaces of your component.\n\n\n3\nIf you want to implement a configurable component, include the XPCF header file ConfigurableBase (Otherwise, ComponentBase).\n\n\n4\nInclude any dependencies to third parties here (std, boost, openCV, etc.). Do not use types or class from these third parties in public functions or attributes. Be sure that these dependencies have been included in the packagedependencies.txt file of your module (for more information, see the section on module dependencies configuration).\n\n\n5\nEmbed your component in the namespace of your module that must comply with the following convention: SOLAR/MODULES/MYMODULE.\n\n\n6\nDeclare your component class. Your component class must inherit from org::bcom::xpcf::ConfigurableBase if you want to configure parameters from an xml file, or from org::bcom::xpcf::ComponentBase otherwise.\n\n\n7\nInherit your component class from the SolAR interface it implements. The namespace of SolAR API are hierarchically organized complying the following convention: api/ComponentCategoryLevel_1/ComponentCategoryLevel_1/..ComponentCategoryLevel_n.\n\n\n8\nDeclare your processing function(s) by complying with the function prototype(s) of the abstract component interface your component implements (defined in the SolAR framework API).\n\n\n9\nOptional, callback if you need to apply some processing during initialization step when the configuration parameters of your component have just been loaded from the xml file.\n\n\n10\nMandatory function used by XPCF to unload your component.\n\n\n11\nDeclare the private attributes of your component. Normally, no public attributes should be declared since the component is only accessible by the public functions declared above.\n\n\n\n\n\nCreate your component sources\n\nCreate with your IDE a source file MyComponent.cpp, and put it in the src folder of your module project. Then copy the following code in it:\n\n\nMyComponent.cpp\n\n/**\n * Your header defining your copyright and your license\n */\n\n#include &quot;MyComponent.h&quot; (1)\n#include &quot;core/Log.h&quot; (2)\n\n// Optional include files\n#include &quot;ThirdPartyLibrary/ClassB.h&quot; (3)\n\nXPCF_DEFINE_FACTORY_CREATE_INSTANCE(SolAR::MODULES::MYMODULE::MyComponent); (4)\n\nnamespace xpcf  = org::bcom::xpcf;\nnamespace SolAR {\nusing namespace datastructure;\nnamespace MODULES {\nnamespace MYMODULE { (5)\n\nMyComponent::MyComponent():ConfigurableBase(xpcf::toUUID&lt;MyComponent&gt;()) (6)\n{\n    addInterface&lt;api::componentCategory::ISolARComponentInterface&gt;(this); (7)\n\n    SRef&lt;xpcf::IPropertyMap&gt; params = getPropertyRootNode(); (8)\n    params-&gt;wrapInteger(&quot;configurableAttribute&quot;, m_configurableAttribute);\n}\n\nxpcf::XPCFErrorCode MyComponent::onConfigured() (9)\n{\n  // Do initialization here when your configurable parameters have been updated with the xml configuration file.\n\n  return xpcf::_SUCCESS;\n}\n\nFrameworkReturnCode MyComponent::myComponentProcesingFunction(\n          const int input1,\n          const SRef&lt;SolARDataStructure&gt; input2,\n          int output1,\n          SRef&lt;SolARDatastructure&gt; output2) (10)\n{\n    // Processing code here\n\n    return FrameworkReturnCode::_SUCCESS;\n}\n}}}\n\n\n\n\n\n1\nInclude the header file of your component.\n\n\n2\nThe SolAR framework provides a dedicated solution for logging. Inlcude core/Log.h if you want to use it.\n\n\n3\nInclude any third partiy header files required for your processing. Be sure that these dependencies have been included in the packagedependencies.txt file of your module (for more information, see the section on module dependencies configuration).\n\n\n4\nAdd the component to the XPCF factory to be able to create an instance of it at run-time.\n\n\n5\nEmbed your component implementation in the namespace of your module that must comply with the following convention: SOLAR/MODULES/MYMODULE.\n\n\n6\nImplement your default component constructor. Inherit your component from ConfigurableBase, or ComponentBase if the component is not configurable, and in both case, pass as the argument of the parent constructor the UUID of your component.\n\n\n7\nDuring component construction, add its interface to XPCF.\n\n\n8\nTo add a configurable parameter and map it to the xml configuration file, retrieve a reference to the properties of the component, and add a wrapper for each configuration parameter you want to map. Here, when an xml element with the name configurableAttribute of type integer will be specified in the configuration file, when exiting the constructor, its value will be set to the attribute m_configurableAttribute.\n\n\n9\nIf you want to initialize internal structures requiring that the value of the configurable parameters was set, you can do it in the onConfigured callback.\n\n\n10\nImplement the processing function(s) of your component.\n\n\n\n\n\nEmbed your component in its module\n\nModule traits update\n\nTo add a component to your module, you need to define its traits in the file MyModule_traits.h:\n\n\nMyModule_traits.h\n\n/**\n * Your header defining your copyright and your license\n */\n\n#ifndef MYMODULE_TRAITS_H\n#define MYMODULE_TRAITS_H\n\n#include &quot;xpcf/core/traits.h&quot;\n\nnamespace SolAR {\nnamespace MODULES {\nnamespace MYMODULE {\n\nclass MyComponent; (1)\n\nXPCF_DEFINE_COMPONENT_TRAITS(MyComponent, (2)\n                             &quot;MyComponent UUID&quot;, (3)\n                             &quot;MyComponent name&quot;, (4)\n                             &quot;MyComponent description&quot;); (5)\n\n}\n}\n}\n#endif // MYMODULE_TRAITS_H\n\n\n\n\n\n1\nDeclare the class of your component.\n\n\n2\nProvide the class corresponding to your component.\n\n\n3\nReplace MyComponent UUID by a Universally Unique IDentifier. To get one, you can use an online UUID generator.\n\n\n4\nReplace MyModule name by the name of your module.\n\n\n5\nPlease, provide a detailed description of your component that could be introspected by authoring tools.\n\n\n\n\nYou have to add to this file as many component class declarations and traits as you have components in your module. Thanks to this trait file relative to a module, any user will just have to include it to instantiate any of its components.\n\n\n\nModule source update\n\nThen, you have to add you component to the module factory and declare it to XPCF in the MyModule.cpp:\n\n\nMyModule.cpp\n\n/**\n * Your header defining your copyright and your license\n */\n\n#include &quot;xpcf/module/ModuleFactory.h&quot;\n#include &quot;MyModule_traits.h&quot;\n\n#include &quot;MyComponent.h&quot; (1)\n#include &quot;MyComponent1.h&quot;\n#include &quot;MyComponent2.h&quot;\n\nnamespace xpcf=org::bcom::xpcf;\n\nXPCF_DECLARE_MODULE(&quot;MyModule UUID&quot;, &quot;MyModule&quot;, &quot;MyModule description&quot;);\n\nextern &quot;C&quot; XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid&amp; componentUUID,SRef&lt;xpcf::IComponentIntrospect&gt;&amp; interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n\n    errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::MYMODULE::MyComponent&gt;(componentUUID,interfaceRef); (2)\n    if (errCode != xpcf::XPCFErrorCode::_SUCCESS)\n    {\n        errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::MYMODULE::MyComponent1&gt;(componentUUID,interfaceRef);\n    }\n    if (errCode != xpcf::XPCFErrorCode::_SUCCESS)\n    {\n        errCode = xpcf::tryCreateComponent&lt;SolAR::MODULES::MYMODULE::MyComponent2&gt;(componentUUID,interfaceRef);\n    }\n    return errCode;\n}using\n\nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::MODULES::MYMODULE::MyComponent) (3)\nXPCF_ADD_COMPONENT(SolAR::MODULES::MYMODULE::MyComponent1)\nXPCF_ADD_COMPONENT(SolAR::MODULES::MYMODULE::MyComponent2)\nXPCF_END_COMPONENTS_DECLARATION\n\n\n\n\n\n1\nInclude your component header.\n\n\n2\nAdd a call to xpcf_tryCreateComponent to create your component when the module factory tries to instantiate it.\n\n\n3\nAdd your component to XPCF.\n\n\n\n\n\nUpdate the module registry\n\nFinally, edit the xpcf_MyModule_registry.xml that should be at the root folder of your module project. Add a decsription for each component you want to embed in your module as follows:\n\n\nxpcf_MyModule_registry.xml\n\n&lt;xpcf-registry&gt;\n&lt;module uuid=&quot;MyModule_UUID&quot; name=&quot;MyModule_Name&quot; description=&quot;MyModule_Description&quot; path=&quot;$REMAKENROOT/MyModule/MyModule_version/lib/x86_64/shared&quot;&gt;\n\n&lt;component uuid=&quot;MyComponent UUID&quot; name=&quot;MyComponent name&quot; description=&quot;MyComponent Description&quot;&gt; (1)\n        &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot;/&gt; (2)\n        &lt;interface uuid=&quot;UUID of the Inherited SolAR Interface&quot; name=&quot;name of the Inherited SolAR Interface&quot; description=&quot;description of the Inherited SolAR Interface&quot;/&gt; (3)\n&lt;/component&gt;\n\n&lt;/module&gt;\n&lt;/xpcf-registry&gt;\n\n\n\n\n\n1\nCopy and paste the component UUID, name and description defined in the file MyModule_traits.h.\n\n\n2\nKeep always this description to the inheritance to _IComponentIntrospect.\n\n\n3\nAdd a description to all SolAR interfaces inherited by MyComponent. To get access to UUID of SolAR interfaces, please refer at the end of the header file of each interface, into the parameters of the MACRO XPCF_DEFINE_INTERFACE_TRAITS.\n\n\n\n\n\n\n",
    id: 6
  });
  

index.add({
    title: "contribution workflow",
    content: "Contribution workflow\n\nTable of Contents\n\nContribution workflow\nContribute to SolAR Framework\nContributing by creating your own components\nContact\n\n\n\nContribution workflow\n\n\n\n\n\n\n\n\n\nContribute to SolAR Framework\n\n\nContributers may be interested in enhancing Solar Framework. For instance, they may want to:\n\n\n\n\ndefine new interfaces or new data structures\n\n\npropose bug fixes\n\n\netc.\n\n\n\n\nThe proposed workflow is based on github forks and pull requests:\n\n\n\n\nif not already done, create a github account: github\n\n\nopen the url of the repository related to the project you want to contribute to. The list of repositories and their urls is here: github SolAR repositories\n\n\nclick on the \"fork\" button in order to copy the repository to your own github account\n\n\nkeep your fork up to date: read the page help github in order\nto sync your local copy with the original repository\n\n\n\n\nYou may then ask the upstream repository to accept your changes: this is performed by creating a pull request.\nFollow the instructions at pull request documentation to see how to create a pull request\nbetween your fork and the original repository.\n\n\nWhen your pull request is created, request for a pull request review, by following these instructions: https://help.github.com/articles/requesting-a-pull-request-review/\n\n\n\n\nContributing by creating your own components\n\n\nYou may be interested by developing your own components based on SolAR interfaces.\nIn this case, create your own github repository, and create any SolAR components and packages you need by following these instructions.\n\n\nOnce your component is created, don&#8217;t hesitate to contact us!\n\n\n\n\nContact\n\n\nFor any request, please contact us.\n\n\n",
    id: 7
  });
  

index.add({
    title: "C++",
    content: "\nTable of Contents\n\nUse a pipleine in C [[UseC]]\nCreate a application project\n\nQT Creator\n&#8201;&#8212;&#8201;Using Cmake instead of .pro QT file&#8201;&#8212;&#8201;\n\n\nSelect your dependencies\nConfigure your pipeline\nmain.cpp\n\n\n\nUse a pipleine in C [[UseC]]\n\n\n\n\n\nCreate a application project\n\n\nQT Creator\n\nOpen QTCreator and create a new project (in File menu).\n\n\nSelect Non-Qt project and Plain C++ Application and click on Choose button.\n\n\n\n\n\nFigure 1. Plain C++ application creation\n\n\nThen, set the name of your application (e.g. MySolARApp) that will use a SolAR pipeline, and its location.\n\n\nNext, define your build system with qmake. For the next step, choose your development kits. We recommend to use MSVC 2017 64bit on Windows or Clang on Linux.\n\n\nYour project is now created, but as SolAR provides a smart and easy way to build and deploy you pipeline, you will need to update the .pro file. Select it in your project tree, and replace its script by the following one:\n\n\nMySolARApp.pro\n\n## remove Qt dependencies\nQT -= core gui\nTARGET = MySolARApp (1)\nVERSION=x.x.x (2)\n\nCONFIG += c++1z\nCONFIG -= qt\nCONFIG += console\n\nDEFINES += MYVERSION=$${VERSION}\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += NDEBUG=1\n}\n\nwin32:CONFIG -= static\nwin32:CONFIG += shared\n\nDEPENDENCIESCONFIG = sharedlib recurse\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude (../../builddefs/qmake/templateappconfig.pri) (3)\n\nSOURCES += \\\n    main.cpp\n\nunix {\n    LIBS += -ldl\n    QMAKE_CXXFLAGS += -DBOOST_LOG_DYN_LINK\n}\n\nmacx {\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CXXFLAGS += -fasm-blocks -x objective-c++\n}\n\nwin32 {\n    QMAKE_LFLAGS += /MACHINE:X64\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275\n\n    # Windows Kit (msvc2013 64)\n    LIBS += -L$$(WINDOWSSDKDIR)lib/winv6.3/um/x64 -lshell32 -lgdi32 -lComdlg32\n    INCLUDEPATH += $$(WINDOWSSDKDIR)lib/winv6.3/um/x64\n\n}\n\n\n\nNow, just update the .pro file:\n\n\n\n\n1\nset the TARGET with the name of your application,\n\n\n2\nset the version number of your application,\n\n\n3\ncheck if the builddefs folder used to define the building pipeline is well referenced\n\n\n\n\nFinally, click on Projects in the left menu of QTcreator, click on Run, set your working directory to the root directory of your project, and check Add build library search path to LD_LIBRARY_PATH if not already done.\n\n\n\n&#8201;&#8212;&#8201;Using Cmake instead of .pro QT file&#8201;&#8212;&#8201;\n\nCreate a CMakeLists.txt file and copy the following code to it.\nThis file use temporarily BCOMDEVROOT environment variable link to your SoLAR sources.\n\n\nCMakeLists.txt\n\ncmake_minimum_required(VERSION 3.7.2)\n\n##################################################\nproject(\"MySolARApp\") (1)\nset (VERSION_NUMBER \"x.x.x\") (2)\nset (SOURCES main.cpp)\n##################################################\n\n# various macros\ninclude(\"$ENV{REMAKENDEVROOT}/SolARFramework/0.6.0/solarmacros.cmake\") (3)\n# config setup\nsetup()\n# process packagedependencies.txt\nprocessPackagedependencies()\n\n# define the list of files to copy to build directory\n\nset(FILES_TO_COPY\n  # Copy framework and its dependencies binaries in your working folder (4)\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_filesystem.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_system.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_timer.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_log.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_chrono.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_thread.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_date_time.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/xpcf/${XPCF_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}xpcf.${LIBEXTENSION}\n  $ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/${SOLARFRAMEWORK_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}SolARFramework.${LIBEXTENSION}\n\n  # Copy module binaries in your working folder (5)\n  $ENV{BCOMDEVROOT}/bcomBuild/\"Module1\"/${\"MODULE1_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module1\".${LIBEXTENSION}\n  $ENV{BCOMDEVROOT}/bcomBuild/\"Module2\"/${\"MODULE2_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module2\".${LIBEXTENSION}\n\n  # Copy binaries of the third parties of the modules in your working folder (6)\n  $ENV{BCOMDEVROOT}/thirdParties/\"Module1_Dependency\"/${\"MODULE1_DEPENDECY_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module1_Dependency\"${MODULE1_DEPENDECYVERSIONSUFFIX}.${LIBEXTENSION}\n  $ENV{BCOMDEVROOT}/thirdParties/\"Module2_Dependency\"/${\"MODULE2_DEPENDECY_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module2_Dependency\"${MODULE2_DEPENDECYVERSIONSUFFIX}.${LIBEXTENSION}\n\t)\n# define targets (library, install and uninstall)\ndefineTargets(\"executable\" \"${FILES_TO_COPY}\")\n\n\n\nnow, just update the CMakeLists.txt file:\n\n\n\n\n1\nreplace the name of the project with the name of your application,\n\n\n2\nset the version number of your application,\n\n\n3\ncheck if the solarmacros.cmake file exists. This file must have been installed when you launched the installer. If you have decided to build the framework by yourself, this file must have been copied in your ${BCOMDEVROOT} folder when you have built and installed the SolARFramework project.\n\n\n4\nChange nothing here, the binaries required for the SolAR framework will be copied in your working directory.\n\n\n5\nAdd the commands to copy the SolAR modules used by your application in you working directory. If they have been well installed, they should be stored in ${BCOMDEVROOT}/bcomBuild/$\n\n\n6\nAdd the commands to copy the dependencies of the SolAR modules used by your application in you working directory. If they have been well installed, they should be stored in ${BCOMDEVROOT}/thirdParties/$\n\n\n\n\n\n\n\n\n\n\nWe recommend to maintain both a QT project file and a CMake file for any SolAR application.\n\n\n\n\n\n\n\n\nSelect your dependencies\n\n\nCopy in your project folder the packagedependencies.txt file of the pipeline you want to use, and add a dependency to the pipeline:\n\n\npackagedependecies.txt\n\nxpcf|2.2.0|xpcf|artifactory|https://repository.b-com.com/amc-generic\nspdlog|0.14.0|spdlog|thirdParties|https://github.com/SolarFramework/binaries/releases/download\neigen|3.3.5|eigen|thirdParties|https://github.com/SolarFramework/binaries/releases/download\nSolARFramework|0.6.0|SolARFramework|github|https://github.com/SolarFramework/SolarFramework/releases/download\nSolARModuleTools|0.6.0|SolARModuleTools|github|https://github.com/SolarFramework/SolARModuleTools/releases/download\nSolARModuleOpenCV|0.6.0|SolARModuleOpenCV|github|https://github.com/SolarFramework/SolARModuleOpenCV/releases/download\nopencv|3.4.3|opencv|thirdParties|https://github.com/SolarFramework/binaries/releases/download\n(1)\nMyPipeline|x.x.x|MyPipeline|artifactory|https://repository.b-com.com/amc-generic\n\n\n\n\n\n1\nAdd the dependency to the pipeline you want to use, with its version number.\nartifactory refers to .remaken/packages/&lt;yourCompiler&gt;/   folder. You can create a REMAKENROOT variable. All process are made in this folder.\n\n\n\n\n\n\nConfigure your pipeline\n\n\nCopy the configuration file provided with your pipeline in your project folder:\n\n\nMyPipelineConfiguration.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;\n&lt;xpcf-registry autoAlias =&quot;true&quot;&gt;\n\n&lt;module uuid=&quot;94b21be9-703b-4a00-86a9-0db1bf70ef89&quot; name=&quot;MyPipelineModule&quot; path=&quot;$REMAKENROOT/MyPipeline/0.0.1/lib/x86_64/shared&quot; description=&quot;MyPipelineModule&quot;&gt;\n  &lt;component uuid=&quot;855c83b7-f4ec-48ab-8e89-56018ea9e169&quot; name=&quot;MyPipeline&quot; description=&quot;MyPipeline&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot;/&gt;\n    &lt;interface uuid=&quot;b5a6225e-6a91-4050-b298-886f4c17d9d2&quot; name=&quot;IPipeline&quot; description=&quot;IPipeline&quot;/&gt;\n  &lt;/component&gt;\n&lt;/module&gt;\n&lt;module uuid=&quot;15e1990b-86b2-445c-8194-0cbe80ede970&quot; name=&quot;SolARModuleOpenCV&quot; path=&quot;$REMAKENROOT/SolARModuleOpenCV/0.6.0/lib/x86_64/shared&quot; description=&quot;OpenCV&quot;&gt;\n  &lt;component uuid=&quot;5B7396F4-A804-4F3C-A0EB-FB1D56042BB4&quot; name=&quot;SolARCameraOpencv&quot; description=&quot;SolARCameraOpencv&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot;/&gt;\n    &lt;interface uuid=&quot;5DDC7DF0-8377-437F-9C81-3643F7676A5B&quot; name=&quot;ICamera&quot; description=&quot;ICamera&quot;/&gt;\n  &lt;/component&gt;\n&lt;/module&gt;\n&lt;module uuid=&quot;28b89d39-41bd-451d-b19e-d25a3d7c5797&quot; name=&quot;SolARModuleTools&quot; path=&quot;$REMAKENROOT/SolARModuleTools/0.6.0/lib/x86_64/shared&quot; description=&quot;Module Tools&quot;&gt;\n  &lt;component uuid=&quot;85db2f25-4f1c-4e06-9011-e020284bfc4f&quot; name=&quot;SolARBasicSink&quot; description=&quot;A Sink component for a synchronized pose and image pair&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot; /&gt;\n    &lt;interface uuid=&quot;c0d9fee4-d7d7-4866-a6cd-3bacac23316a&quot; name=&quot;ISinkPoseImage&quot; description=&quot;An interface allowing to store a synchronized pose and image from the pipeline to make it available to a third party application&quot; /&gt;\n  &lt;/component&gt;\n  &lt;component uuid=&quot;1e43cda9-7850-4a8a-a32b-f3f31ea94902&quot; name=&quot;SolARBasicSource&quot; description=&quot;A source component for feeding the pipeline with external images&quot;&gt;\n    &lt;interface uuid=&quot;125f2007-1bf9-421d-9367-fbdc1210d006&quot; name=&quot;IComponentIntrospect&quot; description=&quot;IComponentIntrospect&quot; /&gt;\n    &lt;interface uuid=&quot;06e2fc5d-39da-4486-b2a6-1d8bd788fa13&quot; name=&quot;ISourceImage&quot; description=&quot;An interface allowing to store an image from extern source to make it available to the pipeline&quot; /&gt;\n  &lt;/component&gt;\n&lt;/module&gt;\n\n&lt;properties&gt;\n  &lt;configuration component=&quot;SolARCameraOpencv&quot;&gt;\n    &lt;property name=&quot;calibrationFile&quot; type=&quot;string&quot; value=&quot;camera_calibration.yml&quot;/&gt;\n    &lt;property name=&quot;deviceID&quot; type=&quot;UnsignedInteger&quot; value=&quot;0&quot;/&gt;\n  &lt;/configuration&gt;\n&lt;/properties&gt;\n\n&lt;/xpcf-registry&gt;\n\n\n\n\n\nmain.cpp\n\n\nCopy yhe following code in your main.cpp file for testing your SolAR pipeline:\n\n\nmain.cpp\n\n/**\n * information concerning the copyright and license of your SolAR application\n */\n\n#include &lt;boost/log/core.hpp&gt;\n#include &quot;core/Log.h&quot;\n#include &quot;xpcf/xpcf.h&quot;\n\n\n// ADD COMPONENTS HEADERS HERE, e.g #include &quot;SolarComponent.h&quot;\n#include &quot;PipelineManager.h&quot;\n\nusing namespace SolAR;\nusing namespace SolAR::PIPELINE;\n\nnamespace xpcf  = org::bcom::xpcf;\n\n#include &quot;SolARModuleOpencv_traits.h&quot;\n#include &quot;SolARImageViewerOpencv.h&quot;\n#include &quot;SolAR3DOverlayBoxOpencv.h&quot;\n\nusing namespace SolAR;\nusing namespace SolAR::MODULES::OPENCV;\nusing namespace SolAR::api;\n\nint main(){\n\n#if NDEBUG\n    boost::log::core::get()-&gt;set_logging_enabled(false);\n#endif\n\n    LOG_ADD_LOG_TO_CONSOLE();\n    SRef&lt;xpcf::IComponentManager&gt; componentMgr = xpcf::getComponentManagerInstance();\n    componentMgr-&gt;load(&quot;MyPipelineConfiguration.xml&quot;);\n    auto pipeline = componentMgr-&gt;resolve&lt;pipeline::IPipeline&gt;();\n\n    (1)\n    if (pipeline-&gt;init(componentMgr) == FrameworkReturnCode::_SUCCESS)\n    {\n        auto imageViewerResult = componentMgr-&gt;resolve&lt;display::IImageViewer&gt;();\n        auto overlay3DComponent = componentMgr-&gt;resolve&lt;display::I3DOverlay&gt;();\n\n        // Set camera parameters\n        CameraParameters camParam = pipeline-&gt;getCameraParameters();\n        overlay3DComponent-&gt;setCameraParameters(camParam.intrinsic, camParam.distorsion);\n\n        unsigned char* r_imageData=new unsigned char[camParam.resolution.width * camParam.resolution.height * 3];\n        SRef&lt;Image&gt; camImage=xpcf::utils::make_shared&lt;Image&gt;(r_imageData,camParam.resolution.width,camParam.resolution.height,SolAR::Image::LAYOUT_BGR,SolAR::Image::INTERLEAVED,SolAR::Image::TYPE_8U);\n\n        Transform3Df s_pose;\n\n        if (pipeline-&gt;start(camImage-&gt;data()) == FrameworkReturnCode::_SUCCESS)\n        {\n            while (true)\n            {\n                Transform3Df pose;\n\n                sink::SinkReturnCode returnCode = pipeline-&gt;udpate(pose);\n                if(returnCode==sink::SinkReturnCode::_ERROR)\n                    break;\n\n                if ((returnCode == sink::SinkReturnCode::_NEW_POSE))\n                {\n                    for(int i=0;i&lt;3;i++)\n                         for(int j=0;j&lt;3;j++)\n                             s_pose(i,j)=pose(i,j);\n                    for(int i=0;i&lt;3;i++)\n                             s_pose(i,3)=pose(i,3);\n                    for(int j=0;j&lt;3;j++)\n                        s_pose(3,j)=0;\n                    s_pose(3,3)=1;\n                    overlay3DComponent-&gt;draw(s_pose, camImage);\n                }\n\n                if (imageViewerResult-&gt;display(camImage) == SolAR::FrameworkReturnCode::_STOP){\n                    pipeline.stop();\n                    break;\n                }\n             }\n        }\n        delete[] r_imageData;\n    }\n}\n\n\n\n\n\n1\n[white]#when you will load your pipeline, fill in the path to its configuration file and its UUID (the UUID of the component representing the pipeline available in the configuration file).\n\n\n\n\n\n\n\n\n\n\nOn QT Creator, do not forget to run qmake before building your application.\n\n\n\n\n\nBuild and run your application.\n\n\n",
    id: 8
  });
  

index.add({
    title: "create a component",
    content: "Create a component\n\nTable of Contents\n\nCreate a component\n\n\n\nCreate a component\n\n\n\n",
    id: 9
  });
  

index.add({
    title: "C#",
    content: "\nTable of Contents\n\nC#\nNow we AR thinking about that\n\n\n\nC#\n\n\n\n\n\nNow we AR thinking about that\n\n\nWe think about this part.\nUnity Engine gives opportunities to develop pipelines with C#.\nSo we ask ourselves on C# pipelines definitions out of Unity.\n\n\n",
    id: 10
  });
  

index.add({
    title: null,
    content: "\n\n  \n    SolAR\n    SolAR\n    https://solarframework.github.io//\n    \n    Mon, 29 Jul 2019 09:59:23 +0000\n    Mon, 29 Jul 2019 09:59:23 +0000\n    Jekyll v3.5.1\n    \n  \n\n",
    id: 11
  });
  

index.add({
    title: "get modules",
    content: "\nTable of Contents\n\nGet Modules\nGet Modules\n\nGet Modules for Windows 7/10\nGet Modules for Ubuntu 18.04\n\n\n\n\n\nGet Modules\n\n\n\n\n\nGet Modules\n\n\nGet Modules for Windows 7/10\n\nAll you need to do is run (or re-run) SolARFramework Installer.\n\n\nPlease check the installation page\nto get instructions on how to download and run the installer.\n\n\nDuring the installation process, there is the possibility (checkbox) to download the available modules that will be installed in the correct directories for later use.\n\n\n\nGet Modules for Ubuntu 18.04\n\nThe Ubuntu 18.04 installer, described here is an executable script that you can run\nwith the following option:\n\n\n\nfoo@bar:~$ ./SolARFrameworkInstall-0.5.2.sh binaries\n\n\n\nThis command will install all the available SolAR modules into your BCOMDEVROOT folder. Again, refer to Ubuntu 18.04 installation instructions to process.\n\n\n\n",
    id: 12
  });
  

index.add({
    title: "getting started",
    content: "getting started\n\nTable of Contents\n\ngetting started\ngetting started\n\n\n\ngetting started\n\n\n\n\n\ngetting started\n\n\nPlease refer to our Installation section\n\n\n",
    id: 13
  });
  

index.add({
    title: "getting started linux",
    content: "getting started linux\n\nTable of Contents\n\ngetting started linux\nInstall IDE linux\n\nInstall pre-requisites\nInstall QT Creator from QT installer\nSet up environment variables\n\n\nInstall and build SolAR Framework in less than 10 minutes (script BETA VERSION)\nTest your first SolAR program\nLook at your SolARframework folder\nchoose a test program\nconfigure your build\nrun it\nUpdate your SolAR framework source code\n\n\n\ngetting started linux\n\n\n\n\n\nInstall IDE linux\n\n\nInstall your environment following these guidelines:\n(Ubuntu 16.04)\n\n\nInstall pre-requisites\n\nIn a console window, enter the following command:\n\n\n\n\n\nsudo  apt-get install -y python2.7 unzip build-essential git pkg-config qt5-qmake qt4-qmake default-jre curl libqt5core5a libgtk2.0-0 libwebp5 libjasper1 libopenexr22 libopenni0 libdc1394-22 libavcodec-ffmpeg56 libavutil-ffmpeg54 libavformat-ffmpeg56 libswscale-ffmpeg3 qt5-default\n\n\n\n\n\nAnd follow the instructions to complete the installation.\n\n\nCheck your system is up-to-date :\n\n\n\n\nsudo apt update\n\n\nsudo apt dist-upgrade\n\n\n\n\nThen execute  this line :\n\n\n\n\nsudo ln -s /usr/lib/libOpenNI.so.0 /usr/lib/libOpenNI.so\n\n\n\n\n\nInstall QT Creator from QT installer\n\nDownload qt installer for Linux 64 bits here:\nhttp://download.qt.io/official_releases/qt/5.9/5.9.1/qt-opensource-linux-x64-5.9.1.run\n\n\nThen, just run the installer. For this, open a console window and enter the following command:\n\n\n$ cd ~/Downloads\n\n\n(English version)\n\n\nor\n\n\ncd ~/Téléchargements\n\n\n(French version)\n\n\nThen:\n\n\n\n$ chmod 755 qt-opensource-linux-x64-5.9.1.run\n$ sudo ./qt-opensource-linux-x64-5.9.1.run\n\n\n\n\nSet up environment variables\n\n\n\ncreate a BCOMDEVROOT directory on your local hard drive\n\n\nmkdir [path]/BCOMDEVROOT\nmkdir [path]/BCOMDEVROOT/linux\n\n\n\n\n\n\nAdd the following line into your ~/.profile file:\n\n\n\nexport BCOMDEVROOT= \"[path]/BCOMDEVROOT/linux\"\n\n\n\nAlso add the following line to your .bashrc file:\n\n\n\nexport PATH=/opt/Qt5.9.1/5.9/gcc_64/bin/:/opt/Qt5.9.1/Tools/QtCreator/bin/:$PATH\n\n\n\nForce the system to take those paths in account:\n\n\n\n\nsource ~/.profil\n\n\nsource .bashrc\n\n\n\n\n\n\n\nInstall and build SolAR Framework in less than 10 minutes (script BETA VERSION)\n\n\n\n\n\n\n\n\nThis section indicates how to use the script implemened for SolAR to instala and build every SolAR code and make your environment ready to contribute in about 5 minutes. Some persons have problems with this script, so that we offer you an alternative in the next section (but will take more time) Please feel free to test the script and give your feedbacks (sucess or not, your computer configuration) so that we can improve it !\n\n\n\n\n\n\n\nCreate a SolAR directory\n\n\nLet&#8217;s move to this directory.\n\n\n\n\n\n\ncd SolAR\n\n\n\n\n\n\nUsing a git client, clone the following repository on the develop branch:\n\n\n\n\n\n\n\ngit clone  https://github.com/SolarFramework/build-scripts\n\n\n\n\n\n\n\nOpen a terminal console, and go to your SolAR directory\n\n\n\n\n\n\nExecute the following command:\n\n\n./build-scripts/fromscratch.sh\n\n\n\n\n\n\n\n\nTest your first SolAR program\n\n\nOnce you have installed SolAR, you are able to run your first SolAR program.\n\n\n\n\nLook at your SolARframework folder\n\n\nCheck you SolARframrwork directory is filled in with SolARframework and SolAR modules.\n\n\n\n\nchoose a test program\n\n\nYou can for example open  the SolARDescriptorMatcher program.\nFor this program, and for each test, you can choose a dynamic or a static version.\nLet&#8217;s see with the static version here.\n\n\n\n\nOpen the SolARContainerOpenCV\\tests\\SolARDescriptorMatcher\\static folder.\n\n\n\n\nThere are source files, and a packagedepencies.txt files, precizing which third parties are used.\n\n\n\n\n\n\n\n\npackagedependencies.txt is the file used by the pipeline manager to load third parties.\n\n\n\n\n\n\n\n\nJust have a look at packagedepencies.txt, it contains the definition of third parties used by this program.\n\n\n\n\n\n\nSolARFramework|1.0.0|SolARFramework|bcomBuild|url_repo_artifactory\n\n\nSolARContainerOpenCV|1.0.0|SolARContainerOpenCV|bcomBuild|url_repo_artifactory\n\n\nxpcf|1.0.0|xpcf|bcomBuild|http://repository.b-com.com/\n\n\nboost|1.64.0|boost|thirdParties|http://repository.b-com.com/\n\n\nopencv|3.2.0|opencv|thirdParties|http://repository.b-com.com/\n\n\n\n\n\n\nJust remind that the third parties shoule be available in your SolARFramework\\SolARLibraries\\thirdParties repository.\n\n\nOpen the pro file in your favorite IDE.\n\n\n\n\n\n\n\nconfigure your build\n\n\nConfigure the project build, add the \"make install\" line as described in this image.\n\n\n\n\n\nAdd also an image in arguments, so that the program can track the image in the camera vision.\n\n\n\n\n\n\n\nrun it\n\n\nThen build and tun the program.\n\n\n\n\n\n\n\n\n\n\n\nif you have problems for compiling or execute a program, feel free to contact us.\n\n\n\n\n\n\n\nUpdate your SolAR framework source code\n\n\nOpen a terminal console, and go to your SolAR directory\n\n\nUpdate code source.\n\n\nFrom your SolAR folder, update the develop branches of the three following git repositories: SolarFramework, SolarContainerOpenCV and xpcf.\nTo do so, repeat the following commands inside the three folders, SolarFramework, SolarContainerOpenCV and xpcf:\n\n\n\n$ git checkout develop\n$ git pull origin develop\n$ git submodule update --init --recursive\n$ git submodule foreach git checkout develop\n$ git submodule foreach git pull origin develop\n\n\n\nRe-build SolAR\n\n\nRun:\n\n\n\n./build-scripts/build.sh debug\n\n\n\nand/or\n\n\n\n./build-scripts/build.sh release\n\n\n\n",
    id: 14
  });
  

index.add({
    title: "getting started windows",
    content: "getting started windows\n\nTable of Contents\n\ngetting started windows\nInstall IDE windows\n\nPre-requisites\nInstall QT creator\nCheck your QT configuration\nInstall Visual Studio\nCheck Visual Studio C /C ++compiler is installed correctly\n\n\nInstall and build SolAR Framework (universal procedure)\n\nPre requisites\n\n\ndirectories\ndownloads\nbuild projects\n\nLook at your SolARframework folder\n\n\nchoose a test program\nUpdate and re-build SolAR\n\n\n\ngetting started windows\n\n\n\n\n\nInstall IDE windows\n\n\nPre-requisites\n\nInstall pkgconfig, sourcetree, python3 and jre.\n\n\n\n\n\npkg-config\n\n\npkg-config is a helper tool used when compiling applications and libraries.\n\n\n\nDownload the setup program here:\nhttps://github.com/SolarFramework/binaries/releases/download/pkgconfig%2Fwin/Setup_pkg-config.exe\n\n\n\n\n\n\n\nSourcetree\n\n\nSourcetree is a free git client for windows and mac.\n\n\n\nDownload it on the following web site:\n https://www.sourcetreeapp.com/\nDuring Sourcetree installation, choose to download the embedded version of git program.\n\n\n\n\n\n\n\npython3\n\n\nPython is a widely used high-level programming language for general-purpose programming. Python3 is requiredby SolAR in order to create new components, based on templates.\n\n\n\nDownload the latest version of python3 for windows here:\nhttps://www.python.org/downloads/\n\n\n\n\n\n\n\njre\n\n\nJava Runtime Environment, or JRE, is required in order to download third parties libraries based on your environment.\n\n\n\nYou can download JRE here:\nhttp://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html\n\n\n\n\n\n\n\n\nYou can use or QT creator, or Visual.\n\n\n\n\n\n\n\n\nQT creator is recommended.\n\n\n\n\n\n\nInstall QT creator\n\nInstall QT community by downloading and launching the following file:\n\n\n\nhttp://download.qt.io/official_releases/online_installers/qt-unified-windows-x86-online.exe\n\n\n\nDuring installation choose a minimal QT 5.9.0 with msvc2015 64bits, and QT Tools→QT creator (default selection) only\n\n\n\nCheck your QT configuration\n\nOpen the \"tools/options\" window and section \"build and run\"; please check compiler and debugger is installed. Every tab should be filled in.\n\n\n\n\nCompiler\n\n\n\n\n\n\n\n\n\n\n\nDebugger\n\n\n\n\n\n\n\n\n\nIf not, make sure your Visual installation is complete (see sections just above).\n\n\nIf Qt does not autodetect the windows debugger, you might need to manually install the debugging tools for Windows, as stated on  [http://doc.qt.io/qtcreator/creator-debugger-engines.html this Qt Page].\nYou can get the Windows Driver Kit that contains the debugging tools from [https://developer.microsoft.com/en-us/windows/hardware/windows-driver-kit this page].\n\n\n\nInstall Visual Studio\n\nYou can either install Visual Community 2017 (adapted for OpenSource) or install Visual Studio 2017.\n\n\n\n\n\n\n\n\nCheck Visual Studio C /C ++compiler is installed correctly\n\nCreate a new C++ project and follow steps advised by the prompt.\n\n\nIf the compiler is not installed, you will have an option to install it right from the new project window.\n\n\nYou should verify you are able to run a console application \"hello world\" in C++.\n\n\n\n\n\n\n\nIf you have a problem when running Qmake, this is probably due a mismatck between your Qt installation and your Visual Studio version.\n\n\ndo this :\n\n\n\n* cd C:\\Qt\\{your qt version -for instance 5.11.1}\n* dir\n\n\n\nYou should see a directory named msvc2017_64 if you ave installed VS2017, and msvc2015_64 if you installed VS2015.\nI this is missing, please do this :\n\n\n\n. cd c:\\\\MaintenanceTool.exe\n. follow the installation step to indicate the MSVC version missing, as you can see in this screenshot :\n\n\n\n\n\n\n\n\n\n\n\nInstall and build SolAR Framework (universal procedure)\n\n\n\n\n\n\n\n\nThis section helps you to install all code needed for contribution to SolAR framework. It helps you do the same as the automatic script \"fromscratch\" in the getting started page, but doing it by yourself, in case the script does not work on your computer.\nPlease feel free to give your feedbacks !\n\n\n\n\n\nPre requisites\n\nTo download SolAR for contribution, please first use the setup tool in the \"use it\" section of this web site setup\n\n\nYou will then use the SolARFramework directory created to download the SolAR Source Code.\n\n\n\n\n\ndirectories\n\n\n\n\nCheck you have a SolAR directory\n\n\n\n\nThis will be used for your development. All code concerning SolARFramework will be there.\n\n\n\n\ncheck you have a BCOMDEVROOT env variable on your local hard drive\n\n\n\n\nThis will be used for your compilation, to know where to find third parties.\n\n\n\n\ndownloads\n\n\nPlease download following projects, using or a GIT bash, or a graphic GIT tool as sourcetree, or by downloading on the github SolarFramework site:\n\n\n\n\n\n\n\n\n\n\nName\nGitHub url\n\n\nFramework\nSolARframework\nhttps://github.com/SolarFramework/SolARFramework\n\n\nModules\nSolARModuleOpenCV\nhttps://github.com/SolarFramework/SolARModuleOpenCV\n\n\nSolARModuleTools\nhttps://github.com/SolarFramework/SolARModuleTools\n\n\nThird parties\nCompiled third parties\nPlease refer to the Use it/ setup section ../use_it/setup\n\n\n\n\n\n\n\n\n\n\nyou have to choose to checkout on the master or on the develop branch. If you want to contribute, prefer the \"develop\" branch.\n\n\n\n\n\n\n\nbuild projects\n\n\nYou have to compile those projects. Please open each of them in QT Creator (is recommended) and do this:\n\n\n\n\nclick on \"run qmake\"\n\n\nconfigure the build option with the option \"make\" + install in parameters (it will install the project in the BCOMDEVROOT directory)\n\n\n\n\n\n\n\n\n\n\n\nclick on \"build\"\n\n\n\n\n\n\n\n\n\n\n\n\nName\nProjects\n\n\nFramework\nSolARframework\nSolARFramework/SolARFramework.pro\n\n\nModules\nSolARModuleOpenCV\nModules/SolARModuleOpenCV/SolARModuleOpenCV.pro\n\n\nSolARModuleTools\nModules/SolARModuleTools/SolARModuleTools.pro\n\n\n\n\nSome other projects are interesting to build and test, if you want to learn more about SolAR.\n\n\n\n\n\n\n\n\n\n\nName\nTest projects\n\n\nTest projects\nImageConvertor\nModules/SolARModuleOpenCV/tests/SolARImageConvertor/dynamic/SolARImageConvertorOpencvTest.pro\n\n\nImageLoader\nModules/SolARModuleOpenCV/tests/SolARImageLoader/dynamic/SolARImageOpenCVDynTest.pro\n\n\nCameraCalibration\nModules/SolARModuleOpenCV/tests/SolARCameraCalibration/static/SolARCameraCalibration.pro\n\n\n\n\nLook at your SolARframework folder\n\n\n\n\nYou can see you have installed:\n\n\n\n\nthe Core framework ins SolARFramework directory\n\n\na module based on OpenCV  .\n\n\na module based on SolAR developments\n\n\n\n\nThe OpenCV container is a first implementation based on SolAR API.\nin this directory, you will see some features and tests.\n\n\n\n\n\n\n\n\nchoose a test program\n\n\nYou can for example open  the SolARDescriptorMatcher program.\nFor this program, and for each test, you can choose a dynamic or a static version.\nLet&#8217;s see with the static version here.\n\n\n\n\nOpen the SolARContainerOpenCV\\tests\\SolARDescriptorMatcher\\static folder.\n\n\n\n\nThere are source files, and a packagedepencies.txt files, precizing which third parties are used.\n\n\n\n\n\n\n\n\npackagedependencies.txt is the file used by the pipeline manager to load third parties.\n\n\n\n\n\n\n\n\nJust have a look at packagedepencies.txt, it contains the definition of third parties used by this program.\n\n\n\n\n\n\nSolARFramework|1.0.0|SolARFramework|bcomBuild|url_repo_artifactory\n\n\nSolARContainerOpenCV|1.0.0|SolARContainerOpenCV|bcomBuild|url_repo_artifactory\n\n\nxpcf|1.0.0|xpcf|bcomBuild|http://repository.b-com.com/\n\n\nboost|1.64.0|boost|thirdParties|http://repository.b-com.com/\n\n\nopencv|3.2.0|opencv|thirdParties|http://repository.b-com.com/\n\n\n\n\n\n\nJust remind that the third parties shoule be available in your SolARFramework\\SolARLibraries\\thirdParties repository.\n\n\nOpen the pro file in your favorite IDE.\n\n\n\n\n\n\n\nUpdate and re-build SolAR\n\n\nPlease use your git tool to update the source code.\n\n\n\n\ngit fetch\n\n\ngit pull\n\n\n\n\nRebuild and explained previously\n\n\n",
    id: 15
  });
  

index.add({
    title: "hidden",
    content: "\nTable of Contents\n\nHidden\ncreate the SolAR installer\nOther tools\n\n\n\nHidden\n\n\n\n\n\ncreate the SolAR installer\n\n\n\n\n\n\n\n\nthis installs binaries and samples, as indicated in the \"use it\" part of the &lt;SolAR&gt; website.\n\n\n\n\n\nYou have to :\n\n\n\n\ninstall inno setup : http://www.jrsoftware.org/isdl.php#stable\n\n\ncreate a directory for your setup. Example called \"setup\".\n\n\nplease get the iss file to create the Solar installer there : https://raw.githubusercontent.com/SolarFramework/binaries/master/inno-setup-SolarLibraries.iss\n\n\nupdate what will be installed for SolAR :\n# SolAR Libraries\n# third parties\n# SolAR Samples\n\n\n\n\nUpdate Solar libraries\n\nVersionning\n\nFirst, please take care of versionning the code corresponding to your installer:\n\n\n\n\nplease tag the source code\n\n\nplease replace the version in all cmakelist.txt and/or the .pro files of the SolAR libraries with the good version\n\n\n\n\n\n\nTARGET = SolARFramework\nINSTALLSUBDIR = bcomBuild\nFRAMEWORK = $$TARGET\nVERSION=G.R.C\n\n\n\n\n\n\nplease also replace the version of the library you need in the packagedependencies.txt files before compiling\n\n\n\n\n\n\nSolARFramework|G.R.C|SolARFramework|bcomBuild|url_repo_artifactory\n\n\n\n\n\nCompile\n\nSecondly, update, compile and store binaries in a directory called \"installeurs\" under your \"setup directory\".\n\n\n\n\n\n\n\n\nplease note that installers are based on master or develop branch. This means a merge workd, validation of code muste be done before generating the installer.\n\n\n\n\n\nYou can test the installer creation thanks to the content here : \\\\filer.b-com.local\\share\\common\\PROJECTS\\ARGO\\atadrist\\SolARSETUP\nimage::images/installeurcontent.png[https://b-com.com/en]\n\n\n\n\nUpdate third parties\n\nto be completed\n\n\n\nUpdate Solar Samples\n\nGet the Samples\n\n\n\n\n\nOther tools\n\n\n\n",
    id: 16
  });
  

index.add({
    title: "how it works",
    content: "How it works\n\nTable of Contents\n\nHow it works\n\n\n\nHow it works\n\n\n\n",
    id: 17
  });
  

index.add({
    title: "Community",
    content: "\nTable of Contents\n\nCommunity\nCommunity\nContact\n\n\n\nCommunity\n\n\n\n\n\nCommunity\n\n\nThere are several ways to contribute to SolAR framework.\n\n\nYou can :\n\n\n\n\ncontribute to Core framework, by defining API, architecture, framework tools &#8230;&#8203; this typically needs software engineering and architecture skills.\n\n\ncontribute to Components, by creating a new SolAR component, that can be used in a pose estimation solution&#8230;&#8203; this typically needs computer vision skills (and software skills).\n\n\n\n\nPlease contribute!\nRefer to our contribution workflow section\n\n\n\n\nContact\n\n\nFor any request, please contact us.\n\n\n",
    id: 18
  });
  

index.add({
    title: "Create",
    content: "\nTable of Contents\n\nCreate\nWhy create SolAR components ?\nWhat is a SolAR component ?\nwhat is a SolAR module ?\n\n\n\nCreate\n\n\n\n\n\nWhy create SolAR components ?\n\n\nThe SolAR framework has been designed to easily assemble a set of SolAR vision components to build vision pipelines adressing AR services. To ensure the interoperability, a concrete vision component must implement one of the more than 50 interfaces currently defined in the SolAR framework. Thus, a SolAR pipeline assembler can easily choose and connect SolAR vision components together to assemble a vision pipeline, and he can easily swap on component by another one to improve or adapt the pipeline to a dedicated device or task. This modularity aims at creating an ecosystem where researchers and vision expert will be able to easily share, promote or make their research results accessible to a large community to help the adoption of augmented reality.\n\n\n\n\nWhat is a SolAR component ?\n\n\nEach component processes input data and streams the processing output to feed the input of other components. Thus, each processing can be performed in parallel by buffering data between components to optimize the global vision pipeline. Components exchange data with strong types defined by the data structures available in the framework to ensure strong interfaces and avoid the connection of components with incompatible data.\n\n\nAlso, each concrete implementation of a SolAR component can define its own parameters to provide configuration genericity. This configuration is very simple with SolAR and allow to configure the pipeline at load time thanks to a simple xml file, and even at runtime through the SolAR API.\n\n\n\n\nwhat is a SolAR module ?\n\n\nAs it is difficult to manage tens, hundreds or even thousands of components independently (i.e. one shared library per component), SolAR components must be grouped into SolAR modules (i.e. a unique shared library embedded a set of concrete implementation of SolAR components). Thus, it will be much more easy to manage the publication of modules which can be organized according to the creator&#8217;s choice (a module dedicated to a third party such as OpenCV, to a research institution, to a company, to a dedicated pipeline assembly, etc.).\n\n\n",
    id: 19
  });
  

index.add({
    title: "Use",
    content: "Use\n\nTable of Contents\n\nUse\nOverview\nHow to contribute\n\n\n\nUse\n\n\n\n\n\nOverview\n\n\nSolAR is a opensource framework designed to solve computer vision problems.\n\n\nThis part of the website is to help developers be successful with our framework and create AR applications.\n\n\n\n\n\nFor the moment :\n\n\n\nUnity3D engine support\n\n\n\n\n\nComing soon :\n\n\n\nC++ native support\n\n\nC# native support\n\n\n\n\n\nIn the future :\n\n\n\nAndroid platform support.\n\n\n\n\n\n\n\n\n\nHow to contribute\n\n\nPlease refer to our contribution workflow section\n\n\n",
    id: 20
  });
  

index.add({
    title: "Assemble",
    content: "\nTable of Contents\n\nAssemble\nWhat is a SolAR vision pipeline ?\nWhy use SolAR to assemble vision pipelines for AR ?\nHow it works ?\n\n\n\nAssemble\n\n\n\n\n\nWhat is a SolAR vision pipeline ?\n\n\nThe SolAR framework has been designed to simplify the design of vision pipelines adressing augmented reality applications. A SolAR vision pipeline is a chain of connected vision processing components generally executed in parallel. For instance, a SolAR vision pipeline may take as input images captured by one or more cameras as well as data from an inertial sensor. These data will be processed in series by a set of SolAR components to estimate the pose of an AR device.\n\n\n\n\nWhy use SolAR to assemble vision pipelines for AR ?\n\n\nThe SolAR framework has been designed from the beginning to clearly separate tasks and roles and offer modularity. Indeed, a vision pipeline assembler will be able to focus on the pipeline design without worrying about the implementation of components, the intergation of existing computer vision libraries or the integration of the pipeline in an AR service.\n\n\nA vision pipeline assembler can easily:\n\n\n\n\ndownload existing SolAR vision components created and published by the SolAR component creators,\n\n\nassemble the vision components to create a vision pipeline,\n\n\nupdate the vision pipeline architecture,\n\n\nswap components by other ones,\n\n\nconfigure components,\n\n\ntest the vision pipeline,\n\n\npublish it for AR pipeline users who will develop AR services.\n\n\n\n\n\n\nHow it works ?\n\n\nThe SolAR framework handles everything that will allow a modular assembling of a vision pipeline:\n\n\n\n\nSolAR Data Structures define the information that flows in a pipeline and are exchanged between components.\n\n\nSolAR Component Interfaces define for now more than 50 standardized abstract interfaces for the different categories of vision processing components required to implement vision pipelines (e.g. keypoint detector, descriptor extractor, features matching, PnP and optimization). This unified interface is required to ensure interoperability between components allowing to easily swap one with another to improve the final vision pipeline.\n\n\nSolAR Components are concrete implementations of vision processing components compliant with SolAR components interfaces. Several components can implement the same SolAR component interface. In general, these components are created by wrapping computer vision libraries that could be either open-source (OpenCV, PCL, ROS, etc.) or proprietary. Each component can define its own parameters that will be used to fine tune the vision pipeline.\n\n\nSolAR Modules are shared libraries embedding a set of SolAR components to ease their management and publication.\n\n\nComponent Manager based on XPCF, a lightweight cross platform component framework similar to the well known COM model. it manages the introspection of SolAR modules and components, it provides an \"in-code\" dependency injection factory to create concrete component instance and bind them to a abstract SolAR component interface, it handles the loading of modules and components at runtime, it provides interfaces for load of pipeline and used modules and components at run-time, etc. XPCF is a third party developped by b&lt;&gt;com under Apache licencse 2.0 (more information about XPCF is available on GitHub).\n\n\n\n\n",
    id: 21
  });
  

index.add({
    title: "Home",
    content: "\n  \n    \n      \n    \n  \n\n\n  \n    What is SolAR?\n    SolAR is an open-source software development kit dedicated to Augmented Reality. \n    \n    SolAR is modular and evolutive. It allows, in various contexts of use, the construction of customized computer vision processing chains addressed to Augmented Reality applications.\n    \n    SolAR contains:\n      \n        \n           interfaces promoting interoperability\n           computer vision components constructed from third-party bricks\n           plugins for third-party applications\n        \n      \n    \n  \n  \n    Who need SolAR?  \n    According to your needs, SolAR framework offers several user profiles:\n  \n\n\n  \n    \n      \n        \n            \n            \n                \n          \n        \n      \n      \n        SolAR pipeline user\n      \n      \n          As an AR service designer, I can use a prebuild standalone or Unity integrated AR pipeline...\n      \n    \n  \n  \n    \n      \n        \n          \n              \n               \n          \n        \n      \n      \n        SolAR pipeline assembler\n      \n      \n          As an AR pipeline developer, I can assemble components to build my own customized AR pipeline...\n      \n    \n  \n  \n  \n    \n      \n        \n          \n           \n        \n      \n    \n    \n      SolAR component developer\n    \n    \n        As an SolAR component developer, I can create customized bricks responding to specific needs...\n    \n    \n  \n\n\n  \n    \n      SolAR framework Overview\n      \n        \n          Your browser does not support the video tag.\n        \n      \n    \n  \n\n \n  \n    How to contribute to SolAR?\n    Join the community, find out how you can contribute to the framework according to your profile and skills and participate to the augmented reality adoption. \n    \n    \n      \n    \n      \n        \n          \n              \n                    \n          \n        \n      \n      \n        SolAR framework contributor\n      \n      \n          As an SolAR framework developer, I can contribute to SolAR expansion...\n      \n    \n  \n\n\n",
    id: 22
  });
  

index.add({
    title: "install",
    content: "\nTable of Contents\n\nInstall\nInstall\n\nInstall SolAR version 0.5.2 - Windows 7/10\nInstall SolAR version 0.5.2 - Ubuntu 18.04\n\n\n\n\n\nInstall\n\n\n\n\n\nInstall\n\n\nInstall SolAR version 0.5.2 - Windows 7/10\n\nA SolAR Framework Windows installer is provided in order to quickly install:\n\n\n\n\nthe SolARFramework library (debug and release modes) and interfaces (C++ header files)\n\n\nSolAR modules libraries (debug and release modes) and interfaces (C++ header files)\n\n\nthe required third party libraries (debug and release modes) and third party interfaces (C++ header files)\n\n\nthe QT creator pre-requisites\n\n\nSolAR samples (C++ sample code)\n\n\n\n\nThe installer can be downloaded here:\n\n\nhttps://github.com/SolarFramework/binaries/releases/download/SolARFramework-installer%2Fwin/SolarFramework-installer-0.5.2.exe\n\n\nUsing the installer is straightforward:\n\n\n\n\ndownload then launch the installer\n\n\nread then accept the license agreement, then press \"Next\"\n\n\n\n\n\n\n\n\n\n\nPlease close QT Creator, if running, on your computer, before executing the installer.\n\n\n\n\n\n\n\n\n\n\n\n\nselect the destination installation folder (default is: C:\\SolARFramework).\n\n\n\n\n\n\n\n\n\n\n\nselect the components you want to install.\n\n\n\n\n\n\n\n\n\nRegarding this last step, you have the choice between:\n\n\n\n\nSolAR libraries: this will install SolAR Framework and SolAR modules libraries and interfaces only.\n\n\nQT creator dependencies: this will install a windows version of pkg-config program, used by SolAR build scripts to generate Makefiles under QT creator\n\n\nThird party libraries: this will install the following third party libraries and interfaces: fbow, freeglut, opencv, boost, eigen, spdlog and xpcf\n\n\nSources: this will install a sources folder containing SolAR Framework, Modules and Samples sources.\n\n\nSample code: this will create a Samples folder under your SolARFramework installation folder. This folder contains sample C++ projects that you can use\nto learn the basics of SolAR.\n\n\nBuild scripts: this will create a build-scripts folder containing bash scripts to manage git repositories and to compiles sources\n\n\nExecutable Samples: this will create a Samples folder containing 4 executable samples (fiducial marker, natural image marker, triangulation based on 2 images and a SLAM sample)\n\n\n\n\nPlease use the default values: it will install everything you need to use SolAR, especially if you want to first test a sample code.\n\n\n\nInstall SolAR version 0.5.2 - Ubuntu 18.04\n\n\n\ndownload both files SolARFramework-0.5.2.tar.xz and SolARFrameworkInstall-0.5.2.sh at the following address:\nhttps://github.com/SolarFramework/binaries/releases/tag/SolARFramework-installer%2F0.5%2Fubuntu\n\n\nopen a terminal to enter the command lines described below\n\n\nyou must have a BCOMDEVROOT environment variable defined, and this variable must point\nto a directory where all binaries (built libraries and third parties libraries) will be copied\n\n\nfoo@bar:~$ export BCOMDEVROOT=[binaries directory path]\n\n\n\n\ngo to the directory where you have saved SolARFramework-0.5.tar.xz and SolARFrameworkInstall-0.5.sh\n\n\nrun the following commands\n\n\nfoo@bar:~$ chmod 755 SolARFrameworkInstall-0.5.2.sh\nfoo@bar:~$ ./SolARFrameworkInstall-0.5.2.sh all\n\n\n\n\nas a result, a SolARFramework directory should now be present under the folder where you ran\nthe installer script. This directory should contain three directories, build-scripts, samples and sources\n\n\nfoo@bar:~$ ls SolARFramework\nbuild-scripts  samples  sources\n\n\n\n\nin your terminal you can now run samples (executable) contained under the samples/ folder\n\n\nyou can also browse SolAR sources under the sources folder\n\n\nyou will be able to update your source tree, running the following command:\n\n\nfoo@bar:~$ ./build-scripts/updateGit.sh develop\n\n\n\n\nfinally you will be able to compile the source code:\n\n\nfoo@bar:~$ ./build-scripts/cmake-build.sh all\n\n\n\n\nnote that in order to run samples your LD_LIBRARY_PATH needs to contain current directory (\"./\"). This can be performed by running the following command:\n\n\nfoo@bar:~$ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH\n\n\n\n\n\n\n\n",
    id: 23
  });
  

index.add({
    title: "How to install",
    content: "\nTable of Contents\n\nInstall\nHow to install\n\nInstall SolAR version 0.5.2 - Windows 7/10\nInstall SolAR version 0.5.2 - Ubuntu 18.04\n\n\nNext Steps\n\n\n\nInstall\n\n\n\n\n\nHow to install\n\n\nPrior to start, be sure that SolAR and your working environment are correctly configured as explained in the following :\n\n\nInstall SolAR version 0.5.2 - Windows 7/10\n\nA SolAR Framework Windows installer is provided in order to quickly install:\n\n\n\n\nthe SolARFramework library (debug and release modes) and interfaces (C++ header files)\n\n\nSolAR modules libraries (debug and release modes) and interfaces (C++ header files)\n\n\nthe required third party libraries (debug and release modes) and third party interfaces (C++ header files)\n\n\nthe QT creator pre-requisites\n\n\nSolAR samples (C++ sample code)\n\n\n\n\nThe installer can be downloaded here:\n\n\nhttps://github.com/SolarFramework/binaries/releases/download/SolARFramework-installer%2Fwin/SolarFramework-installer-0.5.2.exe\n\n\nUsing the installer is straightforward:\n\n\n\n\ndownload then launch the installer\n\n\nread then accept the license agreement, then press \"Next\"\n\n\n\n\n\n\n\n\n\n\nPlease close QT Creator, if running, on your computer, before executing the installer.\n\n\n\n\n\n\n\n\n\n\n\n\nselect the destination installation folder (default is: C:\\SolARFramework).\n\n\n\n\n\n\n\n\n\n\n\nselect the components you want to install.\n\n\n\n\n\n\n\n\n\nRegarding this last step, you have the choice between:\n\n\n\n\nSolAR libraries: this will install SolAR Framework and SolAR modules libraries and interfaces only.\n\n\nQT creator dependencies: this will install a windows version of pkg-config program, used by SolAR build scripts to generate Makefiles under QT creator\n\n\nThird party libraries: this will install the following third party libraries and interfaces: fbow, freeglut, opencv, boost, eigen, spdlog and xpcf\n\n\nSources: this will install a sources folder containing SolAR Framework, Modules and Samples sources.\n\n\nSample code: this will create a Samples folder under your SolARFramework installation folder. This folder contains sample C++ projects that you can use\nto learn the basics of SolAR.\n\n\nBuild scripts: this will create a build-scripts folder containing bash scripts to manage git repositories and to compiles sources\n\n\nExecutable Samples: this will create a Samples folder containing 4 executable samples (fiducial marker, natural image marker, triangulation based on 2 images and a SLAM sample)\n\n\n\n\nPlease use the default values: it will install everything you need to use SolAR, especially if you want to first test a sample code.\n\n\n\nInstall SolAR version 0.5.2 - Ubuntu 18.04\n\n\n\ndownload both files SolARFramework-0.5.2.tar.xz and SolARFrameworkInstall-0.5.2.sh at the following address:\nhttps://github.com/SolarFramework/binaries/releases/tag/SolARFramework-installer%2F0.5%2Fubuntu\n\n\nopen a terminal to enter the command lines described below\n\n\nyou must have a BCOMDEVROOT environment variable defined, and this variable must point\nto a directory where all binaries (built libraries and third parties libraries) will be copied\n\n\nfoo@bar:~$ export BCOMDEVROOT=[binaries directory path]\n\n\n\n\ngo to the directory where you have saved SolARFramework-0.5.tar.xz and SolARFrameworkInstall-0.5.sh\n\n\nrun the following commands\n\n\nfoo@bar:~$ chmod 755 SolARFrameworkInstall-0.5.2.sh\nfoo@bar:~$ ./SolARFrameworkInstall-0.5.2.sh all\n\n\n\n\nas a result, a SolARFramework directory should now be present under the folder where you ran\nthe installer script. This directory should contain three directories, build-scripts, samples and sources\n\n\nfoo@bar:~$ ls SolARFramework\nbuild-scripts  samples  sources\n\n\n\n\nin your terminal you can now run samples (executable) contained under the samples/ folder\n\n\nyou can also browse SolAR sources under the sources folder\n\n\nyou will be able to update your source tree, running the following command:\n\n\nfoo@bar:~$ ./build-scripts/updateGit.sh develop\n\n\n\n\nfinally you will be able to compile the source code:\n\n\nfoo@bar:~$ ./build-scripts/cmake-build.sh all\n\n\n\n\nnote that in order to run samples your LD_LIBRARY_PATH needs to contain current directory (\"./\"). This can be performed by running the following command:\n\n\nfoo@bar:~$ export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH\n\n\n\n\n\n\n\n\n\nNext Steps\n\n\nIn the context of SolAR, a pipeline is a set of connected actions that takes on one hand a camera frame.\nActions are performed via C++ methods with dedicated input/output parameters. Generally output parameters of one action serve as input parameters for subsequent actions, hence the term pipeline.\n\n\nThe SolAR framework provides a comprehensive list of usable methods that are located in the API directory.\n\n\nAlso SolAR provides a set of modules that implement the said methods.\n\n\nTo build a pipeline, it is necessary to identify what are the required actions and which modules/components are available to perform them.\n\n\nSection \"Get Modules\" explains this in detail.\n\n\nOnce it is done, due to the use of XPCF, the three main items to take care of are :\n\n\n\n\na configuration file\n\n\na dependencies description file\n\n\na build configuration file (.pro or cmake)\n\n\n\n\n",
    id: 24
  });
  

index.add({
    title: null,
    content: "// builds lunr\nvar index = lunr(function () {\n  this.field('title')\n  this.field('content', {boost: 10})\n  this.ref('id')\n});\n\n{% assign count = 0 %}\n{% for page in site.pages %}\nindex.add({\n    title: {{page.title | jsonify}},\n    content: {{page.content | strip_html | jsonify}},\n    id: {{count}}\n  });\n  {% assign count = count | plus: 1 %}\n{% endfor %}\n\n\n{% for collection in site.collections %}\n  {% assign name = collection.label %}\n  {% assign sorted_pages = site[name] | sort:\"weight\" %}\n  {% for page in sorted_pages %}\n\n    index.add({\n      title: {{page.title | jsonify}},\n      content: {{page.content | strip_html | jsonify}},\n      id: {{count}}\n    });\n    {% assign count = count | plus: 1 %}\n\n  {% endfor %}\n{% endfor %}\n\n\nvar store = [];\n{% for page in site.pages %}\n  {% capture link %}{{ site.url }}{{ site.baseurl }}{{ page.url }}{% endcapture %}\nstore.push({\"title\": {{page.title | jsonify}},\n  \"link\": {{ link | jsonify }}\n});\n{% endfor %}\n\n{% for collection in site.collections %}\n  {% assign name = collection.label %}\n  {% assign sorted_pages = site[name] | sort:\"weight\" %}\n  {% for page in sorted_pages %}\n    {% capture link %}{{ site.url }}{{ site.baseurl }}{{ page.url }}{% endcapture %}\n    store.push({\"title\": {{page.title | jsonify}},\n      \"link\": {{ link | jsonify }}\n    });\n  {% endfor %}\n{% endfor %}\n\nfunction searchAndDisplay(query){\n  var resultdiv = $('#results');\n  var result = index.search(query);\n  // Show results\n  resultdiv.empty();\n  // Add status\n  resultdiv.prepend('Found '+result.length+' result(s)');\n  // Loop through, match, and add results\n  for (var item in result) {\n    var ref = result[item].ref;\n    var searchitem = ''+store[ref].title+'';\n    resultdiv.append(searchitem);\n  }\n}\n\n// builds search\n$(document).ready(function() {\n    var query = (decodeURI(location.search).split(\"q\" + '=')[1] || '').split('&')[0];\n    var formattedQuery = query.split(\"+\").join(\" \");\n    searchAndDisplay(formattedQuery);\n\n    $('input#search').on('keyup', function () {\n      var query = $(this).val();\n      searchAndDisplay(query);\n    });\n});\n",
    id: 25
  });
  

index.add({
    title: "Made with SolAR",
    content: ":page-layout: _auto\n= Made with SolAR\n:showtitle:\n:page-title: Made with SolAR\n:page-description: Made with SolAR\n:page-liquid:\n\nTo be done\n",
    id: 26
  });
  

index.add({
    title: null,
    content: "/* colors part */\n$blue: #00bee6;\n$purple: #be64ff;\n$red: #ff5050;\n$green: #00cd78;\n$yellow: #ffb400;\n$gray: #666666;\n$transparent-blue: rgba(0, 190, 230, .5);\n$transparent-purple: rgba(190, 100, 255, .5);\n$transparent-red: rgba(255, 80, 80, .5);\n$transparent-green: rgba(0, 205, 120, .5);\n$transparent-yellow: rgba(255, 180, 0, .5);\n$transparent-gray: rgba(255, 255, 255, .5);\n\nhtml {\n  min-height: 100%;\n}\n\nbody {\n   font-family: Arial, sans-serif;\n   font-size: 14px;\n   line-height: 1.42857143;\n   background-repeat: no-repeat;\n   background: rgb(76,86,95); /* Old browsers */\n   background: -moz-radial-gradient(top, ellipse cover, rgba(76,86,95,1) 0%,rgba(15,16,18,1) 100%); /* FF3.6-15 */\n   background: -webkit-radial-gradient(top, ellipse cover, rgba(76,86,95,1) 0%,rgba(15,16,18,1) 100%); /* Chrome10-25,Safari5.1-6 */\n   background: radial-gradient(ellipse at top, rgba(76,86,95,1) 0%,rgba(15,16,18,1) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */\n   filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c565f', endColorstr='#0f1012',GradientType=1 ); /* IE6-9 fallback on horizontal gradient */\n   color: #fff;\n}\n\np.mandatory {\n  text-align: right;\n  font-size: 12px;\n  margin-bottom: 0px;\n}\n\nh1 {\n  margin-top: 0px;\n}\n\n/*information/loading text in navbar*/\n.text-warning, .text-info, .text-error {\n  padding-top:15px;\n  font-weight: bold;\n  font-size: 16px;\n}\n.text-warning {\n  color: $yellow;\n}\n.text-info {\n  color: #FFFFFF;\n}\n.text-error {\n  color: $red;\n}\n\n.btn {\n  text-align: left;\n}\n\n@import 'navbar';\n\n@import 'toc';\n\n@import 'codeblockandscrollbar';\n\n.listingblock > .title {\n  color: $gray; /* To be overload by _colorperpage.scss */\n}\n\n.well {\n  background-color: transparent;\n  -webkit-box-shadow: none;\n  box-shadow: none;\n  border: none;\n  border-radius: 0px;\n  .sect1 + .sect1 {\n    margin-top: 50px;\n  }\n  h1 {\n    display: none;\n  }\n  h2 {\n    text-transform: uppercase;\n    text-align: center;\n    font-size: 13px;\n    color: white;\n    display: inline-block;\n    padding: 5px 20px;\n    margin-top: 0px;\n    position: absolute;\n    top: -12px;\n  }\n  a {\n    text-decoration: underline;\n  }\n}\n\n@import 'submenu';\n\n\n@import 'colorperpage';\n\n\n@import 'homepage';\n\n\n@import 'responsive';\n",
    id: 27
  });
  

index.add({
    title: "create module",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: create module\n:page-description: create module\n:page-layout: default\n:page-category: create\n:page-liquid:\n:toc:\n\n== Create a module [[CreateModule]]\n\n== What is a module ?\n\nA module consists in a shared library embedded a set of SolAR components as well as the corresponding factories to instantiate them. The management of modules is based on the https://forge.b-com.com/plugins/git/sft-softwarefactory/frameworks/xpcf[XPCF] third party providing a lightweight cross platform component framework.\nXPCF provides the following features to manage SolAR modules:\n\n* introspection to figure out which components are available in the module\n* separate implementation from interface to create the concrete implementation of a SolAR component and to bind it to an abstract SolAR and XPCF component interfaces.\n* component creation\n\nEach module implementation is identified with a Universally Unique IDentifier (UUID) to nearly ensure the uniqueness of a component implementation when the system instantiates it.\n\nAs mentionned previoulsy, the third party XPCF can introspect the shared library of a module to obtain information about the embedded components and the interfaces they implement. Only, the introspection of a shared library requires to load it, what could become tricky when the shared library has been built on a different platform than yours (useful for authoring tools supporting cross-platform compilation such as Unity). For this reason, XPCF proposes to associate to each module a registry file in xml format that describes the module with:\n\n* the module UUID,\n* the components embedded in the module with their UUID,\n* the abstract component interfaces implemented by the components.\n\nThus, any system will be able to intropsect a module without the need to load the corresponding shared library.\n\n== Create a module with the wizard\nWe are aware that creating a module and adding components to it can be a little tedious. A QTCreator wizard should soon be available to automate file generation and make the module creation easier for you. But for now, follow the instructions below to create a module step-by-step.\n\n== Create a module step-by-step\n\n=== Create a module project\nThe SolAR framework provides build pipeline tools to ease the cross platform compilation and deployment. As Qmake and CMake have both advantages and limitations, we recommend to provide for any SolAR module both a .pro to work on QTCreator as well as a CMake file to work for example on Visual Studio or other IDE.\n\n==== QT Creator\n\nOpen QTCreator and create a new project (in File menu).\n\nChoose `_Library_` and `_C++ Library_`.\n\nimage::images\\QTCreatorCreateLibrary.png[create a shared C++ library in QT,600,600, align=\"center\", title=\"Project creation\"]\n\nThen, set the name of your project with the name of your module, set the location (a dedicated folder with all module projects is recommended) and select \"Shared Library\" for the type of the library.\n\nimage::images\\QTCreatorCreateLibrary2.png[select library type,600,600, align=\"center\", title=\"Project name, location and library type\"]\n\nNext, select your development kits. We recommend to use _MSVC 2017 64bit_ or _Clang_. Then, unselect all required modules. On the next window, keep the name of the class to create with the name of your module. Unfortunately, with the QT project creation wizard, you cannot set dedicated folders for headers and sources. As we recommend to put the header files in a \"interfaces\" folder and the source files in a \"src\" folder, you will have to create these two folders manually and move the two files (MyModule.h and MyModule.cpp) in their respective folder (interfaces and src). Finally go to the summary and click on \"Finish\".\n\nSolAR provide a smart and easy to use build and deployment system.\n\nNow, you need to select the file called \"MyModule.pro\" in your project tree, and replace the text by the following one:\n\n.MyModule.pro\n----\n## remove Qt dependencies\nQT       -= core gui\nCONFIG -= qt\n\n## global defintions : target lib name, version\nTARGET = MyModule #\nFRAMEWORK = $$TARGET\nVERSION=x.x.x #\n\nDEFINES += MYVERSION=$${VERSION}\nDEFINES += TEMPLATE_LIBRARY\nCONFIG += c++1z\n\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += _NDEBUG=1\n    DEFINES += NDEBUG=1\n}\n\nDEPENDENCIESCONFIG = shared recurse\n\ninclude (../../builddefs/qmake/templatelibconfig.pri) #\n\n## DEFINES FOR MSVC/INTEL C++ compilers\nmsvc {\nDEFINES += \"_BCOM_SHARED=__declspec(dllexport)\"\n}\n\nINCLUDEPATH += interfaces/\n\nHEADERS += interfaces/MyModule.h #\n\nSOURCES += src/MyModule.cpp #\n\nunix {\n    QMAKE_CXXFLAGS += -Wignored-qualifiers\n    QMAKE_LINK=clang++\n    QMAKE_CXX = clang++\n}\n\nmacx {\n    DEFINES += _MACOS_TARGET_\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CFLAGS += -mmacosx-version-min=10.7 -std=c11 #-x objective-c++\n    QMAKE_CXXFLAGS += -mmacosx-version-min=10.7 -std=c11 -std=c++11 -O3 -fPIC#-x objective-c++\n    QMAKE_LFLAGS += -mmacosx-version-min=10.7 -v -lstdc++\n    LIBS += -lstdc++ -lc -lpthread\n}\n\nwin32 {\n\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275\n}\n\nheader_files.path = $${PROJECTDEPLOYDIR}/interfaces\nheader_files.files = $$files($${PWD}/interfaces/*.h*)\n\n# HOME variable corresponds to C:\\user\\\nxpcf_xml_files.path = $$(HOME)/.xpcf/SolAR\nxpcf_xml_files.files=$$files($${PWD}/xpcf*.xml)\n\nINSTALLS += header_files\nINSTALLS += xpcf_xml_files\n----\n\nNow, just update the _.pro_ file:\n\n [white]#replace the TARGET by the name of your module,#\n [white]#set the version number of your module,#\n [white]#change the name of your header file when it is added to the _HEADERS_ variable,#\n [white]#change the name of your source file when it is added to the SOURCES_ variable.#\n [white]#check if the builddefs folder used to define the compilation pipeline is well referenced#\n\nIMPORTANT: In order to deploy your module in the binary folder _${REMAKENROOT}/MyModule/MyModuleVersion_ after building, in QT creator click in the left menu on _Projects_, then on _Build_, on _add a build step_ and select _Make_. Set the _Make Argument_ to the value _install_. Do it for both release and debug mode.\n\n==== -- Using Cmake instead of .pro QT file --\n\nCreate a CMakeLists.txt file and copy the following code to it.\nThis file use a temporarily *BCOMDEVROOT* environment variable link to your SoLAR sources.\n\n.CMakeLists.txt\n----\ncmake_minimum_required(VERSION 3.7.2)\n\n##################################################\nset (VERSION_NUMBER \"x.x.x\") #\nproject(\"MyModule\") #\n\nset (HEADERS\n    interfaces/MyModule.h\n) #\n\nset (SOURCES\n    src/MyModule.cpp\n) #\n\ninstall (FILES \"${CMAKE_CURRENT_SOURCE_DIR}/xpcf_MyModule_registry.xml\" DESTINATION $ENV{BCOMDEVROOT}/.xpcf/SolAR/\t) #\n\n##################################################\n\n# various macros\ninclude(\"$ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/solarmacros.cmake\") #\n# config setup\nsetup()\n# process packagedependencies.txt\nprocessPackagedependencies()\n# define targets (type library)\ndefineTargets(\"library\" \"\")\n----\n\nnow, just update the _CMakeLists.txt_ file:\n\n [white]#set the name of the project with the name of your module,#\n [white]#set the version number of your module,#\n [white]#change the name of your header file when it is added to the _HEADERS_ variable,#\n [white]#change the name of your source file when it is added to the SOURCES_ variable.#\n [white]#indicate the name of your > in your porject folder to copy it to the binary folder _${BCOMDEVROOT}/MyModule/MyModuleVersion_.#\n [white]#check that the _solarmacros.cmake_ file exists. This file must be install when you have launched the installer. If you decide to build the framework by yourself, this file will be copied in your _${BCOMDEVROOT}_ folder when you will build and install the _SolARFramework_ project.#\n\n=== Configure your dependencies [[Module_Dependencies]]\n\nAs mentionned previously, SolAR framework provides developers with a compilation pipeline allowing among other things to easily manage dependencies (download, version management, packaging during deployment step, etc.).\n\nTo define the dependencies used by your module, create a file called packagedependencies.txt at the root of your project.\n\nFollowing, an example of packagedependencies.txt file for the OpenCV module:\n\n/.packagedependencies.txt\n----\nxpcf|2.2.0|xpcf|artifactory|https://repository.b-com.com/amc-generic\nspdlog|0.14.0|spdlog|thirdParties|https://github.com/SolarFramework/binaries/releases/download\neigen|3.3.5|eigen|thirdParties|https://github.com/SolarFramework/binaries/releases/download\nSolARFramework|0.6.0|SolARFramework|github|https://github.com/SolarFramework/SolarFramework/releases/download\nSolARModuleTools|0.6.0|SolARModuleTools|github|https://github.com/SolarFramework/SolARModuleTools/releases/download\nSolARModuleOpenCV|0.6.0|SolARModuleOpenCV|github|https://github.com/SolarFramework/SolARModuleOpenCV/releases/download\nopencv|3.4.3|opencv|thirdParties|https://github.com/SolarFramework/binaries/releases/download\n----\n\nHere is the syntax for each dependency:\n\n----\ndependency_name|dependency_version|dependency_folder_name|dependency_path|dependency_download_url\n----\n\nartifactory refers to .remaken/packages//   folder. You can create a REMAKENROOT variable. All process are made in this folder.\n\nIMPORTANT: xpcf, boost, spdlog, eigen and SolARFramework are mandatory third parties for creating a module.\n\n=== Create mandatory header and source FILES\n\n2 header files and 1 source file are mandatory to create a module.\n\nIMPORTANT: Do not forget to add a reference to the three next files required to create a module in the _.pro_ and in the _CMakeLists.txt_.\n\n==== MyModuleAPI.h\nCreate a new header file in the _interfaces_ folder of your project named _MyModuleAPI.h_, where of course _MyModule_ will be replaced by the name of your module. This file will define the macro _MYMODULE_EXPORT_API_ you will have to place  in front of each component interface to export with your shared library. So copy the following code in your new _MyModuleAPI.h_ file:\n\n.MyModuleAPI.h\n[source,cpp]\n----\n/**\n * Your header defining your copyright and your license\n */\n\n#ifndef MYMODULE_API_H\n#define MYMODULE_API_H\n\n#if _WIN32\n#ifdef MyModule_API_DLLEXPORT\n#define MYMODULE_EXPORT_API __declspec(dllexport)\n#else //MYMODULE_API_DLLEXPORT\n#define MYMODULE_EXPORT_API __declspec(dllimport)\n#endif //MYMODULE_API_DLLEXPORT\n#else //_WIN32\n#define MYMODULE_EXPORT_API\n#endif //_WIN32\n#include \"MyModule_traits.h\"\n#endif //MYMODULE_API\n----\n\nOf course, replace \"MyModule\" by your module name in respecting the case used in this file.\n\n==== MyModule_traits.h\nNow, you will have to create a second header file named _MyModule_traits.h_ in your _interfaces_ folder (again, replace _MyModule_ with the name of your module). This header will be the unique one to reference in order to use one or more components embedded in your module.\n\n.MyModule_traits.h\n[source,cpp]\n----\n/**\n * Your header defining your copyright and your license\n */\n\n#ifndef MYMODULE_TRAITS_H\n#define MYMODULE_TRAITS_H\n\n#include \"xpcf/core/traits.h\"\n\nnamespace SolAR {\nnamespace MODULES {\nnamespace MYMODULE {\n\n}\n}\n}\n\n#endif // MYMODULE_TRAITS_H\n----\n\nFor now, this file is quite empty, but you will see in a next step that we will define in it a trait for each component you will create and add to your module (>).\n\n==== MyModule.cpp\n\nFinally, create in the _src_ folder of your project a source file named _MyModule.cpp_. This file has three functions:\n* it declares the module with a UUID, a name and a description,\n* it is used by the XPCF component factory to create the components of the module,\n* it declares the components embedded in the module.\n\nCopy and paste the following code in it (again replace MyModule by the name of your module):\n\n.MyModule.cpp\n[source,cpp]\n----\n/**\n * Your header defining your copyright and your license\n */\n\n#include \"xpcf/module/ModuleFactory.h\"\n#include \"MyModule_traits.h\"\n\nnamespace xpcf=org::bcom::xpcf;\n\nXPCF_DECLARE_MODULE(\"MyModule UUID\", \"MyModule\", \"MyModule description\"); // \n\nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid& componentUUID,SRef& interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n\n    return errCode;\n}\n\nXPCF_BEGIN_COMPONENTS_DECLARATION\n\nXPCF_END_COMPONENTS_DECLARATION\n----\n\n [white]#Replace MyModule UUID by a Universally Unique IDentifier. To get one, you can use an https://www.uuidgenerator.net/[online UUID generator]. Please, provide a detailed description of your module that could be introspected by authoring tools.#\n\n=== Create a registry file [[RegistryFile]]\nAs mentionned previoulsy, a shared library has to be loaded for introspection, what is quite tricky when it has been built on a platform different from yours. For this reason, we always associate to a module a registry file describing information about the module itself and its components.\n\nCreate an xml file, name it _xpcf_MyModule_registry.xml_, and copy the following code in it (again replace _MyModule_ with the name of your module):\n\n.xpcf_MyModule_registry.xml\n[source,xml]\n----\n\n // \n\n\n\n----\n\n [white]#Copy and paste the module UUID, name and description defined in the file _MyModule.cpp_. Update the path by replacing _MyModule_ by the name of your module and _MyModule_version_ by the version number of your module defined in your _.pro_ and in your _CMakeLists.txt_ files.#\n\nThis file is somewhat empty, but will be completed when adding components.\n\n=== Create a pkg-config file\nThe SolAR compilation pipeline use https://www.freedesktop.org/wiki/Software/pkg-config/[pkg-config] that helps to insert the correct compiler options on the command line so an application can use _gcc -o test test.c pkg-config --libs --cflags glib-2.0_ for instance, rather than hard-coding values on where to find glib (or other libraries).\n\nCreate a file in your project root folder named _bcom-MyModule.pc.in_ and copy the following code in it:\n\n----\nlibname=MyModule # \nprefix=/usr/local\nexec_prefix=${prefix}\nlibdir=${exec_prefix}/lib\nincludedir=${prefix}/interfaces\nName: MyModule # \nDescription: MyModule description # \nVersion: MyModuleVersion # \nRequires:\nLibs: -L${libdir} -l${libname}\nLibs.private: ${libdir}/${pfx}${libname}.${lext}\nCflags: -I${includedir}\n----\n\n [white]#The shared library name of your module defined in your _.pro_ and _CMakeLists.txt_ files.#\n [white]#The description of the module such as the one defined in _MyModule.cpp_.#\n [white]#The name of your module.#\n [white]#the version number of your module defined in your _.pro_ and _CMakeLists.txt_ files.#\n\nWhen you will install your module, this file will be directly copied to your binary folder _${REMAKENROOT}/MyModule/MyModule_Version_.\n",
    id: 28
  });
  

index.add({
    title: "package &amp; download third parties",
    content: ":page-layout: _auto\n= package & download third parties\n\n\n== packaging\n\n. clone the following git repository:\ngit clone ssh://gitolite@forge.b-com.com/bcom-templates/builddefs/builddefs-scripts.git\n\n\nStarting from a fresh installed package (ie. result of a \"make install\"), run\nthe following perl script (under builddefs-scripts/xplatform)\n\n  $ bcom-packager.pl\n----\n  OPTIONS:\n      -s, --sourcedir                  => product root directory (where libs and includes are located)\n      -o, --osname                     => specify the operating system targeted by the product build. It is one of [win|mac|linux]. (defaults to the current OS environment)\n      -i, --includedir                 => relative path to include folder to export (defaults to the sourcedir provided with -s)\n      -l, --libdir                     => relative path to the library folder to export (defaults to the sourcedir provided with -s)\n      -r, --redistfile                 => relative path and filename of a redistribution file to use (such as redist.txt intel ipp's file). Only listed libraries in this file will be packaged\n      -d, --destinationdir             => package directory root destination (where the resulting packaging will be stored)\n      -p, --packagename                => package name\n      -v, --packageversion             => package version\n      -n, --ignore-mode                => forces the pkg-config generated file to ignore the mode when providing -L flags\n      -m, --mode [debug|release]       => specify the current product build mode. Binaries will be packaged in the appropriate [mode] folder\n      -a, --architecture [x86_64|i386] => specify the current product build architecture. Binaries will be packaged in the appropriate [architecture] folder\n      -w, --withsuffix suffix          => specify the suffix used by the thirdparty when building with mode mode\n      -u, --useOriginalPCfiles         => specify to search and use original pkgconfig files from the thirdparty, instead of generating them\n      -h, --help                       => display this help\n\n  EXAMPLES:\n      -s {path_to_root_sourcedir} --o win d {path_to_destination_dir} -p intel-tbb -v 2017.5 -l build/macos_intel64_clang_cc8.0.0_os10.11.6_release -m release -i include\n\n----\n\n. Use the artifactory packager scripts.\n\nUnder windows, use *builddefs-scripts/win/artiPackager.bat*\n\nUnder linux, use *builddefs-scripts/unixes/artiPackager.sh*\n\nUsage: run the .bat / .sh scripts where the packages are.\n\n== Using pkgm-bcom\n\n. Source: https://forge.b-com.com/www/bcom-templates//tools/pkgm-bcom-index/\n. You must have java installed on your machine: http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n. You will need to create an artifactory API_KEY: http://repository.b-com.com/webapp/#/profile\n. Download pkgm-bcom tool here: http://repository.b-com.com/bcom-devtools-generic-local/pkgm-bcom/1.0.0/multi/pkgm-1.0.0-fat.jar\n. In order to download dependencies described in a packagedependencies.txt file, you will need to launch:\n\n    java -jar [path to]/pkgm-1.0.0-fat.jar install -a x86_64 -c release -m shared -f packagedependencies.txt -k [YOUR artifactory API KEY]\n\n. NB: this will work only if third parties are available on artifactory repository\n\nFor example packagedependencies.txt can include the two following lines:\n\n  opencv|3.2.0|opencv|thirdParties|http://repository.b-com.com/argo-generic\n  boost|1.64.0|boost|thirdParties|http://repository.b-com.com/argo-generic\n",
    id: 29
  });
  

index.add({
    title: null,
    content: ":page-layout: _auto\nshowtitle:\n:page-title: project file\n:page-description: project file\n:page-layout: default\n:page-category: assemble\n:page-liquid:\n:toc:\n\n== Project File\n\n== Qt file\nHere is an example of a Qt project file that can be use as a starting point for any standalone project :\n[source]\n----\nTARGET = SolARImageOpenCVDynTest\nVERSION=0.5.2\n\nCONFIG += c++11\nCONFIG -= qt\nCONFIG += console\n\nDEFINES += MYVERSION=$${VERSION}\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += NDEBUG=1\n}\n\nwin32:CONFIG -= static\nwin32:CONFIG += shared\n\nDEPENDENCIESCONFIG = sharedlib\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude ($$(BCOMDEVROOT)/builddefs/qmake/templateappconfig.pri)\n\nSOURCES += \\\n    main.cpp\n\nunix {\n    LIBS += -ldl\n    QMAKE_CXXFLAGS += -DBOOST_LOG_DYN_LINK\n}\n\nmacx {\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CXXFLAGS += -fasm-blocks -x objective-c++\n}\n\nwin32 {\n    QMAKE_LFLAGS += /MACHINE:X64\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n\n    # Windows Kit (msvc2013 64)\n    LIBS += -L$$(WINDOWSSDKDIR)lib/winv6.3/um/x64 -lshell32 -lgdi32 -lComdlg32\n    INCLUDEPATH += $$(WINDOWSSDKDIR)lib/winv6.3/um/x64\n\n}\n\n----\n\nTo adapt this project to your use case, just change the name of the target and if required, add/modify the SOURCES and HEADERS attributes.\n\n== Cmake file\nHere is and example of a cmakelist.txt file that can be used for e.g. generate a Visual Studio solution. It will generate the same executable as the project file displayed above.\n\n[source]\n----\ncmake_minimum_required(VERSION 3.7.2)\n\n##################################################\nproject(\"SolARImageOpenCVDynTest\")\nset (SOURCES main.cpp)\n##################################################\n\n# various macros\ninclude(\"$ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/solarmacros.cmake\")\n# config setup\nsetup()\n# process packagedependencies.txt\nprocessPackagedependencies()\n\n# define the list of files to copy to build directory\n\n\nset(FILES_TO_COPY\n\n\t$ENV{BCOMDEVROOT}/thirdParties/opencv/${OPENCV_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}opencv_world${OPENCVVERSIONSUFFIX}.${LIBEXTENSION}\n\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_filesystem.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_system.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_timer.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_log.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_chrono.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_thread.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_date_time.${LIBEXTENSION}\n\n\t$ENV{BCOMDEVROOT}/bcomBuild/SolARModuleOpenCV/${SOLARMODULEOPENCV_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}SolARModuleOpenCV.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/${SOLARFRAMEWORK_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}SolARFramework.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/xpcf/${XPCF_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}xpcf.${LIBEXTENSION}\n\t)\n# define targets (library, install and uninstall)\ndefineTargets(\"executable\" \"${FILES_TO_COPY}\")\n\n\n----\n\nTo adapt this cmake file  to your use case, just change the name of the target and if required, add/modify the SOURCES and HEADERS attributes.\n",
    id: 30
  });
  

index.add({
    title: null,
    content: "// builds lunr\nvar index = lunr(function () {\n  this.field('title');\n  this.field('content', {boost: 10});\n  this.ref('id');\n});\n \n{% assign count = 0 %}\n{% for page in site.pages %}\n  {% if page.title != null %}\n    // do not take into account items that are from subpages (title == null),\n    // because we don't know in wich (potentially) multiples page(s) these supages can be includedt items that are from subpages (title ==null), because we don't know in wich (potentially) multiples page(s) these supages can be included\n    index.add({\n      \"title\": {{ page.title | jsonify }},\n      \"content\": {{ page.content | strip_html | jsonify }},\n      \"id\": {{ count }}\n    });\n    {% assign count = count | plus: 1 %}\n  {% endif %}\n{% endfor %}\n \n// builds reference data\nvar store = [];\n \n{% for page in site.pages %}\n  {% if page.title != null %}\n    // do not take into account items that are from subpages (title == null),\n    // because we don't know in wich (potentially) multiples page(s) these supages can be included\n    {% capture link %}{{ page.url | relative_url }}{% endcapture %}\n    store.push({\n      \"title\": {{page.title | jsonify }},\n      \"link\": {{ link | jsonify }}\n    });\n  {% endif %}\n{% endfor %}\n \nfunction searchAndDisplay(query){\n  var resultdiv = $('#results');\n  var result = index.search(query);\n  // Remove previous results\n  resultdiv.empty();\n  // Add status\n  resultdiv.prepend('Found '+result.length+' result(s) for keyword: '+query+'');\n  // Loop through, match, and add results\n  result.forEach(function(item) {\n    var ref = item.ref;\n    var searchitem = ''+store[ref].title+'';\n    resultdiv.append(searchitem);\n  });\n}\n \n// builds search\n$(document).ready(function() {\n  var query = (decodeURI(location.search).split('q=')[1] || '').split('&')[0];\n  var formattedQuery = query.split('+').join(' ');\n  searchAndDisplay(formattedQuery);\n \n  $('input#search').val(formattedQuery).on('keyup', function () {\n    var query = $(this).val();\n    searchAndDisplay(query);\n    console.log(\"inputsearch query=\"+query);\n  });\n});",
    id: 31
  });
  

index.add({
    title: "Search",
    content: "Search results\n\n\n",
    id: 32
  });
  

index.add({
    title: "standalone pipeline",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: standalone pipeline\n:page-category: assemble\n:page-description: standalone pipeline\n:page-liquid:\n:page-layout: default\n:toc:\n\n== Assemble a standalone C++ pipeline\n\n== What is standalone C++ pipeline ?\nA standalone C++ pipeline is a SolAR pipeline running in a standalone application. This pipeline will be defined in a _main.cpp_ class, and is very useful for pipeline debugging. We recommend starting with this approach to familiarize yourself with pipeline assembly.\n\n== Initialize your pipeline with the wizard\nWe are aware that creating a pipeline step by step can be a little tedious. A QTCreator wizard should be soon available to automate file generation and make the pipeline creation easier for you.\n\nAlso, the SolAR Framework has been designed to ease the development of a visual coding tool to build pipeline just by dragging and dropping component boxes and connect them in a Graphic User Interface.\n\nBut for now, follow the instructions below to initialize a standalone C++ pipeline step-by-step.\n\n== Initialize your pipeline step-by-step\n\n=== Create your pipeline project\n\n==== QT Creator\n\nOpen QTCreator and create a new project (in File menu).\n\nSelect `_Non-Qt project_` and `_Plain C++ Application_` and click on `_Choose_` button.\n\nimage::images\\QTProjectAppCreation.png[create a Plain C++ application in QT,600,600, align=\"center\", title=\"Plain C++ application creation\"]\n\nThen, set the name of your standalone pipeline, and its location (Create a dedicated folder with all pipeline projects is recommended).\n\nimage::images\\QTProjectAppCreation2.png[Set pipeline project name in QT,600,600, align=\"center\", title=\"Set pipeline project name in QT\"]\n\nNext, define your build system with _qmake_. For the next step, choose your development kits. We recommend to use _MSVC 2017 64bit_ on Windows or _Clang_ on Linux.\n\nYour project is now created, but as SolAR provides a smart and easy way to build and deploy you pipeline, you will need to update the _MyStandalonePipeline.pro_ file. Select it in your project tree, and replace its script by the following one:\n\n.MyStandalonePipeline.pro\n----\n## remove Qt dependencies\nQT -= core gui\nTARGET = MyStandalonePipeline // \nVERSION=x.x.x // \n\nCONFIG += c++1z\nCONFIG -= qt\nCONFIG += console\n\nDEFINES += MYVERSION=$${VERSION}\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += NDEBUG=1\n}\n\nwin32:CONFIG -= static\nwin32:CONFIG += shared\n\nDEPENDENCIESCONFIG = sharedlib\n#NOTE : CONFIG as staticlib or sharedlib, DEPENDENCIESCONFIG as staticlib or sharedlib, QMAKE_TARGET.arch and PROJECTDEPLOYDIR MUST BE DEFINED BEFORE templatelibconfig.pri inclusion\ninclude (../../builddefs/qmake/templateappconfig.pri) // \n\nSOURCES += \\\n    main.cpp\n\nunix {\n    LIBS += -ldl\n    QMAKE_CXXFLAGS += -DBOOST_LOG_DYN_LINK\n}\n\nmacx {\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CXXFLAGS += -fasm-blocks -x objective-c++\n}\n\nwin32 {\n    QMAKE_LFLAGS += /MACHINE:X64\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275\n\n    # Windows Kit (msvc2013 64)\n    LIBS += -L$$(WINDOWSSDKDIR)lib/winv6.3/um/x64 -lshell32 -lgdi32 -lComdlg32\n    INCLUDEPATH += $$(WINDOWSSDKDIR)lib/winv6.3/um/x64\n\n}\n----\n\nNow, just update the _MyStandalonePipeline.pro_ file:\n\n [white]#set the TARGET with the name of your standalone pipeline,#\n [white]#set the version number of your standalone pipeline,#\n [white]#check if the builddefs folder used to define the building pipeline is well referenced#\n\nFinally, click on _Projects_ in the left menu of QTcreator, click on _Run_, set your working directory to the root directory of your project, and check _Add build library search path to LD_LIBRARY_PATH_ if not already done.\n\n==== -- Using Cmake instead of .pro QT file --\n\nCreate a CMakeLists.txt file and copy the following code to it.\nThis file use temporarily *BCOMDEVROOT* environment variable link to your SoLAR sources.\n\n.CMakeLists.txt\n----\ncmake_minimum_required(VERSION 3.7.2)\n\n##################################################\nproject(\"MyStandalonePipeline\") #\nset (VERSION_NUMBER \"x.x.x\") #\nset (SOURCES main.cpp)\n##################################################\n\n# various macros\ninclude(\"$ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/solarmacros.cmake\") #\n# config setup\nsetup()\n# process packagedependencies.txt\nprocessPackagedependencies()\n\n# define the list of files to copy to build directory\n\nset(FILES_TO_COPY\n  # Copy framework and its dependencies binaries in your working folder #\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_filesystem.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_system.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_timer.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_log.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_chrono.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_thread.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/boost/${BOOST_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}boost_date_time.${LIBEXTENSION}\n\t$ENV{BCOMDEVROOT}/thirdParties/xpcf/${XPCF_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}xpcf.${LIBEXTENSION}\n  $ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/${SOLARFRAMEWORK_VERSION}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}SolARFramework.${LIBEXTENSION}\n\n  # Copy module binaries in your working folder #\n  $ENV{BCOMDEVROOT}/bcomBuild/\"Module1\"/${\"MODULE1_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module1\".${LIBEXTENSION}\n  $ENV{BCOMDEVROOT}/bcomBuild/\"Module2\"/${\"MODULE2_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module2\".${LIBEXTENSION}\n\n  # Copy binaries of the third parties of the modules in your working folder #\n  $ENV{BCOMDEVROOT}/thirdParties/\"Module1_Dependency\"/${\"MODULE1_DEPENDECY_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module1_Dependency\"${MODULE1_DEPENDECYVERSIONSUFFIX}.${LIBEXTENSION}\n  $ENV{BCOMDEVROOT}/thirdParties/\"Module2_Dependency\"/${\"MODULE2_DEPENDECY_VERSION\"}/lib/x86_64/shared/${BUILDCONFIG}/${LIBPREFIX}\"Module2_Dependency\"${MODULE2_DEPENDECYVERSIONSUFFIX}.${LIBEXTENSION}\n\t)\n# define targets (library, install and uninstall)\ndefineTargets(\"executable\" \"${FILES_TO_COPY}\")\n----\n\nnow, just update the _CMakeLists.txt_ file:\n\n [white]#replace the name of the project with the name of your standalone pipeline,#\n [white]#set the version number of your standalone pipeline,#\n [white]#check if the _solarmacros.cmake_ file exists. This file must have been installed when you launched the installer. If you have decided to build the framework by yourself, this file must have been copied in your _${BCOMDEVROOT}_ folder when you have built and installed the _SolARFramework_ project.#\n [white]#Change nothing here, the binaries required for the SolAR framework will be copied in your working directory.#\n [white]#Add the commands to copy the SolAR modules used by your pipeline in you working directory. If they have been well installed, they should be stored in _${BCOMDEVROOT}/bcomBuild/$_#\n [white]#Add the commands to copy the dependencies of the SolAR modules used by your pipeline in you working directory. If they have been well installed, they should be stored in _${BCOMDEVROOT}/thirdParties/$_#\n\nIMPORTANT: We recommend to maintain both a QT project file and a CMake file for any SolAR pipeline.\n\n=== Select your dependencies\n\ninclude::_dependencies_file.adoc[]\n\n=== Create the configuration file\n\nhis file will be used at run-time. It will allow XPCF to load Module components and configure them at run-time. So you can experiment different implementations and configurations of a pipeline without the need to recompile your application.\n\nCreating a configuration file is very easy.\nOnce you have identified the modules and the components required to assemble your pipeline, just record them in the xml configuration file.\n\nFollowing, an example of a configuration file for a pipeline using the camera and image viewer components embedded in the _SolARModuleOpenCV_ module :\n\n.MyStandalonePipelineConfiguration.xml\n[source,xml]\n----\n\n\n\n # \n   # \n    \n    \n  \n  \n    \n    \n  \n\n\n # \n  \n    \n    \n  \n  \n    \n    \n    \n    \n  \n\n\n\n----\n [white]#Add the modules used by your pipeline. To get information concerning the modules, have a look to their registry file available in the _${REMAKENROOT}/\"ModuleName\"/\"ModuleVersion\"/_.#\n [white]#For each module, add the components used by your pipeline. To get information concerning the components, have a look to the registry file of their module available in the _${REMAKENROOT}/\"ModuleName\"/\"ModuleVersion\"/_.#\n [white]#Optionally, add a configuration to your components. The name of your configuration parameters are generally the name of the variable in the class definition of the component without the prefix \"m_\". The type of the configuration parameters are simple types such as \"String\", \"Integer\", \"Float\", \"Double\", or array of these simple types.#\n\nExamples of such configuration files are available in the samples directory that is provided with the SolAR installation.\n\n== Implement your pipeline\n\nThis section describes how to assemble different components to build a vision pipeline.\nFirst as already mentioned in the previous sections, it is supposed that the required components have been identified. And consequently, a configuration file, a dependencies file and a project file have been created.\n\n=== Main template of a standalone pipeline\n\nTo create a standalone C++ pipeline, you can start by replacing the main.cpp code with the following one:\n\n.main.cpp\n[source, cpp]\n----\n///**\n * Add your header with the copyright and license information concerning your pipeline\n */\n\n// Common headers // \n#include \"xpcf/xpcf.h\"\n#include \"core/Log.h\"\n\n// ADD HERE: Module traits headers. #include \"SolARModuleOpencv_traits.h\"\n// \n\n// ADD HERE: Component interfaces header. e.g. #include \"api/input/devices/ICamera.h\"\n// \n\n\n// Namespaces // \nusing namespace SolAR;\nusing namespace SolAR::datastructure;\nusing namespace SolAR::api;\n\nnamespace xpcf  = org::bcom::xpcf;\n\n// Main function\nint main(int argc, char *argv[])\n{\n\n#if NDEBUG // \n    boost::log::core::get()->set_logging_enabled(false);\n#endif\n    LOG_ADD_LOG_TO_CONSOLE(); // \n\n// Instantiate component manager and load the pipeline configuration file // \n    SRef xpcfComponentManager = xpcf::getComponentManagerInstance();\n    if(xpcfComponentManager->load(\"MyStandalonePipelineConfiguration.xml\")!=org::bcom::xpcf::_SUCCESS)\n    {\n        LOG_ERROR(\"Failed to load the configuration file MyStandalonePipelineConfiguration.xml\")\n        return -1;\n    }\n\n// ADD HERE: instantiate concrete components and bind them to abstract component interfaces\n    // e.g. SRef camera = xpcfComponentManager->create()->bindTo();\n    // \n\n// ADD HERE: Declare here the data structures used to connect components\n    // \n\n// ADD HERE: The pipeline initialization\n    // \n\n// ADD HERE: The pipeline processing\n    while (true)\n    {\n      // \n    }\n\n    return 0;\n}\n----\n [white]#The _xpcf_ header is required to instantiate components. _log_ header is recomended if you want to log your pipeline.#\n [white]#Add the traits header files of the modules used by the pipeline.#\n [white]#Add the component interface header files of the components used by the pipeline.#\n [white]#Add SolAR and XPCF namespaces directives to shorten the calls to SolAR api and datastructures.#\n [white]#Add this line to remove irrelevant logs in release mode.#\n [white]#Add this line to push logs in the console. You can also push logs to a log file by using the macro _LOG_ADD_TO_FILE(\"path/logfilename.log\", \"r\")_.#\n [white]#Create an instance of an XPCF ComponentManager and use it to load the configuration file of your standalone pipeline.#\n [white]#Instantiate concrete components embedded into modules thanks to the XCPF Component Manager. Then bind them to their corresponding abstract component interface. Thanks to that, swapping a component by another one will just consists in changing this line of code.  More details are given in the next section >#.\n [white]#Declare all the data structures used to exchange data between components. Have a look to the data structures defined in the SolARFramework in the > section.#\n [white]#if required, add the code to initialize your pipeline (e.g. start a camera, load a reference image, etc.).#\n [white]#Create the loop of your pipeline by calling the different processing functions of your components with data structure as input and/or output attributes. More details on how to call a function of a component are given in the next section >.#\n\n=== Instantiate a component [[InstantiateComponent]].\n\nThanks to the use of XPCF, instantiation of a component is very easy and this operation is done at run-time. The configuration of the components will be initialize with values declared in the configuration file.\nThe syntax is the following for e.g. a component that display an image in a window:\n\n[code, cpp]\n----\nSRef imageViewer = xpcfComponentManager->create()->bindTo();\n----\nIf you want to instantiate several instance of the same component but with different configurations, in the configuration file fill in the name attribute for each configuration with a specific value, and add this string value in parameter of the function _create_:\n\n[code, cpp]\n----\nSRef imageViewer = xpcfComponentManager->create(\"configuration1\")->bindTo();\n----\n=== Use a component.\n\nOnce a component is created, any public function  described in its API can be used to build your pipeline.\nFor instance :\n```\nif (viewerConfImage->display(image) == FrameworkReturnCode::_STOP )\n```\n\n=== Pipeline sample\n\nWe will present next the implementation of the simplest pipeline that consists in capturing an image from a camera and display it in a window. For this implementation, we will need only one module: _SolARModuleOpenCV_.\n\n- as the example relies on SolarModuleOpencv, include the module traits\n```\n#include \"SolARModuleOpencv_traits.h\"\n```\n- as the example contains components that implement virtual interfaces, include the corresponding header files\n```\n#include \"api/image/IImageLoader.h\"\n#include \"api/display/IImageViewer.h\"\n```\n\n- as the modules/components to be used are listed in a configuration file (yml), don't forget to load it via xpcf :\n```\nxpcfComponentManager->load(\"conf_ImageLoader.xml\")\n```\n\nHere the full sample code for this standalone pipeline:\n\n\n[source,c]\n----\n///**\n * Add your header with the copyright and license information concerning your pipeline\n */\n\n// Common headers\n#include \"xpcf/xpcf.h\"\n#include \"core/Log.h\"\n\n// Module traits headers. #include \"SolARModuleOpencv_traits.h\"\n#include \"SolARModuleOpencv_traits.h\" // \n\n// Component interfaces header. e.g. #include \"api/image/IImageLoader.h\"\n#include \"api/input/devices/ICamera.h\" // \n#include \"api/display/IImageViewer.h\"\n\n// Namespaces\nusing namespace SolAR;\nusing namespace SolAR::datastructure;\nusing namespace SolAR::api;\n\nnamespace xpcf  = org::bcom::xpcf;\n\n// Main function\nint main(int argc, char *argv[])\n{\n\n#if NDEBUG\n    boost::log::core::get()->set_logging_enabled(false);\n#endif\n    LOG_ADD_LOG_TO_CONSOLE();\n\n// Instantiate component manager and load the pipeline configuration file\n    SRef xpcfComponentManager = xpcf::getComponentManagerInstance();\n    if(xpcfComponentManager->load(\"MyStandalonePipelineConfiguration.xml\")!=org::bcom::xpcf::_SUCCESS)\n    {\n        LOG_ERROR(\"Failed to load the configuration file MyStandalonePipelineConfiguration.xml\")\n        return -1;\n    }\n\n    // declare and instantiate components // \n    SRef camera = xpcfComponentManager->create()->bindTo();\n    SRef imageViewer = xpcfComponentManager->create()->bindTo();\n\n    if (!camera || !imageViewer)\n    {\n        LOG_ERROR(\"One or more component creations have failed\");\n        return -1;\n    }\n\n// Declare here the data structures used to connect components\n    SRef image; // \n\n// The pipeline initialization\n\n    // start the camera // \n    if (camera->start() != FrameworkReturnCode::_SUCCESS)\n    {\n        LOG_ERROR (\"Camera cannot start\");\n        return -1;\n    }\n\n// The pipeline processing // \n    while (true)\n    {\n        if(camera->getNextImage(image)==SolAR::FrameworkReturnCode::_ERROR_)\n            break;\n        if (imageViewer->display(image) == FrameworkReturnCode::_STOP )\n            break;\n     }\n    return 0;\n}\n----\n [white]#As the example relies on _SolARModuleOpencv_, we include the corresponding module traits header file.#\n [white]#As the example assemble two components, a camera and an image viewer, we include the corresponding component interface header files.#\n [white]#We instantiate our two components based on openCV implementations and we bind them to their abstract component interfaces.#\n [white]#We declare a shared reference of a SolARImage that will be used to pass the image captured by the camera to the image viewer.#\n [white]#We initialize the pipeline by starting the camera. In our configuration file, you will find for the camera first an ID corresponding to the camera you want to start, and secondly a path to an yml camera description file defining its intrinsic parameters. This file can be generated by calibrating the camera (see > section for more information).#\n [white]#Finally, we implement the core of the pipeline by capturing the current image from the camera, and by passing this image to the image viewer.#\n\nIMPORTANT: On QT Creator, before building your pipeline, do not forget to run qmake on your project (right click on _MyStandalonePipeline_ into the project hierarchy, and click on _run qmake_).\n\nAs there is no generic way to implement a pipeline, we encourage the readers to take a look at the many examples provided by SolAR in the Samples directory\nthat comes with the installation of SolAR.\nFor each sample, you will find a configuration file, a dependencies file and a project file to help you to build your own pipeline together with sources codes.\n",
    id: 33
  });
  

index.add({
    title: "Tags",
    content: "Tags\n\n{% capture site_tags %}{% for tag in site.tags %}{{ tag | first }}{% unless forloop.last %},{% endunless %}{% endfor %}{% endcapture %}\n\n\n{% assign tag_words = site_tags | split:',' | sort %}\n\n\n\n\n\n  {% for item in (0..site.tags.size) %}{% unless forloop.last %}\n    {% capture this_word %}{{ tag_words[item] }}{% endcapture %}\n    \n      {{ this_word }}\n        ({{ site.tags[this_word].size }})\n      \n    \n  {% endunless %}{% endfor %}\n\n\n\n\n  {% for item in (0..site.tags.size) %}{% unless forloop.last %}\n    {% capture this_word %}{{ tag_words[item] }}{% endcapture %}\n    {{ this_word }}\n    {% for post in site.tags[this_word] %}{% if post.title != null %}\n      \n        \n          {{ post.title }}\n        \n        \n          {{ post.date | date_to_string }}\n        \n      \n      \n    {% endif %}{% endfor %}\n  {% endunless %}{% endfor %}\n\n",
    id: 34
  });
  

index.add({
    title: "module tests",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: module tests\n:page-description: module tests\n:page-layout: default\n:page-category: create\n:page-liquid:\n:toc:\n\n== Tests\n\n== Tests\n\nDefine unit tests, based on boost framework .\nYou can know more about boost with this link : http://www.boost.org/[http://www.boost.org,role=\"external\", window=\"_blank\"]\n\nYour Unit tests for a specific component, should be placed in the component directory/unittest.\nIf you have used the SolARComponent template, this directory should be already there.\n\nimage::images\\400px-Unittestdirectory.png[Unit test directory]\n\n* Open \\{yourcomponent}/unittest/\\{yourcomponent}unittest.pro\n\n* You have to describe your unit tests in the file  \\{yourcomponent}unittest.cpp\n\nFor example\n\n[source,cpp]\n----\n#define\nBOOST_TEST_MODULE \\{Yourcomponent}UnitTest\n\n#include  \n#BOOST_AUTO_TEST_CASE(TestLoadImage) \n{ // test execution instructions\n}\n----\n\n [white]#Please note your code contains include of boost#\n [white]#You have to define the *name* of your test thanks to the boost macro \"BOOST_AUTO_TEST_CASE\"#.\n\nIn this example , the definition of the test case \"TestLoadImage\" for your component.\n\nIt means, that when you will execute the unit test, it will executes this test \"TestLoadImage\" following the instructions in this declaration.\nYou can define several test cases.\n\nInside your test, please write a kind of demo main function, but where you check results of your component function thanks to macro BOOST CHECK and/or BOOST_TEST.\n\nYou will find easily information about BOOST macro on Internet http://www.boost.org/doc/libs/1_64_0/libs/test/doc/html/index.html [boost.org information,role=\"external\", window=\"_blank\"] .\n\nNOTE: There is no \"main\" function, as it is automatically generated by boost (used in unit tests).\n\n* Please ensure that it contains sufficient tests cases to verify your code is OK (normal case, error cases).\n\nExample here : // Case normal, with an existing image file.\n\nWARNING: remplacer ici par le nouveau code source SolAR\n[source,cpp]\n----\nBOOST_AUTO_TEST_CASE(TestLoadImage)\n{ // To simplify this example test, let's suppose we'll test 'float'.\n // Some test are stupid, but all should pass.\n int result= 0;\n std::shared_ptr myArgoImage0 = getArgoImageInstance();\n\n....\nBOOST_CHECK( myArgoImage0 !=  NULL);\n....\n\n// getArgoImageInstance should not return a null pointer result\n\nmyArgoImage0->LoadImage(\"../test.jpg\");\nBOOST_TEST( result= = 0,\"ARGO ERROR: Load Image should return 0\");\n// As the image indicated exists, loadImage should return 0, as a normal case\n\n}\n\nBOOST_AUTO_TEST_CASE(TestLoadImageInexistante)\n{\n// Some test are stupid, but all should pass.\nint result= 0; std::shared_ptr\nmyArgoImage0 =  getArgoImageInstance();\n\n....\nBOOST_TEST(( myArgoImage0 !=  NULL),&quot;ARGO ERROR: ArgoImage should not return null pointer&quot;);\n\nresult=  myArgoImage0-&gt;LoadImage(&quot;../test2.jpg&quot;);\nBOOST_TEST( result= = -1,&quot;ARGO ERROR: Load Image should return -1&quot;);\n....\n\n// As the image indicated does not exist, loadImage should return -1, an error\n\n }\n----\n",
    id: 35
  });
  

index.add({
    title: null,
    content: ":page-layout: _auto\n\n:showtitle:\n:page-title: third parties packaging\n:page-category: assemble\n:page-description: third parties packaging\n:page-liquid:\n:page-layout: default\n:toc:\n\n== Third party packaging\n\n\n\n== Package your third parties [[package_your_third_parties, Package your third parties]]\nTodo\n",
    id: 36
  });
  

index.add({
    title: "tools",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: tools\n:page-description: tools\n:page-layout: default\n:page-category: use\n:page-liquid:\n:toc:\n:toclevels: 1\n\n== Tools\n\n== Camera Calibration [[CameraCalibration]]\n\n== Introduction\nSolar provides a program based on OpenCV https://docs.opencv.org/2.4/doc/tutorials/calib3d/camera_calibration/camera_calibration.html[\"opencv\",role=\"external\", window=\"_blank\"]that can be used to calibrate your camera device. This program is available in the SolARModuleOpenCV repository. It conforms to the SolAR paradigm and both Qt and Visual Studio projects are provided. A chessboard image (chessboard.png) and a input configuration file are also provided.\n\nThis tutorial is a simplified version of the one provided by OpenCV,  feel free to visit OpenCV website to get details on the actual implementation.\n\nThe calibration process uses a chessboard. You can print the following one:\n\nimage::..\\use\\images\\chessboard.png[chessboard,400,400, align=\"center\"]\n\n==  steps\n\n//Here are the steps to follow for Visual Studio (do similar steps if you  use Qt):\n\n//* Open SolARCameraCalibration.sln :\n\n//image::images/CameraCalibration/slnVS.jpg[]\n\n\n//* Build the program (Ctrl + Shift + B) :\n\n//image::images/CameraCalibration/setVS.jpg[]\n\n* Download the zip file with the CameraCalibration executable according to your operating system https://github.com/SolarFramework/binaries/releases/tag/Calibration0.3[\"exec\",role=\"external\", window=\"_blank\"]\n\n* Plug your camera device\n\n* Run the program\n\nBy default, the camera Id is supposed to be 0 and this is correct most of the time. Yet You may have to change that in order to make things working, e.g. on laptops where 0 is usually assigned to the built-in camera device and if you plan to calibrate an USB external camera for instance. In that case you may have to set the camera Id to 1. This is accomplished by setting \"1\" as input parameter in the _Properties/Debugging/Command Arguments_ area:\n\nimage::images/CameraCalibration/Id.jpg[]\n\n\n\nIf input parameters are correct, you will get something like :\n\nimage::images/CameraCalibration/run.jpg[]\n\n* Press the 'g' key to start the process.\n\nA number of positive detections (default = 10) will be taken with a minimum period of time between two detections (default value = 2 seconds). The will be further explained in the last paragraph : *input/output files*.\nA positive detection is when the chessboard is correctly identified. This is illustrated with a frozen picture displaying corners and lines :\n\nimage::images/CameraCalibration/detect.jpg[]\n\nPlease, notice the bottom-right counter that indicates the number of positive detections so far.\n\nWhen all the positive detections are obtained, the calibration is performed and the process is completed, then a bottom-right message indicates \"Calibrated\" :\n\nimage::images/CameraCalibration/completed.jpg[]\n\n* Press [Esc] to close the camera view and to exit the program.\n\nAn output calibration file has been generated :\n\nimage::images/CameraCalibration/outFile.jpg[]\n\nThis file can be used directly in SolARModuleOpenCV samples and demo's codes if a calibration file is required.\n\n== Input/output files\n\nThe input/output file names are hard coded in the code.\n\nimage::images/CameraCalibration/fileNames.jpg[]\n\nThe input file is calibration_config.yml. An example is given which is described below :\n\n****************************\nINPUT\n****************************\n----\ncalibration_config.yml content :\n# the number of inner corners on board width\nchessboard_width: 9\n# the number of inner corners on board height\nchessboard_height: 6\n# square size in some user-defined units\nsquare_size: 0.026\n#fix aspect ratio (fx/fy)\napsect_ration: 1\n# number of frames to calibrate the camera : 10 is advised for a high calibration quality, you can put less if you are not so exigent\nnb_frames: 10\n# OpenCV Flags for camera calibration\nflags: 0\n# delay between each frame in milliseconds : 2 is good to let you enough time to move your camera and focus on the chessboard.\ndelay: 2000\n----\n\n\nThe output file is camera_calibration.yml. It contains the result of the calibration and the format is described below :\n****************************\nOUTPUT\n****************************\n\n----\nThis program generates a file camera_calibration.yml.\nCheck the file date, to be sure that it has been generated when you run the SolARCameraCalibration.\nThe data in this file define the calibration parameters of your camera, and will hemp for computer vision and especially pose estimation.\n\ncalibration_time: \"Wed Dec  6 14:02:31 2017\"\nimage_width: 640\nimage_height: 480\nboard_width: 9\nboard_height: 6\nsquare_size: 2.6000000536441803e-02\nflags: 0\ncamera_matrix: !!opencv-matrix\n   rows: 3\n   cols: 3\n   dt: d\n   data: [ 6.2358844756875726e+02, 0., 3.1296501379528701e+02, 0.,\n       6.2510924611650637e+02, 2.6595453191051286e+02, 0., 0., 1. ]\ndistortion_coefficients: !!opencv-matrix\n   rows: 5\n   cols: 1\n   dt: d\n   data: [ 5.0406145631272294e-03, -7.3194070034412229e-01,\n       8.8401137738982200e-03, -4.1912068994392751e-03,\n       2.7609935737342024e+00 ]\n----\n\n== Video\nThis calibration requires that the chessboard is detected (positive detections) with, as far as possible, different poses of the camera. This is illustrated in the following video.\n\nvideo::../videos/CameraCalibration/CameraCalibration.mp4[width=640px, options=\"\"]\n",
    id: 37
  });
  

index.add({
    title: "tutorials",
    content: ":page-layout: _auto\n= tutorials\n:page-title: tutorials\n:page-category: use_it\n:page-description: tutorials\n:page-liquid:\n:page-layout: default\n:toc:\n:toclevels: 1\n:prewrap!:\n\n== Tutorials\n\n== Prerequisites\ninclude::_prerequisites.adoc[]\n\n//=== Project files\n//-\tDownload the files required by the project.\n//-\tUnarchive the files to your desktop.\n\n[[Create-SolAR-Project]]\n== Create your first SolAR Project\ninclude::_createSolARProject_sanscode.adoc[]\n\n[[Tutorial-hello-world]]\n== Write your first SolAR \"Hello World\"\ninclude::_hello_world.adoc[]\n\n[[Tutorial-keypoints-detection]]\n== Detect keypoints in an image\ninclude::_keypoints_detection_sanscode.adoc[]\n\n[[Tutorial-matching]]\n== Match an image with your video stream\ninclude::_matching_sanscode.adoc[]\n\n[[Tutorial-camera-calibration]]\n== Calibrate your camera\nComing Soon !\nPlease contact us if you want a camera calibration tutorial.\n//include::./tutorials/CameraCalibration/_CameraCalibration_sanscode.adoc[]\n\n== Estimate a camera pose with a natural image marker\nComing Soon !\nPlease contact us if you want tutorial with a natural image marker.\n//include::_NaturalImageMarkersimpletuto_sanscode.adoc[]\n\n== Estimate a camera pose with a fiducial marker\nComing Soon !\nPlease contact us if you want camera pose with a fiducial marker tutorial.\n//include::tutorials\\FiducialMarker\\fiducialMarker_sanscode.adoc[]\n\n\n//==== tutorial\n//:include _keypoint_detection_sample.adoc[]\n\n\n//==== exercise\n\n//==== exercise correction\n//== Use SolAR for Descriptor Extraction\n\n//:include _descriptor_extraction_sample.adoc[]\n\n//== Use SolAR for Descriptor Matching\n\n//:include _descriptor_matching_sample.adoc[]\n",
    id: 38
  });
  

index.add({
    title: "unity",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: unity\n:page-description: unity\n:page-layout: default\n:page-category: use\n:page-liquid:\n:toc:\n:imagesdir: ../images\n\n== Unity [[Unity]]\n\n[.text-center]\nGetting started\n\n== [black]#Now we AR# on unity\n\nIntegrate SolAR pipelines in Unity Engine give opportunities to developers of\nAR services to get access to fully configurable SolAR based solutions to design AR applications. +\n  +\n[.text-center]\nSolAR has now a *Plugin for Unity*\n\n== Install Unity\n\n* Refer to https://store.unity.com/fr/download?ref=personal\n* *Download the last version of Unity Hub*. The hub gives you the possibility to get access to different versions of Unity.\n* Our actual version (our test are based on)  is **2018.2.16f1**\n\n== Create a new Unity project\n\n* *New project*\n\n[#img-newunity]\nimage::newunity.png[NewUnityProject,450,250,align=\"center\"]\n\n[.text-center]\n*Interface to create a new Unity project*\n\nWARNING: It's recommended that you use a 3D project set-up.\n\n* *Documentation*\n\n* All documentation for Unity is available here : https://docs.unity3d.com/2018.4/Documentation/Manual/\n\nNOTE: If you are a Unity newbie, check tutos online to help you.\n\n== SolAR Plugin for Unity\n\n=== For whom ?\n\nFor users who want to simply design AR services: Choose a pipeline, configure it in the inspector, and experience AR at run-time. +\n\n    Easy to use, understandable for everyone.\n\n=== Download\n\n* go on https://github.com/SolarFramework/SolARUnityPlugin/releases\n* click on _Assets_\n* click on _SolARPlugin_win.unitypackage_\n\nThis package provides user with the minimum requirements to load a SolAR pipeline in Unity.\n\n=== Project Structure\n\nThe plugin version will add the following hierarchy in the Assets folder of your unity project:\n\n* `_Plugins_`: Host the binaries of the SolAR Framework, of the the pipeline manager that will handle the load of SolAR pipelines as well as the relative third parties (boost and xpcf).\n* `_SolAR_`\n** `_Editor_`\n*** `_SolARPlugin_`: Scripts for Editor inspector dedicated to the -SolARPipelineLoader_, and a build script to deploy the solution on various platforms\n** `_Prefabs_`: All the prefabs required to simply use SolAR in Unity.\n** `_Materials_`: Materials used to display the video stream of the camera in the background.\n** `_Scripts_`\n*** `_SolARPlugin_`: SolARPipelineLoader script\n*** `_Swig_`\n**** `_SolARPlugin_`: The c# scripts required by the _SolARPipelineLoader_ automatically generated from SolAR C++ classes thanks to SWIG.\n** `_Shaders_`: Shaders used to display the video stream of the camera in the background.\n\n=== How works the SolAR Plugin for Unity ?\n\nThe SolAR plugin for Unity is a simple interface to load any SolAR pipelines assembled by the SolAR pipeline assemblers and use them to design AR services with Unity. +\n +\nTo load a SolAR pipeline in Unity, simply drag and drop the _SolARPipelineLoader_ prefab (in SolAR/Prefabs) in your scene hierarchy. The _SolARPipelineLoader_ has the following parameters:\n\n* *Camera*: is the virtual camera whose position and orientation will be automatically updated at runtime according to the camera pose computed by the SolAR pipeline.\n* *Use Unity Webcam*: Check it if you want to replace the camera used by the pipeline by a Unity camera. If checked, you will be able to select a camera among those available on your computer. For a better experience, you can set the intrinsic parameters of the camera. For that, you will need to calibrate it (see >).\n* *Custom_Canvas*: For video see-through AR, the system has to display the video stream of the camera on background. If unchecked, a Canvas with the video stream of the selected camera will be automatically created when the application will start. If you want to manage yor canvas by yourself, you can check this option and drag and drop your canvas and its material.\n* *Select Pipeline Folder*: A button to select the folder where the available SolAR pipelines are stored in your Unity project. These pipelines must be stored anywhere under the folder _Assets/SolAR/Pipelines/_.\n\nSet your _SolARPipelineLoader_ by dragging and dropping your main camera from your scene hierarchy to the _Camera_ parameter in the _SolARPipelineLoader_ inspector. +\n +\nIt is time now to download pipeline samples to test the SolAR plugin in Unity !\n\n=== Test SolAR pipelines\n\nDownload the SolAR package with samples:\n\n* go on https://github.com/SolarFramework/SolARUnityPlugin/releases\n* click on Assets\n* click on SolARSamples_win.unitypackage\n\n'''\n\nThe samples will add or fill in the following folders in the Assets folder of your unity project:\n\n* `_Plugins_` : Host the binaries of the pipelines, their modules, and the third parties of the modules.\n* `_SolAR_`\n** `_Objects_` : Some 3D objects to augment the scene.\n** `_Pipelines_`: The xml configuration files for the different SolAR pipelines. It is mandatory to put these pipeline configuration file in or under this folder.\n** `_Scenes_`: Sample scenes for simply testing the SolAR plugin.\n** `_Scripts_`: Specific scripts required for the sample.\n* `_StreamingAssets_`\n*** `_CameraCalibration_`: Some camera calibration files used by the pipelines handling their own camera.\n*** `_Markers_`: files describing the markers. You can edit these files to provide the exact size of the markers defined in meters, or create them to add new markers. +\n\n'''\n\nNow you can load SolAR pipelines and choose one:\n\n* Select the _SolARPipelineLoader_ object in your scene hierachy.\n* Click on the _Select Pipelines Folder_ button in the inspector frame.\n* Select the folder _/Assets/SolAR/Pipelines_\n* Select the _PipelineFiducialMarker_.\n\nYou will see a list of parameters relative to the different components of the selected pipeline. A tooltip provides user with information relative to each parameter when he move the pointer over the parameter (only if the configuration file of the pipeline defines descriptions for the configuration parameters).\n\n'''\n\nThen you can put any object in your scene hierarchy to visualize it in augmentation (you can drag and drop the SolAR can available in the SolAR objects). The camera will automatically move relatively to the coordinate system of your marker (positionned in the center of the marker, x-axis pointing to the left, y-axis pointing to the top, z-axis pointing backward), so place your object in (0,0,0) if you want it to be positionned in the center of your marker.\n\nIMPORTANT: For each object with a renderer, add the TAG _SolARObject_ to make it disappear when the pose provided by the pipeline is wrong.\n\n'''\n\nFinally, you can print the following fiducial marker, play the application, and present the marker in front of the camera. That's it, you should visualize a virtual can appearing on your fiducial marker.\n\nimage::../use/images/FiducialMarker.gif[FiducialMarker,450,250,align=\"center\"]\n\nNow, stop the application, select the _SolARPipelineLoader_ object in your scene hierarchy, and select the _PipelineNaturalImageMarker_. Print the following image marker, and play the application. Changing pipeline is as simple as that ! +\n\nimage::../use/images/graf1.png[NaturalImageMarker,450,250,align=\"center\"]\n\nWARNING: For a better AR experience, it is preferable to enter the actual size of the marker in meters. You can do it by editing the marker files available in the folder _Assets/StreamingAssets/Markers/_. By editing these files, you will also be able to change the fiducial marker pattern or the image of reference for the natural image marker pipeline.\n\n== Full SolAR C# wrapper\n\n=== For whom ?\n\nFor vision expert who want ot directly assemble SolAR pipeline in Unity thanks to a full C# wrapping of SolAR.\n\n* go on https://github.com/SolarFramework/SolARUnityPlugin/releases\n* click on _Assets_\n* click on _SolARPlugin_win.unitypackage_\n\n=== Project Structure\nThe unitypackage adds our project’s hierarchy in your Unity project. +\n\n\n* `_Objects_` : our 3D object\n* `_Plugins_` : our DLLs from SolAR\n* `_Scenes_` : Expertversion scene\n* `_SolAR_`\n*** `_Editor_`\n**** `_SolARPluginExpert_' : own Editor inspector for our PipelineLoader\n*** `_Materials_`\n*** `_Pipelines_`\n*** `_Scripts_`\n**** `_SolARPluginExpert_` : all our C# scripts\n***** `_Samples_` : pipelines examples\n*** `_Shaders_`\n*** `_Swig_`\n**** `_SolARPluginExpert_` : full wrapping of SolAR\n* `_StreamingAssets_`\n*** `_CameraCalibration_` : `_design for our cameras_`\n*** `_Configuration_` : xml files for our pipelines\n*** `_Markers_` : files describing our markers. Print our markers or make yours.\n\n[.text-center]\n**Our Scene, our project's folders and some explanations*#\n[#img-expertEditor]\nimage::expertEditor.png[NewbieScene,800,300, align=\"center\"]\n\n=== Make your own pipelines\n\nWARNING: You have to be in Unity Editor with Expert version package imported.\n\nNOTE: We give you pipelines examples in Scripts/SolARPluginExpert/Samples +\n\n*To create a new pipeline :* +\n +\n\n* Create a new script C* \"MyPipeline.cs\"\n* Add *_using properties_* in your file that give you components available. (see example code)\n\n using SolAR.Datasctructure  //our Datasctructure\n using XPCF.Api              //XPCF is the heart of SolAR\n\n* Put your class in *_namespace_* *SolAR.Samples*\n\n namespace SolAR.SAmples {\n  class MyPipeline\n }\n\n* Your class have to base upon AbstractPipeline (C# interface)\n\n class MyPipeline : AbstractPipeline\n\n** This inheritance means you must use different methods.\n\n*** *A constructor* taking a IComponentManager as parameter. +\n    This constructor is the place where you instantiate your components.\n\n*** *GetMarkerSize()* method to define your marker size and use it at the basis of your pipeline.\n\n*** *SetCameraParameters(...)* method to give intrinsic and distorsion parameters to certain components.\n\n*** *Proceed* function. Core function of a pipeline where you have to connect components to each others.\n\nNOTE: Components have to be declare with *_readonly_* property\n\nWARNING: You have to create a new XML files to fix your pipeline configuration. +\n         Examples in StreamingAssets/Configuration.\n",
    id: 39
  });
  

index.add({
    title: "unity pipeline",
    content: ":page-layout: _auto\n:showtitle:\n:page-title: unity pipeline\n:page-description: unity pipeline\n:page-layout: default\n:page-category: assemble\n:page-liquid:\n:toc:\n\n== Assemble C++ pipeline for Unity\n\n== What is a C++ pipeline for Unity ?\nA C++ pipeline is a shared library embedding an implementation of the IPipeline interface defined by the SolAR framework. Thus, this pipeline can be loaded at run-time and run by any third party application such as a C++ application or by Unity. To provide configuration capabilities to a pipeline, it is considered by SolAR as a component embedded in a module. for this reason, readers are encouraged to have a look at the > section.\n\nWhile SolAR is dedicated to computer vision pipelines, for now, the pipeline interface is only dedicated to pose estimation pipeline. To be more specific, the pipelines built to be used in Unity are pipelines that take on hand camera frames and that deliver on the other hand camera pose estimation.\n\nNew pipeline interfaces will be soon added for other viion task such as 3D reconstruction, object recognition, etc.\n\n== Initialize your pipeline step-by-step_\n\n=== Create your pipeline project\n\n==== QT Creator\n\nOpen QTCreator and create a new project (in File menu).\n\nSelect `_Library_` and `_C++ Library_` and click on `_Choose_` button.\n\nimage::..\\create\\images\\QTCreatorCreateLibrary.png[create a shared C++ library in QT,600,600, align=\"center\", title=\"Project creation\"]\n\nThen, set the name of your project with the name of your pipeline, set the location (a dedicated folder with all pipeline projects is recommended) and select \"Shared Library\" for the type of the library.\n\nimage::images\\QTProjectLibraryCreation.png[select library type,600,600, align=\"center\", title=\"Project name, location and library type\"]\n\nNext, select your development kits. We recommend to use _MSVC 2017 64bit_ or _Clang_. Then, unselect all required modules. On the next window, keep the name of the class to create with the name of your module. Unfortunately, with the QT project creation wizard, you cannot set dedicated folders for headers and sources. As we recommend to put the header files in an \"interfaces\" folder and the source files in a \"src\" folder, you will have to create these two folders manually and move the two files (MyPipeline.h and MyPipeline.cpp) in their respective folder (interfaces and src). Finally go to the summary and click on \"Finish\".\n\nIf QT Creator has created a file called mypipeline_global.h, supress it.\n\nSolAR provide a smart and easy to use build and deployment system.\n\nNow, you need to select the file called \"MyPipeline.pro\" in your project tree, and replace the script by the following one:\n\n.MyPipeline.pro\n----\n## remove Qt dependencies\nQT       -= core gui\nCONFIG -= qt\n\n## global defintions : target lib name, version\nTARGET = MyPipeline #\nFRAMEWORK = $$TARGET\nVERSION=x.x.x #\n\nDEFINES += MYVERSION=$${VERSION}\nDEFINES += TEMPLATE_LIBRARY\nCONFIG += c++1z\n\n\nCONFIG(debug,debug|release) {\n    DEFINES += _DEBUG=1\n    DEFINES += DEBUG=1\n}\n\nCONFIG(release,debug|release) {\n    DEFINES += _NDEBUG=1\n    DEFINES += NDEBUG=1\n}\n\nDEPENDENCIESCONFIG = shared recurse\n\ninclude (../../builddefs/qmake/templatelibconfig.pri) #\n\n## DEFINES FOR MSVC/INTEL C++ compilers\nmsvc {\nDEFINES += \"_BCOM_SHARED=__declspec(dllexport)\"\n}\n\nINCLUDEPATH += interfaces/\n\nHEADERS += interfaces/MyPipeline.h #\n\nSOURCES += src/MyPipeline.cpp #\n\nunix {\n    QMAKE_CXXFLAGS += -Wignored-qualifiers\n    QMAKE_LINK=clang++\n    QMAKE_CXX = clang++\n}\n\nmacx {\n    DEFINES += _MACOS_TARGET_\n    QMAKE_MAC_SDK= macosx\n    QMAKE_CFLAGS += -mmacosx-version-min=10.7 -std=c11 #-x objective-c++\n    QMAKE_CXXFLAGS += -mmacosx-version-min=10.7 -std=c11 -std=c++11 -O3 -fPIC#-x objective-c++\n    QMAKE_LFLAGS += -mmacosx-version-min=10.7 -v -lstdc++\n    LIBS += -lstdc++ -lc -lpthread\n}\n\nwin32 {\n\n    DEFINES += WIN64 UNICODE _UNICODE\n    QMAKE_COMPILER_DEFINES += _WIN64\n    QMAKE_CXXFLAGS += -wd4250 -wd4251 -wd4244 -wd4275\n}\n\nheader_files.path = $${PROJECTDEPLOYDIR}/interfaces\nheader_files.files = $$files($${PWD}/interfaces/*.h*)\n\n# HOME variable =  C:\\User\\\nxpcf_xml_files.path = $$(HOME)/.xpcf/SolAR\nxpcf_xml_files.files=$$files($${PWD}/xpcf*.xml)\n\nINSTALLS += header_files\nINSTALLS += xpcf_xml_files\n----\n\nNow, just update the _.pro_ file:\n\n [white]#replace the TARGET by the name of your pipeline,#\n [white]#set the version number of your pipeline,#\n [white]#change the name of your header file when it is added to the _HEADERS_ variable,#\n [white]#change the name of your source file when it is added to the SOURCES_ variable.#\n [white]#check if the builddefs folder used to define the compilation pipeline is well referenced#\n\nIMPORTANT: In order to deploy your pipeline in the binary folder _${REMAKENROOT]/MyPipeline/MyPipelineVersion_ after building, in QT creator click in the left menu on _Projects_, then on _Build_, on _add a build step_ and select _Make_. Set the _Make Argument_ to the value _install_. Do it for both release and debug mode.\n\n====  -- Using Cmake instead of .pro QT file --\n\nCreate a CMakeLists.txt file and copy the following code to it.\nThis file use temporarily *BCOMDEVROOT* environment variable link to your SoLAR sources.\n\n.CMakeLists.txt\n----\ncmake_minimum_required(VERSION 3.7.2)\n\n##################################################\nset (VERSION_NUMBER \"x.x.x\") #\nproject(\"MyPipeline\") #\n\nset (HEADERS\n    interfaces/MyPipeline.h\n) #\n\nset (SOURCES\n    src/MyPipeline.cpp\n) #\n\ninstall (FILES \"${CMAKE_CURRENT_SOURCE_DIR}/MyPipelineConfiguration.xml\" DESTINATION $ENV{BCOMDEVROOT}/bcomBuild/$ENV{CMAKE_PROJECT_NAME}/$ENV{PROJECT_VERSION}/\t)  # \n\n##################################################\n\n# various macros\ninclude(\"$ENV{BCOMDEVROOT}/bcomBuild/SolARFramework/solarmacros.cmake\") #\n# config setup\nsetup()\n# process packagedependencies.txt\nprocessPackagedependencies()\n# define targets (type library)\ndefineTargets(\"library\" \"\")\n----\n\nnow, just update the _CMakeLists.txt_ file:\n\n [white]#set the name of the project with the name of your module,#\n [white]#set the version number of your module,#\n [white]#change the name of your header file when it is added to the _HEADERS_ variable,#\n [white]#change the name of your source file when it is added to the SOURCES_ variable.#\n [white]#update with the name of your > to copy it from your pipeline project to your deployment directory _${BCOMDEVROOT}/MyPipeline/MyPipelineVersion/_.#\n [white]#check that the _solarmacros.cmake_ file exists. This file must be install when you have launched the installer. If you decide to build the framework by yourself, this file will be copied in your _${BCOMDEVROOT}_ folder when you will build and install the _SolARFramework_ project.#\n\n\n=== Select your dependencies\n\nAs mentionned previously, SolAR framework provides developers with a building pipeline allowing among other things to easily manage dependencies (download, version management, packaging during deployment step, etc.).\n\nTo define the dependencies used by your pipeline, create a file called packagedependencies.txt at the root of your project.\n\nFollowing, an example of packagedependencies.txt file for a standalone pipeline using OpenCV module:\n\n/.packagedependencies.txt\n----\nxpcf|2.2.0|xpcf|artifactory|https://repository.b-com.com/amc-generic\nspdlog|0.14.0|spdlog|thirdParties|https://github.com/SolarFramework/binaries/releases/download\neigen|3.3.5|eigen|thirdParties|https://github.com/SolarFramework/binaries/releases/download\nSolARFramework|0.6.0|SolARFramework|github|https://github.com/SolarFramework/SolarFramework/releases/download\nSolARModuleTools|0.6.0|SolARModuleTools|github|https://github.com/SolarFramework/SolARModuleTools/releases/download\nSolARModuleOpenCV|0.6.0|SolARModuleOpenCV|github|https://github.com/SolarFramework/SolARModuleOpenCV/releases/download\nopencv|3.4.3|opencv|thirdParties|https://github.com/SolarFramework/binaries/releases/download\n----\n\nHere is the syntax for each dependency:\n----\nDirectory|version|name|local location|remote location\n----\n\nartifactory refers to .remaken/packages//   folder. You can create a REMAKENROOT variable. All process are made in this folder.\n\nIf you need new modules please refer to the > section, and if you need more third parties, please refer to the > section.\n\nIMPORTANT: xpcf, boost, spdlog, eigen and SolARFramework are mandatory third parties for assembling a pipeline.\n\nNumerous samples of packagedependencies.txt files can be found with the SolAR Samples you have surely installed on your machine.\n\n=== Create the configuration file [[PipelineConfigurationFile]]\n\nhis file will be used at run-time. It will allow XPCF to load Module components and configure them at run-time. So you can experiment different implementations and configurations of a pipeline without the need to recompile your application.\n\nCreating a configuration file is very easy.\nOnce you have identified the modules and the components required to assemble your pipeline, just record them in the xml configuration file.\n\nFollowing, an example of a configuration file for a pipeline using the camera and image viewer components embedded in the _SolARModuleOpenCV_ module :\n\n.MyPipelineConfiguration.xml\n[source,xml]\n----\n\n\n\n\n  \n    \n    \n  \n\n\n  \n    \n    \n  \n\n\n  \n    \n    \n  \n  \n    \n    \n  \n\n\n\n  \n    \n    \n  \n\n\n\n----\n [white]#Add the modules used by your pipeline. To get information concerning the modules, have a look to their registry file available in the _${REMAKENROOT}/\"ModuleName\"/\"ModuleVersion\"/_.#\n [white]#For each module, add the components used by your pipeline. To get information concerning the components, have a look to the registry file of their module available in the _${REMAKENROOT}/\"ModuleName\"/\"ModuleVersion\"/_.#\n [white]#Optionally, add a configuration to your components. The name of your configuration parameters are generally the name of the variable in the class definition of the component without the prefix \"m_\". The type of the configuration parameters are simple types such as \"String\", \"Integer\", \"Float\", \"Double\", or array of these simple types.#\n\nExamples of such configuration files are available in the samples directory that is provided with the SolAR installation.\n\n== Implement your pipeline\n\n=== IPipeline API\n\nA virtual class named IPipeline has been defined in SolAR framework and is located in  [aqua]#api/pipeline/IPipeline.h# . +\nAny SolAR pipeline should implement this class, that means that six methods are to be implemented in the corresponding source code :\n\n* *init*: Initialize the pipeline by providing a reference to the component manager loaded by the PipelineManager. You will have to instantiate all the components used by your pipeline and initialize by for instance starting the camera, initialize component with intrinsic parameter of the camera, etc.\n* *getCameraParameters*: Provide third party applications with the calibration parameters of the camera. Useful hen you want to set the parameter of the virtual camera with the ones from the real one.\n* *start*: Start the pipeline with a texture buffer that will be updated when a new frame will be processed and ready for display.\n* *stop*: Stop the pipeline.\n* *update*: A methode that provide the new pose of the camera.\n* *loadSourceImage*: If there is no camera in your pipeline, you can feed it with an external image (for instance, an image capture by the Unity web camera).\n\nA full description of these methods is available in the [aqua]#api/pipeline/IPipeline.h# file.\n\n=== Pipeline Template\n\nTo implement your pipeline, you have to fill in the header file _MyPipeline.h_ and the source file _MyPipeline.cpp_. Next, we provide you with templates for these to files.\n\n.MyPipeline.h\n[source, cpp]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n#ifndef MYPIPELINE_H\n#define MYPIPELINE_H\n\n// \n#if _WIN32\n#ifdef MyPipeline_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllexport)\n#else //MYPIPELINE_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllimport)\n#endif //MYPIPELINE_API_DLLEXPORT\n#else //_WIN32\n#define MYPIPELINE_EXPORT_API\n#endif //_WIN32\n\n// Mandatory include file // \n#include \"xpcf/core/traits.h\"\n#include \"xpcf/component/ConfigurableBase.h\"\n#include \"api/pipeline/IPipeline.h\"\n#include \"xpcf/threading/BaseTask.h\"\n\n// Add here the header file for the data structures required by your pipeline\n// e.g. #include \"datastructure/Image.h\"\n// \n\n// Add here the header file for the component interfaces required by your pipeline\n// e.g. #include \"api/input/devices/ICamera.h\"\n// \n\nnamespace SolAR { // \nusing namespace datastructure;\nusing namespace api;\nnamespace PIPELINES {\n\n/**\n * @class MyPipeline\n * @brief A short description of your pipeline\n */\n// \nclass MYPIPELINE_EXPORT_API MyPipeline : public org::bcom::xpcf::ConfigurableBase,\n    public api::pipeline::IPipeline\n{\npublic:\n    MyPipeline();\n    ~MyPipeline();\n\n    //// @brief Initialization of the pipeline\n    /// Initialize the pipeline by providing a reference to the component manager loaded by the PipelineManager.\n    /// @param[in] componentManager a shared reference to the component manager which has loaded the components and configuration in the pipleine manager\n    FrameworkReturnCode init(SRef xpcfComponentManager) override;\n\n    /// @brief Provide the camera parameters\n    /// @return the camera parameters (its resolution and its focal)\n    pipeline::CameraParameters getCameraParameters() override;\n\n    /// @brief Starts the pipeline and provides a texture buffer which will be updated when required.\n    /// @param[in] textureHandle a pointer to the texture buffer which will be updated at each call of the update method.\n    FrameworkReturnCode start(void* imageDataBuffer) override;\n\n    /// @brief Stop the pipeline.\n    FrameworkReturnCode stop() override;\n\n    /// @brief update the pipeline\n    /// Get the new pose and update the texture buffer with the image that has to be displayed\n    SinkReturnCode update(Transform3Df& pose) override;\n\n    /// @brief load the source image\n    SourceReturnCode loadSourceImage(void* sourceTextureHandle, int width, int height) override;\n\n    void unloadComponent () override final;\n\nprivate:\n  // Add here the declaration of the shared references on components required by your pipeline (e.g. SRef m_camera;)\n  // \n\n  // Threads // \n  bool pipelineLoop();\n  xpcf::DelegateTask* m_pipelineLoopTask = nullptr;\n\n  // optionally, add here some parameters of you rmodule that can be configured\n  // int m_myPipelineParameter; // \n};\n\n}\n}\n\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::PIPELINES::MyPipeline, // \n                             \"\",\n                             \"My pipeline\",\n                             \"A sample pipeline used for documentation\");\n\n#endif // MYPIPELINE_H\n----\n [white]#Add the required declarations to export the pipeline functions embedded in your shared library. Just replace in a case sensitive manner \"MyModule\" by the name of your module.#\n [white]#These include files are mandatory. They correspond to the xpcf traits file as here we declare the module traits directly in this file, to the XPCF configurableBase header file if you want to configure your pipeline through an external xml file, and to the SolAR IPipeline header file, as your pipeline implement this SolAR interface.#\n [white]#The header files of the SolAR data structures required to connect your components.#\n [white]#The header files of the SolAR component interfaces required by your pipeline.#\n [white]#SolAR and XPCF namespaces directives to shorten the calls to SolAR api and data structures.#\n [white]#Declare your pipeline class, and add the functions defined as abstract in the IPipeline interface.#\n [white]#Declaration of the components used by the pipeline (thanks to their abstract interfaces). We are using a shared reference of the components to ease their use in multi-threaded pipelines.#\n [white]#Declare a xpcf task and the function running the pipeline loop in a dedicated thread.\n [white]#You can declare parameters for the pipeline. Some of these parameters may be configurable.#\n [white]#Finally, add the trait of your pipeline. To generate an UUID, you can use a https://www.uuidgenerator.net/[online UUID generator]#\n\n.MyPipeline.cpp\n[source, code]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n// Mandatory header file // \n#include \"xpcf/module/ModuleFactory.h\"\n#include \"core/Log.h\"\n\n// Header to your pipeline declaration // \n#include \"MyPipeline.h\"\n\n// Add here the headers to the traits of the module used by your pipeline // \n// e.g. #include \"SolARModuleOpencv_traits.h\"\n\nnamespace xpcf=org::bcom::xpcf;\n\n// Declaration of the module embedding MyPipeline // \nXPCF_DECLARE_MODULE(\"\", \"MyPipelineModule\", \"The module embedding MyPipeline\")\n\n// Add this function required by the XPCF component factory // \nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid& componentUUID,SRef& interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n    errCode = xpcf::tryCreateComponent(componentUUID,interfaceRef);\n\n    return errCode;\n}\n\n// Add the declaration of the component (here a pipeline) to XPCF // \nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::PIPELINES::MyPipeline)\nXPCF_END_COMPONENTS_DECLARATION\n\n// Macro used by the XPCF factory to define a component/pipeline // \nXPCF_DEFINE_FACTORY_CREATE_INSTANCE(SolAR::PIPELINES::MyPipeline)\n\nnamespace SolAR { // \nusing namespace datastructure;\nusing namespace api::pipeline;\nnamespace PIPELINES {\n\nMyPipeline::MyPipeline():ConfigurableBase(xpcf::toUUID())\n{\n   addInterface(this);\n   // Add here the mapping to make configurable some attributes of your pipeline\n   // SRef params = getPropertyRootNode();\n   // params->wrapInteger(\"myPipelineParameter\", m_myPipelineParameter);\n   // \n}\n\nMyPipeline::~MyPipeline()\n{\n\n}\n\nbool MyPipeline::pipelineLoop() //\n{\n  // ADD HERE the code connecting the component of your pipeline\n\n  return true;\n}\n\nFrameworkReturnCode MyPipeline::init(SRef xpcfComponentManager)\n{\n  try {\n    // ADD HERE: instantiate concrete components and bind them to abstract component interfaces\n    // \n    // e.g. SRef camera = xpcfComponentManager->create()->bindTo();\n\n  }\n  catch (xpcf::Exception e)\n  {\n     LOG_WARNING(\"One or more components cannot be created: {}\", e.what());\n     return FrameworkReturnCode::_ERROR_;\n  }\n\n  // ADD HERE: The pipeline initialization\n  // \n  return FrameworkReturnCode::_SUCCESS;\n}\n\nCameraParameters MyPipeline::getCameraParameters()\n{\n  CameraParameters camParam;\n  // ADD HERE the code to return camera parameters\n\n  return camParam;\n}\n\nSourceReturnCode MyPipeline::loadSourceImage(void* sourceTextureHandle, int width, int height)\n{\n   // ADD HERE the code to take external image as input of your pipeline\n\n   return SourceReturnCode::_NOT_IMPLEMENTED;\n}\n\n\nFrameworkReturnCode MyPipeline::start(void* imageDataBuffer)\n{\n  // ADD HERE the code to start your pipeline\n\n  // create and start a thread for the loop of the pipeline // \n  auto pipelineLoopThread = [this](){;pipelineLoop();};\n  m_pipelineLoopTask = new xpcf::DelegateTask(pipelineLoopThread);\n  m_pipelineLoopTask->start();\n\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nFrameworkReturnCode MyPipeline::stop()\n{\n  // ADD HERE the code to stop your pipeline\n  if (m_pipelineLoopTask != nullptr)\n    m_pipelineLoopTask->stop(); // \n  return FrameworkReturnCode::_SUCCESS;\n}\n\nSinkReturnCode MyPipeline::update(Transform3Df& pose)\n{\n  // ADD HERE the code to update the pose of the camera\n\n  return SinkReturnCode::_NOT_IMPLEMENTED;\n}\n\n}\n}\n----\n [white]#Required header file corresponding to the XPCF module factory.#\n [white]#Obviously, add the header file corresponding to your pipeline declaration.#\n [white]#Add the trait header files for the modules required by your pipeline.#\n [white]#Declare your module to XPCF. generate a UUID for your module by using an https://www.uuidgenerator.net/[online UUID generator].#\n [white]#Implement the method _XPCF_getComponent_ required by the XPCF factory to instantiate the componen t(here a pipeline).#\n [white]#Add your component/pipeline to XPCF.#\n [white]#Add the definition of your pipeline to the XPCF component factory.#\n [white]#Embed your pipeline in the _SolAR/PIPELINES_ namespace.#\n [white]#To add a configurable parameter and map it to the xml configuration file, retrieve a reference to the properties of the component/pipeline, and add a wrapper for each configuration parameter you want to map. Here, when an xml element with the name \"myPipelineParameter\" of type integer will be specified in the configuration file, when exiting the constructor, its value will be set to the attribute _m_myPipelineParameter_.#\n [white]#Implement the loop of the pipeline by connecting components. This loop will run in a dedicated thread.#\n [white]#Instantiate all components required by your pipeline here.#\n [white]#If required, add the code to initialize your pipeline (e.g. load a reference image, initialize some component with the intrinsic parameters of the camera, etc.).#\n [white]#Start the pipeline loop thread when the start method is called.#\n [white]#Stop the pipeline loop thread when the stop method is called.#\n\n=== Pipeline sample\nWe will present next the implementation of the simplest pipeline that consists in capturing an image from a camera and make it available for a third party application. For this implementation, we will need only one module: SolARModuleOpenCV.\n\n.MyPipeline.h\n[source, cpp]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n#ifndef MYPIPELINE_H\n#define MYPIPELINE_H\n\n#if _WIN32\n#ifdef MyPipeline_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllexport)\n#else //MYPIPELINE_API_DLLEXPORT\n#define MYPIPELINE_EXPORT_API __declspec(dllimport)\n#endif //MYPIPELINE_API_DLLEXPORT\n#else //_WIN32\n#define MYPIPELINE_EXPORT_API\n#endif //_WIN32\n\n// Mandatory include file\n#include \"xpcf/core/traits.h\"\n#include \"xpcf/component/ConfigurableBase.h\"\n#include \"api/pipeline/IPipeline.h\"\n#include \"xpcf/threading/BaseTask.h\"\n\n// Add here the header file for the data structures required by your pipeline\n// e.g. #include \"datastructure/Image.h\"\n#include \"datastructure/Image.h\" // \n\n// Add here the header file for the component interfaces required by your pipeline\n// e.g. #include \"api/input/devices/ICamera.h\" // \n#include \"api/input/devices/ICamera.h\"\n#include \"api/sink/ISinkPoseImage.h\"\n#include \"api/source/ISourceImage.h\"\n\n\n\nnamespace SolAR {\nusing namespace datastructure;\nusing namespace api;\nnamespace PIPELINES {\n\n/**\n * @class MyPipeline\n * @brief A short description of your pipeline\n */\nclass MYPIPELINE_EXPORT_API MyPipeline : public org::bcom::xpcf::ConfigurableBase,\n    public api::pipeline::IPipeline\n{\npublic:\n    MyPipeline();\n    ~MyPipeline();\n\n    //// @brief Initialization of the pipeline\n    /// Initialize the pipeline by providing a reference to the component manager loaded by the PipelineManager.\n    /// @param[in] componentManager a shared reference to the component manager which has loaded the components and configuration in the pipleine manager\n    FrameworkReturnCode init(SRef xpcfComponentManager) override;\n\n    /// @brief Provide the camera parameters\n    /// @return the camera parameters (its resolution and its focal)\n    pipeline::CameraParameters getCameraParameters() override;\n\n    /// @brief Starts the pipeline and provides a texture buffer which will be updated when required.\n    /// @param[in] textureHandle a pointer to the texture buffer which will be updated at each call of the update method.\n    FrameworkReturnCode start(void* imageDataBuffer) override;\n\n    /// @brief Stop the pipeline.\n    FrameworkReturnCode stop() override;\n\n    /// @brief update the pipeline\n    /// Get the new pose and update the texture buffer with the image that has to be displayed\n    SinkReturnCode update(Transform3Df& pose) override;\n\n    /// @brief load the source image\n    SourceReturnCode loadSourceImage(void* sourceTextureHandle, int width, int height) override;\n\n    void unloadComponent () override final;\n\nprivate:\n  // Add here the declaration of the shared references on components required by your pipeline (e.g. SRef m_camera;)\n  SRef m_camera; // \n  SRef m_sink;\n  SRef m_source;\n\n  // Threads\n  bool pipelineLoop();\n  xpcf::DelegateTask* m_pipelineLoopTask = nullptr;\n\n  // optionally, add here some parameters of your module that can be configured\n  // int m_myPipelineParameter;\n\n  // Other attributes\n  bool m_externalInputImageMode = false; // \n};\n\n}\n}\n\n\nXPCF_DEFINE_COMPONENT_TRAITS(SolAR::PIPELINES::MyPipeline,\n                             \"855c83b7-f4ec-48ab-8e89-56018ea9e169\",\n                             \"My pipeline\",\n                             \"A sample pipeline used for documentation\");\n\n#endif // MYPIPELINE_H\n----\n [white]#include the header file of a SolAR image to connect the camera component to the sink component.#\n [white]#include the component interface headers for a camera component, a sink component and a source component. A sink component handles an output buffer feed by the pipeline a read by external third parties. Reciprocally, a source component handles an input buffer feeds by external third parties and used by the pipeline.#\n [white]#Declaration of the three components used by this pipeline, a camera, a sink component handling the pose and the output image, and a source component handling an input image.#\n [white]#Add an attribute to know if the pipeline use as input an image coming from a third party.#\n\n.MyPipeline.cpp\n[source, cpp]\n----\n/**\n * Information concerning the copyright and licence of your pipeline\n */\n\n// Mandatory header file\n#include \"xpcf/module/ModuleFactory.h\"\n#include \"core/Log.h\"\n\n// Header to your pipeline declaration\n#include \"MyPipeline.h\"\n\n// Add here the headers to the traits of the module used by your pipeline\n// e.g. #include \"SolARModuleOpencv_traits.h\"\n#include \"SolARModuleOpencv_traits.h\" // \n#include \"SolARModuleTools_traits.h\"\n\nnamespace xpcf=org::bcom::xpcf;\n\n// Declaration of the module embedding MyPipeline\nXPCF_DECLARE_MODULE(\"855c83b7-f4ec-48ab-8e89-56018ea9e169\", \"MyPipelineModule\", \"The module embedding MyPipeline\")\n\n// Add this function required by the XPCF component factory\nextern \"C\" XPCF_MODULEHOOKS_API xpcf::XPCFErrorCode XPCF_getComponent(const boost::uuids::uuid& componentUUID,SRef& interfaceRef)\n{\n    xpcf::XPCFErrorCode errCode = xpcf::XPCFErrorCode::_FAIL;\n    errCode = xpcf::tryCreateComponent(componentUUID,interfaceRef);\n\n    return errCode;\n}\n\n// Add the declaration of the component (here a pipeline) to XPCF\nXPCF_BEGIN_COMPONENTS_DECLARATION\nXPCF_ADD_COMPONENT(SolAR::PIPELINES::MyPipeline)\nXPCF_END_COMPONENTS_DECLARATION\n\n// Macro used by the XPCF factory to define a component/pipeline\nXPCF_DEFINE_FACTORY_CREATE_INSTANCE(SolAR::PIPELINES::MyPipeline)\n\nnamespace SolAR {\nusing namespace datastructure;\nusing namespace api::pipeline;\nnamespace PIPELINES {\n\nMyPipeline::MyPipeline():ConfigurableBase(xpcf::toUUID())\n{\n   addInterface(this);\n   // Add here the mapping to make configurable some attributes of your pipeline\n   // SRef params = getPropertyRootNode();\n   // params->wrapInteger(\"myPipelineParameter\", m_myPipelineParameter);\n}\n\nMyPipeline::~MyPipeline()\n{\n\n}\n\nbool MyPipeline::pipelineLoop() //\n{\n  // ADD HERE the code connecting the component of your pipeline\n  SRef image;\n\n  if (m_externalInputImageMode)\n  {\n    if (m_source->getNextImage(image) == SourceReturnCode::_NEW_IMAGE)\n      m_sink->set(image);\n  }\n  else\n  {\n    if (m_camera->getNextImage(image) == SolAR::FrameworkReturnCode::_ERROR_LOAD_IMAGE)\n      return false;\n    m_sink->set(image);\n  }\n  return true;\n}\n\nFrameworkReturnCode MyPipeline::init(SRef xpcfComponentManager)\n{\n  try {\n    // ADD HERE: instantiate concrete components and bind them to abstract component interfaces\n    // e.g. SRef camera = xpcfComponentManager->create()->bindTo();\n    // \n    m_camera = xpcfComponentManager->create()->bindTo();\n    m_sink = xpcfComponentManager->create()->bindTo();\n    m_source = xpcfComponentManager->create()->bindTo();\n  }\n  catch (xpcf::Exception e)\n  {\n     LOG_WARNING(\"One or more components cannot be created: {}\", e.what());\n     return FrameworkReturnCode::_ERROR_;\n  }\n\n  // ADD HERE: The pipeline initialization\n\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nCameraParameters MyPipeline::getCameraParameters()\n{\n  CameraParameters camParam;\n  // ADD HERE the code to return camera parameters\n  if (m_camera) // \n    {\n        camParam  m_camera->getCameraParameters();\n    }\n  return camParam;\n}\n\nSourceReturnCode MyPipeline::loadSourceImage(void* sourceTextureHandle, int width, int height)\n{\n   // ADD HERE the code to take external image as input of your pipeline\n   m_externalInputImageMode = true; // \n   return m_source->setInputTexture((unsigned char *)sourceTextureHandle, width, height);\n}\n\n\nFrameworkReturnCode MyPipeline::start(void* imageDataBuffer)\n{\n  // ADD HERE the code to start your pipeline\n  m_sink->setImageBuffer((unsigned char*)imageDataBuffer); // \n\n  if (m_camera->start() != FrameworkReturnCode::_SUCCESS) // \n    return FrameworkReturnCode::_ERROR_;\n\n  // create and start a thread for the loop of the pipeline\n  auto pipelineLoopThread = [this](){;pipelineLoop();};\n  m_pipelineLoopTask = new xpcf::DelegateTask(pipelineLoopThread);\n  m_pipelineLoopTask->start();\n\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nFrameworkReturnCode MyPipeline::stop()\n{\n  // ADD HERE the code to stop your pipeline\n  if (m_pipelineLoopTask != nullptr)\n    m_pipelineLoopTask->stop();\n  return FrameworkReturnCode::_SUCCESS;\n}\n\nSinkReturnCode MyPipeline::update(Transform3Df& pose)\n{\n  // ADD HERE the code to update the pose of the camera\n\n  return SinkReturnCode::_NOT_IMPLEMENTED;\n}\n\n}\n}\n----\n [white]#As we will only need _SolARModuleOpenCV_ and _SolARModuleTools_ for this pipeline, we add their trait header files.#\n [white]#Implementation of the pipeline loop. If an input image has been updated, we will access to it through the source component and we pass it to the sink component. If not, we read the last image captured by the camera and we pass it to the sink component.#\n [white]#We instantiate the 3 components required for this pipeline.#\n [white]#A simple code to get camera parameters and return it.#\n [white]#Set the _m_externalInputImageMode_ to true to inform the pipeline that it run with external input images, and put the image in the buffer of the source component.#\n [white]#Set the image buffer for the sink component.#\n [white]#Start the camera.#\n\n== Export your pipeline for Unity\n\nFirst of all, you must follow the installation instructions of Unity and of the SolAR plugin for unity available in the section >.\n\nThen, copy the shared binaries of your pipeline, of its modules and of the dependencies of its modules in the _Assets/Plugins_ folder of your Unity project.\n\nCopy the configuration file of your pipeline in the _Assets/SolAR/Pipelines_ folder of your Unity project. When copied, edit the configuration file and replace all module paths so they are relative to your Unity project (_./Assets/Plugins_).\n\nNow, in the Unity editor, you can select again your pipeline folder in the inspector of your SolARPipelineLoader, and select in the pipeline list your pipeline.\n\nIf you want to export your pipeline, create a new Unity package with:\n\n* The shared binaries stored in the Unity plugin folder relative to:\n** Your pipeline\n** The modules used by your pipeline\n** The third parties of the modules used by your pipeline\n* The pipleline configuration file stored under _Assets/SolAR/Pipelines/_.\n\n== Test your pipeline in C++\n\nTo test your pipeline in C++, have a look to the section >.\n",
    id: 40
  });
  




  
  
  



var store = [];

  
store.push({"title": "GIT",
  "link": "https://solarframework.github.io///community/GIT/"
});

  
store.push({"title": "About",
  "link": "https://solarframework.github.io///about/"
});

  
store.push({"title": "API",
  "link": "https://solarframework.github.io///create/api/"
});

  
store.push({"title": "api",
  "link": "https://solarframework.github.io///assemble/api/"
});

  
store.push({"title": "best practises",
  "link": "https://solarframework.github.io///community/best_practices/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///create/build/"
});

  
store.push({"title": "create a component",
  "link": "https://solarframework.github.io///create/component/"
});

  
store.push({"title": "contribution workflow",
  "link": "https://solarframework.github.io///community/contribution_workflow/"
});

  
store.push({"title": "C++",
  "link": "https://solarframework.github.io///use/cplusplus/"
});

  
store.push({"title": "create a component",
  "link": "https://solarframework.github.io///community/create_component/"
});

  
store.push({"title": "C#",
  "link": "https://solarframework.github.io///use/csharp/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///feed.xml"
});

  
store.push({"title": "get modules",
  "link": "https://solarframework.github.io///assemble/get_modules/"
});

  
store.push({"title": "getting started",
  "link": "https://solarframework.github.io///community/getting_started/"
});

  
store.push({"title": "getting started linux",
  "link": "https://solarframework.github.io///community/old/getting_started_linux/"
});

  
store.push({"title": "getting started windows",
  "link": "https://solarframework.github.io///community/old/getting_started_windows/"
});

  
store.push({"title": "hidden",
  "link": "https://solarframework.github.io///community/old/hidden/"
});

  
store.push({"title": "how it works",
  "link": "https://solarframework.github.io///community/how_it_works/"
});

  
store.push({"title": "Community",
  "link": "https://solarframework.github.io///community/"
});

  
store.push({"title": "Create",
  "link": "https://solarframework.github.io///create/"
});

  
store.push({"title": "Use",
  "link": "https://solarframework.github.io///use/"
});

  
store.push({"title": "Assemble",
  "link": "https://solarframework.github.io///assemble/"
});

  
store.push({"title": "Home",
  "link": "https://solarframework.github.io///"
});

  
store.push({"title": "install",
  "link": "https://solarframework.github.io///create/install/"
});

  
store.push({"title": "How to install",
  "link": "https://solarframework.github.io///assemble/install/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///js/lunr-feed.js"
});

  
store.push({"title": "Made with SolAR",
  "link": "https://solarframework.github.io///made_with_solAR/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///assets/styles/main.css"
});

  
store.push({"title": "create module",
  "link": "https://solarframework.github.io///create/module/"
});

  
store.push({"title": "package &amp; download third parties",
  "link": "https://solarframework.github.io///argodoc/packageanddownload/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///assemble/project_file/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///js/search.js"
});

  
store.push({"title": "Search",
  "link": "https://solarframework.github.io///search/"
});

  
store.push({"title": "standalone pipeline",
  "link": "https://solarframework.github.io///assemble/standalone_c_plus_plus/"
});

  
store.push({"title": "Tags",
  "link": "https://solarframework.github.io///tags/"
});

  
store.push({"title": "module tests",
  "link": "https://solarframework.github.io///create/tests/"
});

  
store.push({"title": null,
  "link": "https://solarframework.github.io///create/third_parties_packaging/"
});

  
store.push({"title": "tools",
  "link": "https://solarframework.github.io///use/tools/"
});

  
store.push({"title": "tutorials",
  "link": "https://solarframework.github.io///use_it/tutorials/"
});

  
store.push({"title": "unity",
  "link": "https://solarframework.github.io///use/unity/"
});

  
store.push({"title": "unity pipeline",
  "link": "https://solarframework.github.io///assemble/unity_pipeline/"
});



  
  
  


function searchAndDisplay(query){
  var resultdiv = $('#results');
  var result = index.search(query);
  // Show results
  resultdiv.empty();
  // Add status
  resultdiv.prepend('<p class="">Found '+result.length+' result(s)</p>');
  // Loop through, match, and add results
  for (var item in result) {
    var ref = result[item].ref;
    var searchitem = '<div class="result"><div class="result-body"><li><a href="'+store[ref].link+'" class="post-title">'+store[ref].title+'</a></li></div>';
    resultdiv.append(searchitem);
  }
}

// builds search
$(document).ready(function() {
    var query = (decodeURI(location.search).split("q" + '=')[1] || '').split('&')[0];
    var formattedQuery = query.split("+").join(" ");
    searchAndDisplay(formattedQuery);

    $('input#search').on('keyup', function () {
      var query = $(this).val();
      searchAndDisplay(query);
    });
});
